<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Evolution Simulation</title>
    <style>
        /* Basic Resets & Body Styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000; /* Fallback for very old browsers, actual background drawn on canvas */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Full viewport height */
            width: 100vw; /* Full viewport width */
            position: relative; /* For absolute positioning of UI */
            user-select: none; /* Prevent text selection during dragging */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Canvas Styles */
        canvas {
            display: block;
            width: 100%;
            height: 100%; /* Canvas will fill the flex container */
            background-color: transparent; /* Canvas background will be drawn dynamically */
            cursor: grab; /* Indicate draggable */
        }
        canvas.dragging {
            cursor: grabbing;
        }

        /* UI Panel (God Panel) Styles */
        #ui-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark background */
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); /* Glowing effect */
            max-width: 300px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 0.9em;
            max-height: calc(100vh - 40px); /* Prevent panel from overflowing on smaller screens */
            overflow-y: auto; /* Enable scrolling for panel if content is too long */
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; /* Smooth collapse */
            transform: translateX(0); /* Default: visible */
            opacity: 1;
        }

        #ui-panel.hidden {
            transform: translateX(100%); /* Slide out to the right */
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }

        #ui-panel h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
            text-align: center;
        }

        .param-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .param-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #ccc;
        }

        .param-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none; /* Override default slider styles */
            height: 8px;
            border-radius: 5px;
            background: #555;
            outline: none;
            opacity: 0.7;
            -webkit-transition: .2s;
            transition: opacity .2s;
        }

        /* Slider Thumb Styles */
        .param-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 5px #0ff;
        }

        .param-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #0ff;
            cursor: pointer;
            box-shadow: 0 0 5px #0ff;
        }

        /* Common Button Styles */
        .ui-button {
            padding: 10px 15px;
            font-size: 1em;
            font-weight: bold;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
            text-align: center;
        }

        .ui-button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .ui-button:active {
            transform: translateY(0);
        }

        /* Specific Button Margins */
        #start-pause-button, #toggle-panel-button {
            margin-top: 10px;
        }

        /* Zoom Controls */
        #zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            z-index: 9; /* Below God Panel */
            display: flex;
            gap: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(100%); /* Hidden by default */
            opacity: 0;
            pointer-events: none;
        }

        #zoom-controls.visible {
            transform: translateX(0); /* Slide up */
            opacity: 1;
            pointer-events: auto;
        }

        #zoom-controls .ui-button {
            font-size: 1.5em; /* Larger icons for zoom */
            padding: 8px 15px;
            min-width: 45px;
            line-height: 1; /* Center text vertically */
        }

        /* Show Panel Button */
        #show-panel-button {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9; /* Below God Panel, but above zoom controls if on mobile */
            background-color: rgba(0, 0, 0, 0.7); /* Match other UI */
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(100%); /* Hidden by default */
            opacity: 0;
            pointer-events: none; /* Disabled until visible */
            padding: 12px 20px; /* Make it more prominent than zoom buttons */
        }

        #show-panel-button.visible {
            transform: translateX(0); /* Slide in */
            opacity: 1;
            pointer-events: auto;
        }

        /* Stats Panel */
        #stats-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5); /* Different glow for stats */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 5px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            font-size: 0.9em;
        }

        #stats-panel div {
            display: flex;
            justify-content: space-between;
            color: #ccc;
        }

        #stats-panel strong {
            color: #fff;
            text-shadow: 0 0 3px #fff;
        }

        /* Game Over Overlay */
        #game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 20; /* Above all other UI */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            text-shadow: 0 0 10px #f00;
            font-size: 1.2em;
            text-align: center;
            pointer-events: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }

        #game-over-overlay.visible {
            opacity: 1;
            pointer-events: auto; /* Enable interaction when visible */
        }

        #game-over-overlay h1 {
            color: #f00;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #f00, 0 0 20px #f00;
        }

        #game-over-overlay p {
            margin: 5px 0;
            font-size: 1.1em;
            color: #ccc;
        }

        #game-over-overlay .final-stats {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            max-width: 80%;
            display: inline-block; /* To shrink to content */
        }
        #game-over-overlay .final-stats strong {
            color: #0ff; /* Bright color for stats */
        }

        #game-over-overlay button {
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
            color: #000;
        }
        #game-over-overlay button:hover {
            background-color: #00cc00;
        }


        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            #ui-panel {
                top: auto;
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: unset;
                max-height: 40vh; /* Limit height on mobile */
                padding: 10px;
            }

            #ui-panel.hidden {
                transform: translateY(100%); /* Slide down on mobile */
                opacity: 0;
            }

            #ui-panel h2 {
                font-size: 1.2em;
                margin-bottom: 10px;
            }

            .ui-button {
                padding: 10px 15px;
                font-size: 1em;
            }

            #zoom-controls {
                top: 10px; /* Move to top right on mobile */
                bottom: auto;
                left: auto;
                right: 10px;
                transform: translateX(100%); /* Hidden by default for mobile (slides right) */
            }
            #zoom-controls.visible {
                transform: translateX(0); /* Visible for mobile */
            }

            #show-panel-button {
                top: 70px; /* Position below zoom controls on mobile */
                right: 10px;
            }

            #stats-panel {
                top: 10px;
                left: 10px;
                padding: 10px;
            }

            #game-over-overlay h1 {
                font-size: 2em;
            }
            #game-over-overlay p {
                font-size: 0.9em;
            }
            #game-over-overlay button {
                padding: 10px 20px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-panel">
        <h2>Ecosystem God Panel</h2>
        <button id="start-pause-button" class="ui-button">Start Simulation</button>
        <button id="toggle-panel-button" class="ui-button">Hide Panel</button>

        <div class="param-group">
            <label for="timeScale">World Speed: <span id="timeScaleValue"></span></label>
            <input type="range" id="timeScale" min="0.1" max="5" step="0.1">
        </div>

        <div class="param-group">
            <label for="mutationRate">Mutation Rate: <span id="mutationRateValue"></span></label>
            <input type="range" id="mutationRate" min="0.001" max="0.1" step="0.001">
        </div>

        <div class="param-group">
            <label for="foodSpawnRate">Food Spawn Rate: <span id="foodSpawnRateValue"></span></label>
            <input type="range" id="foodSpawnRate" min="0.1" max="2" step="0.1">
        </div>

        <div class="param-group">
            <label for="foodEnergy">Food Energy: <span id="foodEnergyValue"></span></label>
            <input type="range" id="foodEnergy" min="10" max="200" step="5">
        </div>

        <div class="param-group">
            <label for="preyTargetPopulation">Prey Target Pop: <span id="preyTargetPopulationValue"></span></label>
            <input type="range" id="preyTargetPopulation" min="50" max="500" step="10">
        </div>

        <div class="param-group">
            <label for="predatorTargetPopulation">Predator Target Pop: <span id="predatorTargetPopulationValue"></span></label>
            <input type="range" id="predatorTargetPopulation" min="10" max="100" step="5">
        </div>

        <div class="param-group">
            <label for="hunterTargetPopulation">Hunter Target Pop: <span id="hunterTargetPopulationValue"></span></label>
            <input type="range" id="hunterTargetPopulation" min="0" max="50" step="5">
        </div>

        <div class="param-group">
            <label for="preyMaxSpeed">Prey Max Speed: <span id="preyMaxSpeedValue"></span></label>
            <input type="range" id="preyMaxSpeed" min="1" max="5" step="0.1">
        </div>

        <div class="param-group">
            <label for="predatorMaxSpeed">Predator Max Speed: <span id="predatorMaxSpeedValue"></span></label>
            <input type="range" id="predatorMaxSpeed" min="1" max="5" step="0.1">
        </div>

        <div class="param-group">
            <label for="hunterMaxSpeed">Hunter Max Speed: <span id="hunterMaxSpeedValue"></span></label>
            <input type="range" id="hunterMaxSpeed" min="1" max="5" step="0.1">
        </div>
    </div>

    <div id="zoom-controls">
        <button id="zoom-in-button" class="ui-button">+</button>
        <button id="zoom-out-button" class="ui-button">-</button>
    </div>

    <button id="show-panel-button" class="ui-button">Show Panel</button>

    <div id="stats-panel">
        <div>Prey: <strong id="preyCount">0</strong></div>
        <div>Predators: <strong id="predatorCount">0</strong></div>
        <div>Hunters: <strong id="hunterCount">0</strong></div>
        <div>Food: <strong id="foodCount">0</strong></div>
        <div>Prey Survival: <strong id="totalPreySurvivalTime">0</strong></div>
        <div>Predator Survival: <strong id="totalPredatorSurvivalTime">0</strong></div>
        <div>Hunter Survival: <strong id="totalHunterSurvivalTime">0</strong></div>
        <div>Births: <strong id="totalBirths">0</strong></div>
        <div>Mutations: <strong id="totalGeneticMutations">0</strong></div>
        <div>Ticks: <strong id="simulationTicks">0</strong></div>
    </div>

    <!-- New: Game Over Overlay -->
    <div id="game-over-overlay">
        <h1>GAME OVER</h1>
        <p>Prey population has gone extinct!</p>
        <div class="final-stats">
            <p>Total Ticks: <strong><span id="finalTicks">0</span></strong></p>
            <p>Total Prey Survival Ticks: <strong><span id="finalPreySurvival">0</span></strong></p>
            <p>Total Predator Survival Ticks: <strong><span id="finalPredatorSurvival">0</span></strong></p>
            <p>Total Hunter Survival Ticks: <strong><span id="finalHunterSurvival">0</span></strong></p>
            <p>Total Births: <strong><span id="finalBirths">0</span></strong></p>
            <p>Total Mutations: <strong><span id="finalMutations">0</span></strong></p>
        </div>
        <button id="restart-game-button" class="ui-button">Restart Simulation</button>
    </div>


    <script>
        // --- Game Configuration and Global Variables ---
        const config = {
            // Simulation World Dimensions (Virtual World, can be larger than canvas)
            worldWidth: 2000,           // The virtual width of the simulation world
            worldHeight: 1500,          // The virtual height of the simulation world

            // Simulation Parameters
            timeScale: 1.0,             // Controls the overall simulation speed (1.0 = normal)
            zoomLevel: 1.0,             // Controls rendering zoom (will be auto-adjusted initially)
            mutationRate: 0.01,         // Chance of a gene mutating during reproduction
            mutationColorRange: 20,     // Max hue shift for visual mutations (+/- degrees)
            foodSpawnRate: 0.5,         // Number of food items to try and spawn per update tick
            foodEnergy: 50,             // Health gained per food item eaten

            // Population Targets (simulation will try to maintain these numbers)
            preyTargetPopulation: 200,
            predatorTargetPopulation: 50,
            hunterTargetPopulation: 10, // New: Target population for hunters

            // Creature Base Stats (these influence initial spawns and serve as evolutionary baselines)
            creatureSize: 8,            // Base visual size for creatures
            preyMaxSpeed: 2.5,          // Initial max speed for prey
            predatorMaxSpeed: 3.5,      // Initial max speed for predators
            hunterMaxSpeed: 4.0,        // New: Initial max speed for hunters

            // Health & Energy Mechanics
            preyMaxHealth: 100,         // Maximum health for prey
            predatorMaxHealth: 150,     // Maximum health for predators
            hunterMaxHealth: 200,       // New: Maximum health for hunters
            preyReproductionThreshold: 80,  // Health needed for a prey to reproduce
            predatorReproductionThreshold: 120, // Health needed for a predator to reproduce
            hunterReproductionThreshold: 160, // New: Health needed for a hunter to reproduce
            preyEnergyConsumption: 0.1,     // Health lost per tick for prey (survival cost)
            predatorEnergyConsumption: 0.2, // Health lost per tick for predators
            hunterEnergyConsumption: 0.3, // New: Health lost per tick for hunters
            reproductionCost: 50,           // Health cost incurred by parent upon reproduction

            // Vision & Senses
            preyVisionRange: 150,       // Distance prey can "see"
            predatorVisionRange: 200,   // Distance predators can "see"
            hunterVisionRange: 250,     // New: Distance hunters can "see"

            // World Regions (percentages of world width, not canvas width)
            foodZoneWidth: 0.4,         // Left 40% of the world
            desolateZoneWidth: 0.2,     // Middle 20%
            predatorDenWidth: 0.4,      // Right 40%

            // Quadtree Configuration
            quadtreeCapacity: 4,        // Max entities per quadtree node before subdividing

            // Global Limits
            maxEntities: 1000           // Cap for total entities to prevent runaway growth
        };

        let canvas, ctx;
        let simulationPaused = true;
        let lastFrameTime = 0;
        let entities = [];
        let quadtree;
        let entityIdCounter = 0; // Unique ID for each entity

        // Camera State
        let cameraX = 0;
        let cameraY = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Statistics counters
        let currentPreyCount = 0;
        let currentPredatorCount = 0;
        let currentHunterCount = 0; // New: Hunter count
        let currentFoodCount = 0;
        let totalPreySurvivalTicks = 0;
        let totalPredatorSurvivalTicks = 0;
        let totalHunterSurvivalTicks = 0; // New: Total survival time for hunters
        let totalBirths = 0;
        let totalGeneticMutations = 0;
        let simulationTicks = 0;
        let gameOver = false; // Flag to indicate game over state

        // --- Neural Network Learning Explanation ---
        /*
        The Neural Network (NN) in this simulation "learns" through a Genetic Algorithm, not within a creature's lifetime.
        Here's how it works:
        1.  **Genes (NN Weights & Biases):** Each creature's "brain" is a simple feed-forward Neural Network. The values of its weights and biases are its "genes."
        2.  **Survival of the Fittest:** Creatures with NNs that allow them to find food, avoid threats, and reproduce effectively will survive longer and have more offspring. Poorly adapted NNs lead to early death.
        3.  **Reproduction (Crossover):** When two healthy creatures reproduce, their offspring's NN is created by combining the weights and biases from both parents (crossover). This allows successful "traits" (NN connections) to be passed down and combined.
        4.  **Mutation:** After crossover, a small chance of random alteration (mutation) is applied to the offspring's NN weights and biases (controlled by the "Mutation Rate" slider). These mutations introduce new, random "traits" into the gene pool. Most are detrimental, but some might be beneficial.
        5.  **Evolution:** Over many generations, beneficial combinations of weights and biases (genes) are naturally selected for, as creatures possessing them out-survive and out-reproduce others. This leads to a gradual improvement in the population's overall "intelligence" and adaptation to the environment. The color changes you'll see are a visual representation of these underlying genetic (NN) mutations.
        */

        // --- Utility Classes ---

        /**
         * Represents a 2D vector for position, velocity, and acceleration.
         */
        class Vector {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(other) { return new Vector(this.x + other.x, this.y + other.y); }
            sub(other) { return new Vector(this.x - other.x, this.y - other.y); }
            mult(scalar) { return new Vector(this.x * scalar, this.y * scalar); }
            div(scalar) { return new Vector(this.x / scalar, this.y / scalar); }

            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }

            normalize() {
                const m = this.mag();
                return m > 0 ? this.div(m) : new Vector(0, 0);
            }

            setMag(magnitude) { return this.normalize().mult(magnitude); }

            limit(max) {
                if (this.mag() > max) {
                    return this.setMag(max);
                }
                return this;
            }

            dist(other) { return this.sub(other).mag(); }

            angle() { return Math.atan2(this.y, this.x); }

            static random2D() {
                const angle = Math.random() * Math.PI * 2;
                return new Vector(Math.cos(angle), Math.sin(angle));
            }

            copy() {
                return new Vector(this.x, this.y);
            }
        }

        /**
         * Represents a rectangular boundary for the Quadtree.
         */
        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x; // Center X
                this.y = y; // Center Y
                this.w = w; // Half-width
                this.h = h; // Half-height
            }

            contains(point) {
                return (point.x >= this.x - this.w &&
                        point.x <= this.x + this.w &&
                        point.y >= this.y - this.h &&
                        point.y <= this.y + this.h);
            }

            intersects(range) {
                return !(range.x - range.w > this.x + this.w ||
                         range.x + range.w < this.x - this.w ||
                         range.y - range.h > this.y + this.h ||
                         range.y + range.h < this.y - this.h);
            }
        }

        /**
         * Quadtree data structure for efficient spatial partitioning of entities.
         */
        class QuadTree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.entities = [];
                this.divided = false;
            }

            subdivide() {
                let x = this.boundary.x;
                let y = this.boundary.y;
                let w = this.boundary.w / 2;
                let h = this.boundary.h / 2;

                this.northeast = new QuadTree(new Rectangle(x + w, y - h, w, h), this.capacity);
                this.northwest = new QuadTree(new Rectangle(x - w, y - h, w, h), this.capacity);
                this.southeast = new QuadTree(new Rectangle(x + w, y + h, w, h), this.capacity);
                this.southwest = new QuadTree(new Rectangle(x - w, y + h, w, h), this.capacity);

                this.divided = true;

                // Redistribute entities to new sub-nodes
                for (let entity of this.entities) {
                    this.insert(entity);
                }
                this.entities = []; // Clear current node's entities after distribution
            }

            insert(entity) {
                if (!this.boundary.contains(entity.position)) {
                    return false;
                }

                if (this.entities.length < this.capacity && !this.divided) {
                    this.entities.push(entity);
                    return true;
                } else {
                    if (!this.divided) {
                        this.subdivide();
                    }
                    if (this.northeast.insert(entity)) { return true; }
                    if (this.northwest.insert(entity)) { return true; }
                    if (this.southeast.insert(entity)) { return true; }
                    if (this.southwest.insert(entity)) { return true; }
                }
                return false; // Should not happen if boundary.contains is true
            }

            query(range, found = []) {
                if (!this.boundary.intersects(range)) {
                    return found;
                }

                for (let entity of this.entities) {
                    if (range.contains(entity.position)) { // More precise check against query range
                        found.push(entity);
                    }
                }

                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }
                return found;
            }

            clear() {
                this.entities = [];
                this.divided = false;
                this.northeast = null;
                this.northwest = null;
                this.southeast = null;
                this.southwest = null;
            }
        }

        /**
         * Simple Feed-Forward Neural Network used as the "brain" for creatures.
         */
        class NeuralNetwork {
            // NN structure: 11 inputs (health, 4 x (dist, angle) for Food, Prey, Predator, Hunter, 2 x (dist, angle) for Mate),
            // 10 hidden neurons, 2 outputs (acceleration magnitude, turning strength)
            static INPUT_SIZE = 1 + (2 * 5); // Health + 5 types of entities (dist, angle)
            static HIDDEN_SIZE = 10;
            static OUTPUT_SIZE = 2;

            constructor(...layerSizes) {
                this.layerSizes = layerSizes.length ? layerSizes : [NeuralNetwork.INPUT_SIZE, NeuralNetwork.HIDDEN_SIZE, NeuralNetwork.OUTPUT_SIZE];
                this.weights = [];
                this.biases = [];

                for (let i = 0; i < this.layerSizes.length - 1; i++) {
                    const rows = this.layerSizes[i + 1];
                    const cols = this.layerSizes[i];
                    // Initialize weights and biases randomly between -1 and 1
                    const weightMatrix = Array.from({ length: rows }, () =>
                        Array.from({ length: cols }, () => Math.random() * 2 - 1)
                    );
                    this.weights.push(weightMatrix);

                    const biasVector = Array.from({ length: rows }, () => Math.random() * 2 - 1);
                    this.biases.push(biasVector);
                }
            }

            // Tanh activation function: maps input to range [-1, 1]
            static tanh(x) {
                return Math.tanh(x);
            }

            /**
             * Propagates inputs through the network to produce outputs.
             * @param {Array<number>} inputs - The input values to the network.
             * @returns {Array<number>} The output values from the network.
             */
            feedForward(inputs) {
                if (inputs.length !== this.layerSizes[0]) {
                    console.error(`Input size mismatch. Expected ${this.layerSizes[0]}, got ${inputs.length}. Padding/truncating.`);
                    const paddedInputs = inputs.slice(0, this.layerSizes[0]);
                    while (paddedInputs.length < this.layerSizes[0]) {
                        paddedInputs.push(0); // Pad with zeros if inputs are too few
                    }
                    inputs = paddedInputs;
                }

                let currentOutputs = inputs;

                for (let i = 0; i < this.weights.length; i++) {
                    const nextOutputs = [];
                    const weightMatrix = this.weights[i];
                    const biasVector = this.biases[i];

                    for (let r = 0; r < weightMatrix.length; r++) {
                        let sum = 0;
                        for (let c = 0; c < weightMatrix[r].length; c++) {
                            sum += currentOutputs[c] * weightMatrix[r][c];
                        }
                        nextOutputs.push(NeuralNetwork.tanh(sum + biasVector[r]));
                    }
                    currentOutputs = nextOutputs;
                }
                return currentOutputs;
            }

            /**
             * Creates a deep copy of the neural network.
             * @returns {NeuralNetwork} A new NeuralNetwork instance with copied weights and biases.
             */
            copy() {
                const newNN = new NeuralNetwork(...this.layerSizes);
                newNN.weights = this.weights.map(matrix => matrix.map(row => [...row]));
                newNN.biases = this.biases.map(bias => [...bias]);
                return newNN;
            }

            /**
             * Mutates the weights and biases of the network with a given rate.
             * @param {number} rate - The mutation rate (probability).
             * @returns {number} The number of actual mutations applied.
             */
            mutate(rate) {
                let mutationsCount = 0;
                for (let i = 0; i < this.weights.length; i++) {
                    for (let r = 0; r < this.weights[i].length; r++) {
                        for (let c = 0; c < this.weights[i][r].length; c++) {
                            if (Math.random() < rate) {
                                this.weights[i][r][c] += (Math.random() * 2 - 1) * 0.5; // Small random adjustment
                                mutationsCount++;
                            }
                        }
                    }
                }
                for (let i = 0; i < this.biases.length; i++) {
                    for (let r = 0; r < this.biases[i].length; r++) {
                        if (Math.random() < rate) {
                            this.biases[i][r] += (Math.random() * 2 - 1) * 0.5;
                            mutationsCount++;
                        }
                    }
                }
                return mutationsCount;
            }

            /**
             * Combines two parent neural networks to produce a child network through crossover.
             * @param {NeuralNetwork} nn1 - The first parent network.
             * @param {NeuralNetwork} nn2 - The second parent network.
             * @returns {NeuralNetwork} A new NeuralNetwork instance representing the child.
             */
            static crossover(nn1, nn2) {
                if (nn1.layerSizes.join('-') !== nn2.layerSizes.join('-')) {
                    throw new Error("Cannot crossover NNs with different architectures.");
                }

                const childNN = new NeuralNetwork(...nn1.layerSizes);

                for (let i = 0; i < nn1.weights.length; i++) {
                    const crossoverPointRow = Math.floor(Math.random() * nn1.weights[i].length);
                    const crossoverPointCol = Math.floor(Math.random() * nn1.weights[i][0].length);

                    for (let r = 0; r < nn1.weights[i].length; r++) {
                        for (let c = 0; c < nn1.weights[i][r].length; c++) {
                            // Combine weights: pick from nn1 before crossover point, nn2 after
                            if (r < crossoverPointRow || (r === crossoverPointRow && c < crossoverPointCol)) {
                                childNN.weights[i][r][c] = nn1.weights[i][r][c];
                            } else {
                                childNN.weights[i][r][c] = nn2.weights[i][r][c];
                            }
                        }
                    }
                }

                for (let i = 0; i < nn1.biases.length; i++) {
                    const crossoverPoint = Math.floor(Math.random() * nn1.biases[i].length);
                    for (let r = 0; r < nn1.biases[i].length; r++) {
                        // Combine biases: pick from nn1 before crossover point, nn2 after
                        if (r < crossoverPoint) {
                            childNN.biases[i][r] = nn1.biases[i][r];
                        } else {
                            childNN.biases[i][r] = nn2.biases[i][r];
                        }
                    }
                }
                return childNN;
            }
        }

        // --- Entity Classes ---

        /**
         * Base class for all entities in the simulation (creatures, food).
         */
        class Entity {
            constructor(x, y, color, size, world) {
                this.position = new Vector(x, y);
                this.color = color; // Hue for HSLA
                this.size = size;
                this.world = world; // Reference to world dimensions
                this.id = entityIdCounter++; // Unique ID
                this.isDead = false; // Flag for removal
                this.trail = []; // For drawing trails
                this.maxTrailLength = 5; // How many past positions to store
            }

            update() {
                // Update trail
                this.trail.unshift(this.position.copy()); // Add current position to front
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.pop(); // Remove oldest position
                }
            }
            draw(ctx) { /* Override in subclasses */ }
        }

        /**
         * Represents a generic creature with a Neural Network brain.
         * Extended by Prey and Predator classes.
         */
        class Creature extends Entity {
            constructor(x, y, color, size, world, nn, maxHealth, reproductionThreshold, energyConsumption, maxSpeed, visionRange) {
                super(x, y, color, size, world);
                this.velocity = Vector.random2D().setMag(maxSpeed * 0.5); // Initial random movement
                this.acceleration = new Vector(0, 0);
                this.maxSpeed = maxSpeed;
                this.maxHealth = maxHealth;
                this.health = maxHealth; // Starts with full health
                this.reproductionThreshold = reproductionThreshold;
                this.energyConsumption = energyConsumption;
                this.nn = nn;
                this.visionRange = visionRange;
                this.age = 0;
            }

            /**
             * Helper to normalize distance and angle for NN inputs.
             */
            _addNormalizedInputs(inputs, { entity, dist }) {
                if (entity) {
                    inputs.push(dist / this.visionRange); // Distance (0-1)
                    const angleToEntity = entity.position.sub(this.position).angle();
                    let relativeAngleToEntity = angleToEntity - this.velocity.angle();
                    relativeAngleToEntity = Math.atan2(Math.sin(relativeAngleToEntity), Math.cos(relativeAngleToEntity)); // Normalize to -PI to PI
                    inputs.push(relativeAngleToEntity / Math.PI); // Normalize to -1 to 1
                } else {
                    inputs.push(1); // No entity detected (max distance)
                    inputs.push(0); // No angle
                }
            }

            /**
             * The creature's "brain" function. Uses NN to decide movement based on inputs.
             */
            think() {
                // Find nearest entities by type within vision range
                const searchRange = new Rectangle(this.position.x, this.position.y, this.visionRange / 2, this.visionRange / 2);
                const nearbyEntities = quadtree.query(searchRange);

                let closestFood = { entity: null, dist: Infinity };
                let closestPrey = { entity: null, dist: Infinity };
                let closestPredator = { entity: null, dist: Infinity };
                let closestHunter = { entity: null, dist: Infinity };
                let closestMate = { entity: null, dist: Infinity };


                for (let entity of nearbyEntities) {
                    if (entity.id === this.id || entity.isDead) continue;
                    const dist = this.position.dist(entity.position);

                    if (dist < this.visionRange) {
                        if (entity instanceof Food) {
                            if (dist < closestFood.dist) { closestFood = { entity, dist }; }
                        } else if (entity instanceof Prey) {
                            if (dist < closestPrey.dist) { closestPrey = { entity, dist }; }
                            if (this.constructor === entity.constructor) { // Same type, potential mate
                                if (dist < closestMate.dist) { closestMate = { entity, dist }; }
                            }
                        } else if (entity instanceof Predator) {
                            if (dist < closestPredator.dist) { closestPredator = { entity, dist }; }
                            if (this.constructor === entity.constructor) { // Same type, potential mate
                                if (dist < closestMate.dist) { closestMate = { entity, dist }; }
                            }
                        } else if (entity instanceof Hunter) {
                            if (dist < closestHunter.dist) { closestHunter = { entity, dist }; }
                            if (this.constructor === entity.constructor) { // Same type, potential mate
                                if (dist < closestMate.dist) { closestMate = { entity, dist }; }
                            }
                        }
                    }
                }

                // Prepare NN inputs (11 inputs: health, 5 x (dist, angle) for Food, Prey, Predator, Hunter, Mate)
                const inputs = [];
                inputs.push(this.health / this.maxHealth); // Own health (0-1)

                this._addNormalizedInputs(inputs, closestFood);
                this._addNormalizedInputs(inputs, closestPrey);
                this._addNormalizedInputs(inputs, closestPredator);
                this._addNormalizedInputs(inputs, closestHunter);
                this._addNormalizedInputs(inputs, closestMate);


                // Feed inputs to NN
                const outputs = this.nn.feedForward(inputs);

                // Map NN outputs to acceleration and turning force
                // Outputs are typically between -1 and 1 due to tanh activation
                const accelerationMag = (outputs[0] + 1) / 2; // Map from -1 to 1 to 0 to 1
                const turnStrength = outputs[1]; // -1 to 1, determines left/right turn magnitude

                // Apply acceleration based on NN outputs
                const currentHeading = this.velocity.angle();
                const desiredHeading = currentHeading + turnStrength * (Math.PI / 8); // Max turn of ~22.5 degrees per tick
                this.acceleration = new Vector(Math.cos(desiredHeading), Math.sin(desiredHeading)).setMag(accelerationMag * 0.1); // Small constant acceleration scale
            }

            // Handles movement and boundary wrapping
            move() {
                this.velocity = this.velocity.add(this.acceleration);
                this.velocity = this.velocity.limit(this.maxSpeed);
                // Apply timeScale to the position update
                this.position = this.position.add(this.velocity.mult(config.timeScale));
                this.acceleration = new Vector(0, 0); // Reset acceleration each frame

                // Wrap around edges using world dimensions
                if (this.position.x < 0) this.position.x = this.world.width;
                if (this.position.x > this.world.width) this.position.x = 0;
                if (this.position.y < 0) this.position.y = this.world.height;
                if (this.position.y > this.world.height) this.position.y = 0;
            }

            // Consumes energy (health decay) and checks for death
            updateHealth() {
                // Apply timeScale to health consumption
                this.health -= this.energyConsumption * config.timeScale;
                if (this.health <= 0) {
                    this.isDead = true;
                }
            }

            /**
             * Attempts to reproduce. Costs health. Offspring inherit NN.
             * @param {NeuralNetwork} mateNN - The Neural Network of a potential mate for crossover.
             * @returns {Creature|null} A new child creature or null if reproduction fails.
             */
            reproduce(mateNN = null) {
                if (this.health >= this.reproductionThreshold) {
                    const childNN = mateNN ? NeuralNetwork.crossover(this.nn, mateNN) : this.nn.copy();
                    const mutationsThisBirth = childNN.mutate(config.mutationRate); // Mutate and get count
                    totalGeneticMutations += mutationsThisBirth; // Add to global count

                    // Apply visual mutation (color change)
                    let childColor = this.color;
                    if (mutationsThisBirth > 0) { // Only change color if an actual gene mutation occurred
                        childColor = (this.color + (Math.random() * 2 * config.mutationColorRange - config.mutationColorRange));
                        childColor = (childColor % 360 + 360) % 360; // Ensure hue wraps around 0-359
                    }


                    // Offset child slightly to prevent immediate re-collision/reproduction issues
                    const offset = Vector.random2D().mult(this.size * 2);
                    const child = new (this.constructor)( // Create new instance of current creature type (Prey or Predator)
                        this.position.x + offset.x,
                        this.position.y + offset.y,
                        this.world,
                        childNN, // Pass the mutated/crossed-over NN
                        childColor // Pass the (potentially mutated) color
                    );

                    this.health -= config.reproductionCost; // Health cost for reproduction
                    totalBirths++; // Increment total births
                    return child;
                }
                return null;
            }

            /**
             * Eats a target entity (food or prey). Gains health.
             * @param {Entity} targetItem - The entity to eat.
             * @param {number} energyValue - The amount of health to gain.
             */
            eat(targetItem, energyValue) {
                this.health += energyValue;
                this.health = Math.min(this.health, this.maxHealth); // Cap health at max
                targetItem.isDead = true; // Mark eaten item for removal
            }

            // Main update logic for a creature
            update() {
                super.update(); // Call base Entity update for trail logic
                // Apply timeScale to age increment
                this.age += config.timeScale;
                this.updateHealth();
                if (this.isDead) return;

                // Find nearby entities for interaction
                const searchRange = new Rectangle(this.position.x, this.position.y, this.visionRange / 2, this.visionRange / 2);
                const nearbyEntities = quadtree.query(searchRange);

                for (let entity of nearbyEntities) {
                    if (entity.id === this.id || entity.isDead) continue; // Skip self and dead entities

                    const dist = this.position.dist(entity.position);
                    if (dist < this.size / 2 + entity.size / 2) { // Simple circular collision detection
                        // Handle eating based on creature type and entity type
                        if (this instanceof Prey && entity instanceof Food) {
                            this.eat(entity, config.foodEnergy);
                        } else if (this instanceof Predator && entity instanceof Prey) {
                            this.eat(entity, entity.maxHealth * 0.5); // Predators gain health based on prey's max health
                        } else if (this instanceof Hunter) { // New Hunter eating logic
                            if (entity instanceof Food) {
                                this.eat(entity, config.foodEnergy);
                            } else if (entity instanceof Prey) {
                                this.eat(entity, entity.maxHealth * 0.75); // Hunter gets more from Prey
                            } else if (entity instanceof Predator) {
                                this.eat(entity, entity.maxHealth * 1.0); // Hunter gets most from Predator
                            }
                        }
                    }
                }

                this.think(); // Call think after all potential interactions this tick
                this.move();

                // Reproduction check
                if (this.health >= this.reproductionThreshold) {
                    const mateCandidate = nearbyEntities.find(e =>
                        e.constructor === this.constructor && // Same type
                        e.id !== this.id && // Not self
                        !e.isDead && // Alive
                        e.health > e.reproductionThreshold * 0.8 && // Healthy mate
                        this.position.dist(e.position) < this.size * 2 // Close enough to mate
                    );
                    if (mateCandidate) {
                         const newChild = this.reproduce(mateCandidate.nn);
                         if (newChild && entities.length < config.maxEntities) {
                             entities.push(newChild);
                         }
                    }
                }
            }

            // Draws the creature on the canvas with a glow effect
            draw(ctx) {
                const healthRatio = this.health / this.maxHealth;
                const brightness = Math.max(0.2, Math.min(1.0, healthRatio * 1.2)); // Brighter when healthier
                const alpha = Math.max(0.1, Math.min(0.8, healthRatio * 0.7 + 0.1)); // More opaque when healthier

                // Draw trail
                if (this.trail.length > 0) { // Check if there's at least one point
                    ctx.beginPath();
                    ctx.moveTo(this.position.x, this.position.y); // Start from current position
                    for (let i = 0; i < this.trail.length; i++) { // Loop through trail points
                        const point = this.trail[i];
                        const segmentAlpha = alpha * (1 - (i / this.maxTrailLength)); // Fade trail
                        ctx.strokeStyle = `hsla(${this.color}, 100%, 50%, ${segmentAlpha})`;
                        ctx.lineWidth = this.size * (1 - (i / this.maxTrailLength)) / 2; // Taper trail
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.stroke();
                }

                // Set glow effect using shadow properties
                ctx.shadowBlur = this.size * 1.5;
                ctx.shadowColor = `hsla(${this.color}, 100%, 50%, ${alpha})`;

                ctx.fillStyle = `hsla(${this.color}, 100%, ${brightness * 100}%, ${alpha})`; // Main body color
                ctx.beginPath();

                if (this instanceof Prey) {
                    ctx.arc(this.position.x, this.position.y, this.size / 2, 0, Math.PI * 2);
                } else if (this instanceof Predator) {
                    const angle = this.velocity.angle();
                    const tipX = this.position.x + Math.cos(angle) * this.size / 2;
                    const tipY = this.position.y + Math.sin(angle) * this.size / 2;
                    const baseAngle1 = angle + (2 * Math.PI / 3);
                    const baseAngle2 = angle - (2 * Math.PI / 3);
                    const baseX1 = this.position.x + Math.cos(baseAngle1) * this.size / 2;
                    const baseY1 = this.position.y + Math.sin(baseAngle1) * this.size / 2;
                    const baseX2 = this.position.x + Math.cos(baseAngle2) * this.size / 2;
                    const baseY2 = this.position.y + Math.sin(baseAngle2) * this.size / 2;

                    ctx.moveTo(tipX, tipY);
                    ctx.lineTo(baseX1, baseY1);
                    ctx.lineTo(baseX2, baseY2);
                    ctx.closePath();
                } else if (this instanceof Hunter) { // New: Draw a diamond for Hunter
                    const angle = this.velocity.angle();
                    const halfSize = this.size * 0.7; // Slightly smaller to fit better
                    const sqrt2 = Math.sqrt(2); // For diamond points
                    const p1 = new Vector(this.position.x + Math.cos(angle) * halfSize * sqrt2, this.position.y + Math.sin(angle) * halfSize * sqrt2); // Top
                    const p2 = new Vector(this.position.x + Math.cos(angle + Math.PI / 2) * halfSize, this.position.y + Math.sin(angle + Math.PI / 2) * halfSize); // Right
                    const p3 = new Vector(this.position.x + Math.cos(angle + Math.PI) * halfSize * sqrt2, this.position.y + Math.sin(angle + Math.PI) * halfSize * sqrt2); // Bottom
                    const p4 = new Vector(this.position.x + Math.cos(angle - Math.PI / 2) * halfSize, this.position.y + Math.sin(angle - Math.PI / 2) * halfSize); // Left

                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.lineTo(p3.x, p3.y);
                    ctx.lineTo(p4.x, p4.y);
                    ctx.closePath();
                }
                ctx.fill();

                // Reset shadow properties to avoid affecting subsequent draws
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.lineWidth = 1; // Reset line width
            }
        }

        /**
         * Represents a Prey creature, extends Creature.
         */
        class Prey extends Creature {
            constructor(x, y, world, nn = null, color = 120) { // Default color 120 (Green)
                super(x, y, color, config.creatureSize, world, nn || new NeuralNetwork(),
                      config.preyMaxHealth, config.preyReproductionThreshold, config.preyEnergyConsumption,
                      config.preyMaxSpeed, config.preyVisionRange);
            }
        }

        /**
         * Represents a Predator creature, extends Creature.
         */
        class Predator extends Creature {
            constructor(x, y, world, nn = null, color = 0) { // Default color 0 (Red)
                super(x, y, color, config.creatureSize + 2, world, nn || new NeuralNetwork(), // Slightly larger
                      config.predatorMaxHealth, config.predatorReproductionThreshold, config.predatorEnergyConsumption,
                      config.predatorMaxSpeed, config.predatorVisionRange);
            }
        }

        /**
         * New: Represents a Hunter creature, extends Creature.
         */
        class Hunter extends Creature {
            constructor(x, y, world, nn = null, color = 280) { // Default color 280 (Purple/Magenta)
                super(x, y, color, config.creatureSize + 4, world, nn || new NeuralNetwork(), // Even larger
                      config.hunterMaxHealth, config.hunterReproductionThreshold, config.hunterEnergyConsumption,
                      config.hunterMaxSpeed, config.hunterVisionRange);
            }
        }

        /**
         * Represents a Food item, extends Entity.
         */
        class Food extends Entity {
            constructor(x, y, world) {
                const foodColorHue = 240; // Blue
                // Slightly vary food size for more organic look
                const foodSize = config.creatureSize / 2 + (Math.random() * 2 - 1) * (config.creatureSize / 8);
                super(x, y, foodColorHue, foodSize, world); // Smaller than creatures
            }

            // Draws the food item on the canvas with a faint glow
            draw(ctx) {
                ctx.shadowBlur = this.size * 2;
                ctx.shadowColor = `hsla(${this.color}, 100%, 70%, 0.5)`;

                ctx.fillStyle = `hsla(${this.color}, 100%, 80%, 0.8)`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }
        }

        // --- Simulation Management Functions ---

        /**
         * Initializes the canvas, quadtree, initial population, and UI.
         */
        function initSimulation() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas(); // Set initial canvas size based on window and fit world
            window.addEventListener('resize', resizeCanvas); // Adjust canvas on window resize

            // Initialize quadtree for the entire *virtual* world area
            const boundary = new Rectangle(config.worldWidth / 2, config.worldHeight / 2, config.worldWidth / 2, config.worldHeight / 2);
            quadtree = new QuadTree(boundary, config.quadtreeCapacity);

            setupCanvasEvents(); // Set up panning events
            generateInitialPopulation(); // Create initial entities
            setupUI(); // Setup UI controls and button listeners
            drawSimulation(); // Draw initial static state before simulation starts
        }

        /**
         * Sets up mouse/touch events for camera panning.
         */
        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // Left mouse button
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    canvas.classList.add('dragging');
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastMouseX;
                    const dy = e.clientY - lastMouseY;

                    // Adjust camera offset, scaling by current zoom level
                    // Moving mouse right should move camera left relative to world
                    cameraX -= dx / config.zoomLevel;
                    cameraY -= dy / config.zoomLevel;

                    // Clamp camera to world bounds
                    clampCamera();

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    drawSimulation(); // Redraw for smooth panning
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.classList.remove('dragging');
            });

            canvas.addEventListener('mouseleave', () => { // Stop dragging if mouse leaves canvas
                isDragging = false;
                canvas.classList.remove('dragging');
            });

            // Touch events for mobile
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    canvas.classList.add('dragging');
                }
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                if (isDragging && e.touches.length === 1) {
                    const dx = e.touches[0].clientX - lastMouseX;
                    const dy = e.touches[0].clientY - lastMouseY;

                    cameraX -= dx / config.zoomLevel;
                    cameraY -= dy / config.zoomLevel;

                    clampCamera();

                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    drawSimulation();
                }
            }, { passive: true });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
                canvas.classList.remove('dragging');
            });

            // Prevent context menu on right click, useful if we add right-click actions later
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }

        /**
         * Clamps the camera position so it doesn't pan off the world.
         */
        function clampCamera() {
            const worldViewWidth = canvas.width / config.zoomLevel;
            const worldViewHeight = canvas.height / config.zoomLevel;

            // Max cameraX (leftmost position of the view)
            const maxX = config.worldWidth - worldViewWidth;
            // Max cameraY (topmost position of the view)
            const maxY = config.worldHeight - worldViewHeight;

            cameraX = Math.max(0, Math.min(cameraX, maxX));
            cameraY = Math.max(0, Math.min(cameraY, maxY));
        }


        /**
         * Generates the initial population of Prey, Predators, Food, and Hunters.
         */
        function generateInitialPopulation() {
            entities = []; // Clear any existing entities
            totalBirths = 0; // Reset stats on new population
            totalGeneticMutations = 0;
            simulationTicks = 0;
            totalPreySurvivalTicks = 0; // Reset survival times
            totalPredatorSurvivalTicks = 0;
            totalHunterSurvivalTicks = 0;
            gameOver = false; // Reset game over flag

            // Define world region boundaries based on worldWidth
            const foodZoneEnd = config.worldWidth * config.foodZoneWidth;
            // const predatorDenStart = config.worldWidth * (config.foodZoneWidth + config.desolateZoneWidth); // Used for drawing only now

            // Spawn initial Prey in Food Zone
            for (let i = 0; i < config.preyTargetPopulation; i++) {
                const x = Math.random() * foodZoneEnd;
                const y = Math.random() * config.worldHeight;
                entities.push(new Prey(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }

            // Spawn initial Predators in a wider central zone for better initial survival
            const centralSpawnMinX = config.worldWidth * 0.2; // 20% from left
            const centralSpawnMaxX = config.worldWidth * 0.8;   // 80% from left
            for (let i = 0; i < config.predatorTargetPopulation; i++) {
                const x = centralSpawnMinX + Math.random() * (centralSpawnMaxX - centralSpawnMinX);
                const y = Math.random() * config.worldHeight;
                entities.push(new Predator(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }

            // Spawn initial Hunters in the desolate zone, or spread them out
            const hunterSpawnMinX = config.worldWidth * config.foodZoneWidth; // Start of desolate zone
            const hunterSpawnMaxX = config.worldWidth * (config.foodZoneWidth + config.desolateZoneWidth); // End of desolate zone
            for (let i = 0; i < config.hunterTargetPopulation; i++) {
                const x = hunterSpawnMinX + Math.random() * (hunterSpawnMaxX - hunterSpawnMinX);
                const y = Math.random() * config.worldHeight;
                entities.push(new Hunter(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }

            // Spawn initial Food across the food zone
            for (let i = 0; i < config.preyTargetPopulation * 2; i++) { // More food than prey initially for stability
                const x = Math.random() * foodZoneEnd;
                const y = Math.random() * config.worldHeight;
                entities.push(new Food(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }
            // IMPORTANT: Update counts immediately after generation for the initial draw
            updateEntityCounts();
        }

        /**
         * Updates the state of all entities and manages population.
         */
        function updateSimulation() {
            if (simulationPaused || gameOver) return; // Do not update if paused or game over

            simulationTicks++; // Increment simulation time

            // Clear and rebuild quadtree for current frame
            quadtree.clear();
            for (let entity of entities) {
                if (!entity.isDead) { // Only add live entities
                    quadtree.insert(entity);
                }
            }

            // Update entities and filter out dead ones
            let newEntities = [];
            for (let entity of entities) {
                if (!entity.isDead) { // Ensure entity is not already marked dead
                    // Accumulate survival time before updating and potentially dying
                    if (entity instanceof Prey) {
                        totalPreySurvivalTicks += config.timeScale;
                    } else if (entity instanceof Predator) {
                        totalPredatorSurvivalTicks += config.timeScale;
                    } else if (entity instanceof Hunter) { // New: Hunter survival time
                        totalHunterSurvivalTicks += config.timeScale;
                    }

                    entity.update(); // Call individual entity's update logic
                    if (!entity.isDead) { // Check again AFTER update, as they might have died during update
                        newEntities.push(entity);
                    }
                }
            }
            entities = newEntities; // Replace old array with new live entities

            updateEntityCounts(); // Update counts after filtering

            // --- Game Over Condition Check ---
            if (currentPreyCount === 0 && !gameOver) {
                endGame();
                return; // Stop further updates for this frame
            }

            // Population Control and Spawning Logic
            const foodZoneEnd = config.worldWidth * config.foodZoneWidth;
            const predatorDenStart = config.worldWidth * (config.foodZoneWidth + config.desolateZoneWidth);
            const hunterSpawnMinX = config.worldWidth * config.foodZoneWidth; // Desolate zone start
            const hunterSpawnMaxX = config.worldWidth * (config.foodZoneWidth + config.desolateZoneWidth); // Desolate zone end


            // Spawn food randomly in the food zone
            // Scale spawn rate by timeScale
            if (Math.random() < config.foodSpawnRate * config.timeScale && entities.length < config.maxEntities) {
                const x = Math.random() * foodZoneEnd;
                const y = Math.random() * config.worldHeight;
                entities.push(new Food(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }

            // Spawn new prey if population is below target
            // These spawn events are not "time-scaled" by timeScale directly as they are threshold-based,
            // but the overall effect will be faster because creatures reproduce and die faster with higher timeScale.
            if (currentPreyCount < config.preyTargetPopulation && entities.length < config.maxEntities) {
                const x = Math.random() * foodZoneEnd; // Spawn in food zone
                const y = Math.random() * config.worldHeight;
                entities.push(new Prey(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }

            // Spawn new predators if population is below target
            if (currentPredatorCount < config.predatorTargetPopulation && entities.length < config.maxEntities) {
                const x = predatorDenStart + Math.random() * (config.worldWidth - predatorDenStart); // Spawn in predator den
                const y = Math.random() * config.worldHeight;
                entities.push(new Predator(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }

            // Spawn new hunters if population is below target
            if (currentHunterCount < config.hunterTargetPopulation && entities.length < config.maxEntities) {
                const x = hunterSpawnMinX + Math.random() * (hunterSpawnMaxX - hunterSpawnMinX);
                const y = Math.random() * config.worldHeight;
                entities.push(new Hunter(x, y, { width: config.worldWidth, height: config.worldHeight }));
            }
        }

        /**
         * Helper function to update the global entity counts.
         */
        function updateEntityCounts() {
            currentPreyCount = 0;
            currentPredatorCount = 0;
            currentHunterCount = 0;
            currentFoodCount = 0;
            for (const entity of entities) {
                if (entity instanceof Prey) currentPreyCount++;
                else if (entity instanceof Predator) currentPredatorCount++;
                else if (entity instanceof Hunter) currentHunterCount++;
                else if (entity instanceof Food) currentFoodCount++;
            }
        }

        /**
         * Ends the game, pauses simulation, and displays final stats.
         */
        function endGame() {
            simulationPaused = true;
            gameOver = true;
            document.getElementById('start-pause-button').textContent = 'Restart Simulation';
            displayGameOverStats();
        }

        /**
         * Displays the game over overlay with final statistics.
         */
        function displayGameOverStats() {
            const overlay = document.getElementById('game-over-overlay');
            document.getElementById('finalTicks').textContent = simulationTicks;
            document.getElementById('finalPreySurvival').textContent = totalPreySurvivalTicks.toFixed(0);
            document.getElementById('finalPredatorSurvival').textContent = totalPredatorSurvivalTicks.toFixed(0);
            document.getElementById('finalHunterSurvival').textContent = totalHunterSurvivalTicks.toFixed(0); // New: Hunter survival
            document.getElementById('finalBirths').textContent = totalBirths;
            document.getElementById('finalMutations').textContent = totalGeneticMutations;
            overlay.classList.add('visible');
        }

        /**
         * Hides the game over overlay.
         */
        function hideGameOverStats() {
            document.getElementById('game-over-overlay').classList.remove('visible');
        }

        /**
         * Draws the current state of the simulation on the canvas.
         */
        function drawSimulation() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear entire canvas

            // Draw animated background (subtle cosmic/deep-sea feel)
            // This is drawn to the canvas's actual dimensions, not the scaled world.
            const backgroundGradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, Math.min(canvas.width, canvas.height) * 0.1,
                canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) * 0.6
            );
            backgroundGradient.addColorStop(0, 'hsl(240, 50%, 5%)');   // Dark blue center
            backgroundGradient.addColorStop(0.5, 'hsl(280, 40%, 3%)'); // Darker purple
            backgroundGradient.addColorStop(1, 'hsl(0, 0%, 0%)');      // Black edges
            ctx.fillStyle = backgroundGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);


            // --- Apply camera transform (scale and then translate for zoom and pan) ---
            ctx.save();

            // Translate to account for camera pan
            // This transforms the coordinate system so that (cameraX, cameraY) in world space
            // is effectively at (0,0) in canvas space after scaling.
            ctx.translate(-cameraX * config.zoomLevel, -cameraY * config.zoomLevel);

            // Apply zoom
            ctx.scale(config.zoomLevel, config.zoomLevel);

            // Draw world regions as faint colored overlays (using world coordinates)
            const foodZoneEnd = config.worldWidth * config.foodZoneWidth;
            const desolateZoneStart = foodZoneEnd;
            const desolateZoneEnd = config.worldWidth * (config.foodZoneWidth + config.desolateZoneWidth);
            const predatorDenStart = desolateZoneEnd;

            // Food Zone (Left) - Fades to transparent at its right edge
            let foodGradient = ctx.createLinearGradient(0, 0, foodZoneEnd, 0);
            foodGradient.addColorStop(0, 'hsla(180, 80%, 30%, 0.15)'); // Teal, stronger near left
            foodGradient.addColorStop(0.8, 'hsla(120, 70%, 20%, 0.05)'); // Green, blending
            foodGradient.addColorStop(1, 'hsla(120, 70%, 20%, 0)'); // Fully transparent at right edge
            ctx.fillStyle = foodGradient;
            ctx.fillRect(0, 0, foodZoneEnd, config.worldHeight);

            // Desolate Zone (Middle) - Fades to transparent at both ends
            let desolateGradient = ctx.createLinearGradient(desolateZoneStart, 0, desolateZoneEnd, 0);
            desolateGradient.addColorStop(0, 'hsla(280, 30%, 15%, 0)'); // Transparent at left edge
            desolateGradient.addColorStop(0.2, 'hsla(280, 30%, 15%, 0.03)'); // Opaque inner
            desolateGradient.addColorStop(0.8, 'hsla(280, 30%, 15%, 0.03)');
            desolateGradient.addColorStop(1, 'hsla(280, 30%, 15%, 0)'); // Transparent at right edge
            ctx.fillStyle = desolateGradient;
            ctx.fillRect(desolateZoneStart, 0, desolateZoneEnd - desolateZoneStart, config.worldHeight);

            // Predator Den (Right) - Fades from transparent at its left edge
            let predatorGradient = ctx.createLinearGradient(predatorDenStart, 0, config.worldWidth, 0);
            predatorGradient.addColorStop(0, 'hsla(0, 80%, 20%, 0)'); // Transparent at left edge
            predatorGradient.addColorStop(0.2, 'hsla(0, 80%, 20%, 0.05)'); // Red, blending
            predatorGradient.addColorStop(1, 'hsla(340, 70%, 15%, 0.15)'); // Darker Pink/Red, stronger near right
            ctx.fillStyle = predatorGradient;
            ctx.fillRect(predatorDenStart, 0, config.worldWidth - predatorDenStart, config.worldHeight);


            // Draw all entities (their draw method expects original world coordinates)
            for (let entity of entities) {
                entity.draw(ctx);
            }

            // Restore canvas transform to original (no zoom for UI elements or other overlays)
            ctx.restore();

            // Update stats panel
            document.getElementById('preyCount').textContent = currentPreyCount;
            document.getElementById('predatorCount').textContent = currentPredatorCount;
            document.getElementById('hunterCount').textContent = currentHunterCount;
            document.getElementById('foodCount').textContent = currentFoodCount;
            document.getElementById('totalPreySurvivalTime').textContent = totalPreySurvivalTicks.toFixed(0);
            document.getElementById('totalPredatorSurvivalTime').textContent = totalPredatorSurvivalTicks.toFixed(0);
            document.getElementById('totalHunterSurvivalTime').textContent = totalHunterSurvivalTicks.toFixed(0);
            document.getElementById('totalBirths').textContent = totalBirths;
            document.getElementById('totalGeneticMutations').textContent = totalGeneticMutations;
            document.getElementById('simulationTicks').textContent = simulationTicks;
        }

        /**
         * The main game loop, called repeatedly via requestAnimationFrame.
         * @param {DOMHighResTimeStamp} currentTime - The time value passed by requestAnimationFrame.
         */
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            updateSimulation();
            drawSimulation();

            // Only request next frame if simulation is not paused or game is over
            if (!simulationPaused && !gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        /**
         * Resizes the canvas to fill the window and updates the Quadtree boundary.
         * Also adjusts initial camera position to center the world.
         */
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Auto-adjust zoom level to fit the entire world on screen initially
            const scaleX = canvas.width / config.worldWidth;
            const scaleY = canvas.height / config.worldHeight;
            config.zoomLevel = Math.min(scaleX, scaleY);
            // Ensure a reasonable minimum zoom (don't zoom out excessively)
            config.zoomLevel = Math.max(config.zoomLevel, 0.01);

            // Center camera initially so the entire world is visible
            cameraX = (config.worldWidth - (canvas.width / config.zoomLevel)) / 2;
            cameraY = (config.worldHeight - (canvas.height / config.zoomLevel)) / 2;
            clampCamera(); // Ensure camera is within bounds after initial centering

            // Update quadtree boundary to new world dimensions
            quadtree = new QuadTree(new Rectangle(config.worldWidth / 2, config.worldHeight / 2, config.worldWidth / 2, config.worldHeight / 2), config.quadtreeCapacity);
            // After resizing, redraw immediately to avoid visual glitches
            drawSimulation();
        }

        /**
         * Sets up the UI controls (sliders, start/pause button, hide/show panel, zoom buttons).
         */
        function setupUI() {
            const startPauseButton = document.getElementById('start-pause-button');
            const togglePanelButton = document.getElementById('toggle-panel-button');
            const uiPanel = document.getElementById('ui-panel');
            const zoomControls = document.getElementById('zoom-controls');
            const zoomInButton = document.getElementById('zoom-in-button');
            const zoomOutButton = document.getElementById('zoom-out-button');
            const showPanelButton = document.getElementById('show-panel-button');
            const restartGameButton = document.getElementById('restart-game-button');

            const sliders = [
                { id: 'timeScale', prop: 'timeScale', valueSpan: 'timeScaleValue', precision: 1 },
                { id: 'mutationRate', prop: 'mutationRate', valueSpan: 'mutationRateValue', precision: 3 },
                { id: 'foodSpawnRate', prop: 'foodSpawnRate', valueSpan: 'foodSpawnRateValue', precision: 1 },
                { id: 'foodEnergy', prop: 'foodEnergy', valueSpan: 'foodEnergyValue', precision: 0 },
                { id: 'preyTargetPopulation', prop: 'preyTargetPopulation', valueSpan: 'preyTargetPopulationValue', precision: 0 },
                { id: 'predatorTargetPopulation', prop: 'predatorTargetPopulation', valueSpan: 'predatorTargetPopulationValue', precision: 0 },
                { id: 'hunterTargetPopulation', prop: 'hunterTargetPopulation', valueSpan: 'hunterTargetPopulationValue', precision: 0 }, // New hunter slider
                { id: 'preyMaxSpeed', prop: 'preyMaxSpeed', valueSpan: 'preyMaxSpeedValue', precision: 1 },
                { id: 'predatorMaxSpeed', prop: 'predatorMaxSpeed', valueSpan: 'predatorMaxSpeedValue', precision: 1 },
                { id: 'hunterMaxSpeed', prop: 'hunterMaxSpeed', valueSpan: 'hunterMaxSpeedValue', precision: 1 }, // New hunter slider
            ];

            // Initialize slider values and add event listeners
            sliders.forEach(s => {
                const slider = document.getElementById(s.id);
                const valueSpan = document.getElementById(s.valueSpan);

                // Set initial value from config
                slider.value = config[s.prop];
                // Display initial value, formatted based on precision
                valueSpan.textContent = config[s.prop].toFixed(s.precision);

                // Add input event listener to update config and display value in real-time
                slider.addEventListener('input', (event) => {
                    config[s.prop] = parseFloat(event.target.value);
                    valueSpan.textContent = config[s.prop].toFixed(s.precision);
                });
            });

            // Start/Pause Button Logic
            startPauseButton.addEventListener('click', () => {
                if (gameOver) {
                    // This button acts as a restart when game is over
                    hideGameOverStats();
                    generateInitialPopulation();
                    simulationPaused = false;
                    startPauseButton.textContent = 'Pause Simulation';
                    lastFrameTime = performance.now();
                    requestAnimationFrame(gameLoop);
                } else {
                    // Normal pause/resume logic
                    simulationPaused = !simulationPaused;
                    if (!simulationPaused) {
                        startPauseButton.textContent = 'Pause Simulation';
                        lastFrameTime = performance.now();
                        requestAnimationFrame(gameLoop);
                    } else {
                        startPauseButton.textContent = 'Resume Simulation';
                    }
                }
            });

            // Hide/Show God Panel Logic
            togglePanelButton.addEventListener('click', () => {
                const isHidden = uiPanel.classList.toggle('hidden');
                togglePanelButton.textContent = isHidden ? 'Show Panel' : 'Hide Panel';
                zoomControls.classList.toggle('visible', isHidden); // Show zoom controls if panel is hidden
                showPanelButton.classList.toggle('visible', isHidden); // Show "Show Panel" button if panel is hidden
            });

            // "Show Panel" Button Logic
            showPanelButton.addEventListener('click', () => {
                uiPanel.classList.remove('hidden'); // Show the main panel
                togglePanelButton.textContent = 'Hide Panel'; // Update its text
                zoomControls.classList.remove('visible'); // Hide zoom controls
                showPanelButton.classList.remove('visible'); // Hide this button
            });


            // Zoom Buttons Logic
            zoomInButton.addEventListener('click', () => {
                const oldZoom = config.zoomLevel;
                config.zoomLevel = Math.min(config.zoomLevel * 1.1, 3.0); // Increase zoom by 10%, max 3.0

                // Adjust camera to zoom into center of current view
                const centerX = cameraX + (canvas.width / 2 / oldZoom);
                const centerY = cameraY + (canvas.height / 2 / oldZoom);
                cameraX = centerX - (canvas.width / 2 / config.zoomLevel);
                cameraY = centerY - (canvas.height / 2 / config.zoomLevel);
                clampCamera();
                drawSimulation(); // Redraw immediately to apply zoom
            });

            zoomOutButton.addEventListener('click', () => {
                const oldZoom = config.zoomLevel;
                config.zoomLevel = Math.max(config.zoomLevel * 0.9, 0.01); // Decrease zoom by 10%, min 0.01

                // Adjust camera to zoom out from center of current view
                const centerX = cameraX + (canvas.width / 2 / oldZoom);
                const centerY = cameraY + (canvas.height / 2 / oldZoom);
                cameraX = centerX - (canvas.width / 2 / config.zoomLevel);
                cameraY = centerY - (canvas.height / 2 / config.zoomLevel);
                clampCamera();
                drawSimulation(); // Redraw immediately to apply zoom
            });

            // Restart Game button on Game Over Overlay
            restartGameButton.addEventListener('click', () => {
                hideGameOverStats();
                generateInitialPopulation();
                simulationPaused = false;
                // Update the main start/pause button as well
                document.getElementById('start-pause-button').textContent = 'Pause Simulation';
                lastFrameTime = performance.now();
                requestAnimationFrame(gameLoop);
            });
        }

        // Initialize the simulation when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initSimulation);

    </script>
</body>
</html>