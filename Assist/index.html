<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Assist - Peer-to-Peer Aid</title>
    <!-- Leaflet CSS for Maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css">

    <style>
        /* Your existing CSS (no changes) */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f7f6;
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background-color: #28a745;
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        main {
            flex-grow: 1;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align content to the top */
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
            width: 100%;
            max-width: 800px;
            box-sizing: border-box;
        }
        h1, h2, h3 {
            color: #28a745;
            text-align: center;
            margin-bottom: 20px;
        }
        input[type="text"], input[type="number"], textarea, select {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        button {
            background-color: #28a745;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin-right: 10px;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #218838;
        }
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .message-list, .request-list, .chat-box {
            border: 1px solid #eee;
            max-height: 400px;
            overflow-y: auto;
            padding: 15px;
            border-radius: 4px;
            background-color: #fcfcfc;
            margin-bottom: 20px;
        }
        .message-item, .request-item {
            background-color: #e9f7ef;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 5px solid #28a745;
            word-wrap: break-word;
        }
        .message-item strong {
            color: #007bff;
        }
        .message-item.self {
            background-color: #d1ecf1;
            border-left-color: #007bff;
            text-align: right;
        }
        .message-item.self strong {
            color: #28a745;
        }
        .request-item.accepted {
            border-left-color: #ffc107;
            background-color: #fff3cd;
        }
        .request-item.completed {
            border-left-color: #17a2b8;
            background-color: #d1ecf1;
        }
        .status-message {
            text-align: center;
            font-style: italic;
            color: #666;
            margin-top: 15px;
        }
        .hidden {
            display: none;
        }
        #map {
            height: 300px;
            width: 100%;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        footer {
            margin-top: 20px;
            padding: 15px;
            text-align: center;
            color: #666;
            font-size: 0.85rem;
            border-top: 1px solid #eee;
        }
        .tab-buttons {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-bottom: none;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            margin: 0 2px;
        }
        .tab-button.active {
            background-color: #28a745;
            color: white;
            border-color: #28a745;
        }
        .tab-content {
            padding-top: 10px;
        }
        .message-input-area {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .message-input-area input {
            flex-grow: 1;
            margin-bottom: 0;
        }
        .item-list {
            list-style-type: none;
            padding: 0;
            margin-top: 10px;
        }
        .item-list li {
            background-color: #f0f0f0;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .item-list li button {
            padding: 5px 8px;
            font-size: 0.8rem;
            margin-left: 10px;
        }
        .request-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .request-header h3 {
            margin: 0;
            text-align: left;
            flex-grow: 1;
        }
    </style>

    <!-- Firebase SDKs - ADDED -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <!-- You might need other services like auth or functions, but these are core for data & chat -->

</head>
<body>
    <header>
        <h1>Local Assist</h1>
        <p id="user-info"></p>
        <button id="logout-button" class="btn-secondary hidden">Logout</button>
    </header>

    <main>
        <div class="container" id="app-container">
            <!-- Content will be dynamically loaded here -->
            <div id="loading-screen" style="text-align: center;">
                <p>Initializing Firebase...</p>
                <div class="spinner"></div>
            </div>
        </div>
    </main>

    <footer>
        <p>Â© 2023 Local Assist. All rights reserved. Prototype Version.</p>
    </footer>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        const firebaseConfig = {
        apiKey: "AIzaSyAvutjrwWBsZ_5bCPN-nbL3VpP2NQ94EUY",
        authDomain: "tap-guardian-rpg.firebaseapp.com",
        databaseURL: "https://tap-guardian-rpg-default-rtdb.firebaseio.com",
        projectId: "tap-guardian-rpg",
        storageBucket: "tap-guardian-rpg.firebasestorage.app",
        messagingSenderId: "50272459426",
        appId: "1:50272459426:web:8f67f9126d3bc3a23a15fb",
        measurementId: "G-XJRE7YNPZR"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        // --- Configuration ---
        // Your Cloud Functions API endpoint
        // This will be based on your projectId and the default region (us-central1 is common)
        const API_BASE_URL = `https://us-central1-${firebaseConfig.projectId}.cloudfunctions.net/api`;

        // --- Core Application State ---
        let currentUser = null; // { username: '', role: 'help' | 'assist', lat: null, lng: null, cashapp: '' }
        let requests = []; // Fetched from server and updated by Firestore listener
        let activeRequestId = null; // The request ID currently being viewed/chatted in.
        let unsubscribeFromRequest = null; // To manage the active Firestore listener for a request document

        // --- Constants ---
        const DISTANCE_THRESHOLD_MILES = 50;
        const POLL_INTERVAL_DASHBOARD_MS = 5000; // Poll for dashboard updates

        // --- Default Locations for Simulation (if Geolocation fails) ---
        const DEFAULT_LOCATIONS = {
            help: { lat: 33.584, lng: -112.015 }, // Near downtown Phoenix, AZ
            assist: { lat: 33.425, lng: -111.940 } // Near Tempe, AZ (approx 10-15 miles from help default)
        };

        // --- DOM Elements Cache ---
        const appContainer = document.getElementById('app-container');
        const userInfoDisplay = document.getElementById('user-info');
        const logoutButton = document.getElementById('logout-button');

        // --- API Helper Functions ---
        async function apiFetch(endpoint, method = 'GET', body = null) {
            try {
                const options = { method, headers: { 'Content-Type': 'application/json' } };
                if (body) {
                    options.body = JSON.stringify(body);
                }
                const response = await fetch(`${API_BASE_URL}${endpoint}`, options);
                if (!response.ok) {
                    // Try to parse error message from server
                    const errorText = await response.text();
                    console.error(`API Error on ${method} ${endpoint}: Status ${response.status}, Response:`, errorText);
                    try {
                        const errorData = JSON.parse(errorText);
                        throw new Error(errorData.message || `Server error! Status: ${response.status}`);
                    } catch {
                        // If response is not JSON, just show generic error
                        throw new Error(`Server error! Status: ${response.status}: ${errorText.substring(0, 100)}...`);
                    }
                }
                // Handle 204 No Content for DELETE requests
                if (response.status === 204) {
                    return true; // Indicate success for deletion
                }
                return await response.json();
            } catch (error) {
                console.error(`API Fetch Error:`, error);
                alert(`Error during API call: ${error.message}. Check console for details.`);
                return null;
            }
        }

        // --- Helper Functions (geolocation, distance - unchanged) ---

        /**
         * Generates a unique ID (simple UUID-like for prototype).
         * Note: Backend generates its own ID now, but this is still useful for local temp IDs or testing.
         */
        function generateUniqueId() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Calculates distance between two lat/lng points in miles.
         */
        function calculateDistance(lat1, lon1, lat2, lon2) {
            if (typeof lat1 !== 'number' || typeof lon1 !== 'number' || typeof lat2 !== 'number' || typeof lon2 !== 'number' ||
                isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
                return Infinity;
            }

            const R = 3958.8; // Earth's radius in miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;
            return distance;
        }

        /**
         * Gets user's current geolocation or falls back to a default based on role.
         */
        function getUserLocation(role) {
            return new Promise((resolve) => {
                if ("geolocation" in navigator) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            console.log("Geolocation successful:", position.coords.latitude, position.coords.longitude);
                            resolve({
                                lat: position.coords.latitude,
                                lng: position.coords.longitude
                            });
                        },
                        (error) => {
                            console.warn(`Geolocation error: ${error.message}. Using default location for role: ${role}.`);
                            resolve(DEFAULT_LOCATIONS[role] || DEFAULT_LOCATIONS.help);
                        },
                        { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
                    );
                } else {
                    console.warn(`Geolocation is not supported by this browser. Using default location for role: ${role}.`);
                    resolve(DEFAULT_LOCATIONS[role] || DEFAULT_LOCATIONS.help);
                }
            });
        }

        // --- Core Rendering Logic ---
        function renderApp() {
            appContainer.innerHTML = '';
            userInfoDisplay.textContent = currentUser ? `${currentUser.username} (${currentUser.role === 'help' ? 'Needs Help' : 'Provides Assistance'})` : 'Please Login';
            logoutButton.classList.toggle('hidden', !currentUser);

            // Clean up old Firestore listener if transitioning away from chat
            if (unsubscribeFromRequest && !activeRequestId) {
                unsubscribeFromRequest();
                unsubscribeFromRequest = null;
                console.log("Firestore listener unsubscribed.");
            }

            if (!currentUser) {
                renderLogin();
                return;
            }

            if (!currentUser.role) {
                renderRoleSelection();
                return;
            }

            if (currentUser.lat === null || currentUser.lng === null || isNaN(currentUser.lat) || isNaN(currentUser.lng)) {
                renderLocationPrompt();
                return;
            }

            if (activeRequestId) {
                const request = requests.find(r => r.id === activeRequestId);
                // Ensure the request belongs to the current user before rendering chat
                if (request && (request.helpUser === currentUser.username || request.assistUser === currentUser.username)) {
                    renderChatScreen(request);
                } else {
                    activeRequestId = null; // Request not found or not relevant to current user
                    renderApp(); // Re-render main dashboard
                }
                return;
            }

            if (currentUser.role === 'help') {
                renderHelpUserDashboard();
            } else if (currentUser.role === 'assist') {
                renderAssistUserDashboard();
            }
        }

        // --- UI Rendering Functions ---

        function renderLogin() {
            appContainer.innerHTML = `
                <h2>Welcome to Local Assist!</h2>
                <p>Please enter your username to continue.</p>
                <div class="form-group">
                    <label for="username-input">Username:</label>
                    <input type="text" id="username-input" placeholder="Enter your username" required>
                </div>
                <div class="form-group">
                    <label for="cashapp-input">Your CashApp Tag (for assistants, optional):</label>
                    <input type="text" id="cashapp-input" placeholder="e.g., $YourCashAppTag">
                    <small>Help users will see this if you accept their request.</small>
                </div>
                <button id="login-button">Login</button>
            `;
            document.getElementById('login-button').addEventListener('click', handleLogin);
        }

        async function handleLogin() {
            const usernameInput = document.getElementById('username-input');
            const cashappInput = document.getElementById('cashapp-input');
            const username = usernameInput.value.trim();
            const cashappTag = cashappInput.value.trim();

            if (!username) {
                alert('Please enter a username.');
                return;
            }

            const response = await apiFetch(`/login`, 'POST', { username, cashapp: cashappTag });
            if (response) {
                currentUser = response;
                localStorage.setItem('currentUser', JSON.stringify(currentUser)); // Store for session continuity
                renderApp();
            }
        }

        function renderRoleSelection() {
            appContainer.innerHTML = `
                <h2>Select Your Role</h2>
                <p>Are you looking for help, or offering assistance?</p>
                <button id="select-help-user-button">I Need Help</button>
                <button id="select-assist-user-button">I Can Assist</button>
            `;
            document.getElementById('select-help-user-button').addEventListener('click', () => handleRoleSelection('help'));
            document.getElementById('select-assist-user-button').addEventListener('click', () => handleRoleSelection('assist'));
        }

        async function handleRoleSelection(role) {
            currentUser.role = role;
            const loc = await getUserLocation(role);
            currentUser.lat = loc.lat;
            currentUser.lng = loc.lng;

            const response = await apiFetch(`/login`, 'POST', currentUser);
            if (response) {
                currentUser = response;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                renderApp();
            }
        }

        function renderLocationPrompt() {
            appContainer.innerHTML = `
                <h2>Get Your Location</h2>
                <p>We need your location to connect you with relevant users. Please click "Share My Location" and allow browser permissions.</p>
                <button id="get-location-button">Share My Location</button>
                <p class="status-message" id="location-status-message"></p>
            `;
            const locationStatusMessage = document.getElementById('location-status-message');
            document.getElementById('get-location-button').addEventListener('click', async () => {
                locationStatusMessage.textContent = "Attempting to get location...";
                const loc = await getUserLocation(currentUser.role);
                currentUser.lat = loc.lat;
                currentUser.lng = loc.lng;

                const response = await apiFetch(`/login`, 'POST', currentUser);
                if (response) {
                    currentUser = response;
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    if (currentUser.lat !== null && currentUser.lng !== null && !isNaN(currentUser.lat)) {
                        locationStatusMessage.textContent = `Location obtained: ${currentUser.lat.toFixed(4)}, ${currentUser.lng.toFixed(4)}`;
                    } else {
                        locationStatusMessage.textContent = "Could not get precise location. Using a default location. Please enable GPS and try again.";
                    }
                    setTimeout(renderApp, 1500);
                }
            });
        }

        async function updateCurrentUserLocation(role) {
            const loc = await getUserLocation(role);
            currentUser.lat = loc.lat;
            currentUser.lng = loc.lng;
            const response = await apiFetch(`/login`, 'POST', currentUser);
            if (response) {
                currentUser = response;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
        }

        function renderHelpUserDashboard() {
            appContainer.innerHTML = `
                <h2>Hello, ${currentUser.username}! What do you need help with?</h2>
                <p>Your Location: ${currentUser.lat ? `${currentUser.lat.toFixed(4)}, ${currentUser.lng.toFixed(4)}` : 'Unknown'}</p>
                <button id="refresh-location-button">Refresh Location</button>
                <hr>
                <h3>Request New Assistance</h3>
                <div class="form-group">
                    <label for="store-name">Store Name:</label>
                    <input type="text" id="store-name" placeholder="e.g., Walmart, Local Pharmacy" required>
                </div>
                <div class="form-group">
                    <label for="items-needed">Items Needed (one per line):</label>
                    <textarea id="items-needed" rows="5" placeholder="Milk
Bread
Eggs"></textarea>
                </div>
                <button id="request-assistance-button">Request Assistance</button>

                <h3>Your Active Requests</h3>
                <div id="your-requests" class="request-list">
                    <p class="status-message">Loading requests...</p>
                </div>
            `;
            document.getElementById('refresh-location-button').addEventListener('click', async () => {
                await updateCurrentUserLocation(currentUser.role);
                renderApp();
            });
            document.getElementById('request-assistance-button').addEventListener('click', handleRequestAssistance);
            fetchRequests();
        }

        async function fetchRequests() {
            const allFetchedRequests = await apiFetch('/requests');
            if (allFetchedRequests) {
                // Ensure timestamps are converted from Firestore format to Date objects for client-side use
                requests = allFetchedRequests.map(req => ({
                    ...req,
                    // Firestore `timestamp` field is a Timestamp object, convert to Date
                    // Messages can also have Timestamp objects
                    timestamp: req.timestamp && req.timestamp._seconds ? new Date(req.timestamp._seconds * 1000 + req.timestamp._nanoseconds / 1000000) : req.timestamp,
                    messages: req.messages ? req.messages.map(msg => ({
                        ...msg,
                        timestamp: msg.timestamp && msg.timestamp._seconds ? new Date(msg.timestamp._seconds * 1000 + msg.timestamp._nanoseconds / 1000000) : msg.timestamp // Handles embedded message timestamps
                    })) : []
                }));

                if (currentUser.role === 'help') {
                    renderHelpUserRequests();
                } else if (currentUser.role === 'assist') {
                    renderAvailableRequests();
                    renderAssistUserAcceptedRequests();
                }
            }
        }

        function renderHelpUserRequests() {
            const yourRequestsDiv = document.getElementById('your-requests');
            if (!yourRequestsDiv) return;

            yourRequestsDiv.innerHTML = '';
            const userRequests = requests.filter(r => r.helpUser === currentUser.username);

            if (userRequests.length === 0) {
                yourRequestsDiv.innerHTML = '<p class="status-message">You have no active requests.</p>';
                return;
            }

            userRequests.sort((a, b) => {
                const order = { 'pending': 1, 'accepted': 2, 'in_progress': 3, 'completed': 4, 'denied': 5 };
                return order[a.status] - order[b.status];
            });

            userRequests.forEach(request => {
                const requestEl = document.createElement('div');
                requestEl.classList.add('request-item', request.status);
                let statusText = '';
                let actions = '';

                switch (request.status) {
                    case 'pending':
                        statusText = 'Waiting for an assistant...';
                        actions = `<button class="delete-request-button btn-secondary" data-request-id="${request.id}">Cancel Request</button>`;
                        break;
                    case 'accepted':
                        statusText = `Accepted by ${request.assistUser}!`;
                        actions = `<button class="view-chat-button" data-request-id="${request.id}">View Live Map & Chat</button>`;
                        break;
                    case 'in_progress':
                        statusText = `Shopping in progress by ${request.assistUser}`;
                        actions = `<button class="view-chat-button" data-request-id="${request.id}">View Live Map & Chat</button>`;
                        break;
                    case 'completed':
                        statusText = `Delivered by ${request.assistUser}!`;
                        if (request.confirmDeliveryTimestamp) {
                           statusText = `Completed! You confirmed delivery.`;
                           actions = `<button class="view-chat-button" data-request-id="${request.id}">View Details & Chat</button>
                                      <button class="delete-request-button btn-secondary" data-request-id="${request.id}">Delete Record</button>`;
                        } else {
                            actions = `<button class="help-confirm-delivery-button" data-request-id="${request.id}">Confirm Delivery & Complete</button>
                                       <button class="view-chat-button btn-secondary" data-request-id="${request.id}">View Details & Chat</button>`;
                        }
                        break;
                    case 'denied':
                        statusText = `Request denied by ${request.assistUser || 'an assistant'}.`;
                        actions = `<button class="delete-request-button btn-secondary" data-request-id="${request.id}">Delete</button>`;
                        break;
                }

                requestEl.innerHTML = `
                    <div class="request-header">
                        <h3>Request for ${request.store}</h3>
                        <div>Status: <strong>${statusText}</strong></div>
                    </div>
                    <p><strong>Items:</strong></p>
                    <ul class="item-list">
                        ${request.items.map(item => `<li>${item}</li>`).join('')}
                    </ul>
                    ${request.subtotal ? `<p><strong>Subtotal:</strong> $${request.subtotal.toFixed(2)}</p>` : ''}
                    ${request.cashappTag ? `<p><strong>Assistant's CashApp:</strong> <span style="font-family: monospace; font-weight: bold; color: #6200EE;">${request.cashappTag}</span></p>` : ''}
                    ${request.receiptImage ? `<p><strong>Receipt:</strong> <a href="${request.receiptImage}" target="_blank">View Receipt</a><br><img src="${request.receiptImage}" alt="Receipt" style="max-width: 100%; height: auto; display: block; margin-top: 10px; border: 1px solid #ddd;"></p>` : ''}
                    <div style="text-align: right; margin-top: 10px;">${actions}</div>
                `;
                yourRequestsDiv.appendChild(requestEl);
            });

            yourRequestsDiv.querySelectorAll('.view-chat-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    activeRequestId = e.target.dataset.requestId;
                    renderApp();
                });
            });
            yourRequestsDiv.querySelectorAll('.delete-request-button').forEach(button => {
                button.addEventListener('click', async (e) => {
                    if (confirm('Are you sure you want to delete this request? This cannot be undone.')) {
                        const success = await apiFetch(`/requests/${e.target.dataset.requestId}`, 'DELETE');
                        if (success) {
                            requests = requests.filter(r => r.id !== e.target.dataset.requestId);
                            renderApp();
                        }
                    }
                });
            });
            yourRequestsDiv.querySelectorAll('.help-confirm-delivery-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    handleHelpConfirmDelivery({ target: { dataset: { requestId: e.target.dataset.requestId } } });
                });
            });
        }

        async function handleRequestAssistance() {
            const storeName = document.getElementById('store-name').value.trim();
            const itemsNeeded = document.getElementById('items-needed').value.split('\n').map(item => item.trim()).filter(item => item !== '');

            if (!storeName || itemsNeeded.length === 0) {
                alert('Please enter a store name and at least one item.');
                return;
            }
             if (currentUser.lat === null || currentUser.lng === null || isNaN(currentUser.lat) || isNaN(currentUser.lng)) {
                alert('Your location is not set or invalid. Please refresh your location before requesting assistance.');
                return;
            }

            const newRequestData = {
                helpUser: currentUser.username,
                helpUserLoc: { lat: currentUser.lat, lng: currentUser.lng },
                status: 'pending',
                store: storeName,
                items: itemsNeeded,
                messages: []
            };
            const response = await apiFetch('/requests', 'POST', newRequestData);
            if (response) {
                alert('Assistance request sent! We will notify you when an assistant accepts.');
                await fetchRequests(); // Refresh requests after sending
                renderApp();
            }
        }

        function renderAssistUserDashboard() {
            appContainer.innerHTML = `
                <h2>Hello, ${currentUser.username}! Ready to assist?</h2>
                <p>Your Location: ${currentUser.lat ? `${currentUser.lat.toFixed(4)}, ${currentUser.lng.toFixed(4)}` : 'Unknown'}</p>
                <button id="refresh-location-button">Refresh Location</button>
                <hr>
                <div class="tab-buttons">
                    <button class="tab-button active" data-tab="available-requests">Available Requests</button>
                    <button class="tab-button" data-tab="your-accepted-requests">Your Accepted Requests</button>
                </div>
                <div id="tab-content-wrapper">
                    <div id="available-requests-tab" class="tab-content">
                        <h3>Nearby Help Requests (within ${DISTANCE_THRESHOLD_MILES} miles)</h3>
                        <div id="available-requests" class="request-list">
                            <p class="status-message">Loading requests...</p>
                        </div>
                    </div>
                    <div id="your-accepted-requests-tab" class="tab-content hidden">
                        <h3>Your Accepted Requests</h3>
                        <div id="your-accepted-requests" class="request-list">
                            <p class="status-message">You haven't accepted any requests yet.</p>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('refresh-location-button').addEventListener('click', async () => {
                await updateCurrentUserLocation(currentUser.role);
                renderApp();
            });

            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
                    document.getElementById(`${e.target.dataset.tab}-tab`).classList.remove('hidden');
                });
            });

            fetchRequests();
        }

        function renderAvailableRequests() {
            const availableRequestsDiv = document.getElementById('available-requests');
            if (!availableRequestsDiv) return;

            availableRequestsDiv.innerHTML = '';

            const nearbyPendingRequests = requests.filter(req => {
                if (req.status !== 'pending') return false;
                if (!req.helpUserLoc || typeof req.helpUserLoc.lat !== 'number' || isNaN(req.helpUserLoc.lat)) return false;
                if (currentUser.lat === null || currentUser.lng === null || isNaN(currentUser.lat)) return false;

                const distance = calculateDistance(currentUser.lat, currentUser.lng, req.helpUserLoc.lat, req.helpUserLoc.lng);
                return distance <= DISTANCE_THRESHOLD_MILES;
            });

            if (nearbyPendingRequests.length === 0) {
                availableRequestsDiv.innerHTML = '<p class="status-message">No nearby requests currently available within 50 miles.</p>';
                return;
            }

            nearbyPendingRequests.forEach(request => {
                const distance = calculateDistance(currentUser.lat, currentUser.lng, request.helpUserLoc.lat, request.helpUserLoc.lng).toFixed(1);
                const requestEl = document.createElement('div');
                requestEl.classList.add('request-item');
                requestEl.innerHTML = `
                    <div class="request-header">
                        <h3>Request from ${request.helpUser}</h3>
                        <div>${distance} miles away</div>
                    </div>
                    <p><strong>Store:</strong> ${request.store}</p>
                    <p><strong>Items:</strong></p>
                    <ul class="item-list">
                        ${request.items.map(item => `<li>${item}</li>`).join('')}
                    </ul>
                    <div style="text-align: right; margin-top: 10px;">
                        <button class="accept-request-button" data-request-id="${request.id}">Accept Request</button>
                        <button class="deny-request-button btn-secondary" data-request-id="${request.id}">Deny Request</button>
                    </div>
                `;
                availableRequestsDiv.appendChild(requestEl);
            });

            availableRequestsDiv.querySelectorAll('.accept-request-button').forEach(button => {
                button.addEventListener('click', handleAcceptRequest);
            });
            availableRequestsDiv.querySelectorAll('.deny-request-button').forEach(button => {
                button.addEventListener('click', handleDenyRequest);
            });
        }

        function renderAssistUserAcceptedRequests() {
            const acceptedRequestsDiv = document.getElementById('your-accepted-requests');
            if (!acceptedRequestsDiv) return;

            acceptedRequestsDiv.innerHTML = '';
            const acceptedRequests = requests.filter(r =>
                r.assistUser === currentUser.username && (r.status === 'accepted' || r.status === 'in_progress' || r.status === 'completed')
            );

            if (acceptedRequests.length === 0) {
                acceptedRequestsDiv.innerHTML = '<p class="status-message">You haven\'t accepted any requests yet.</p>';
                return;
            }

            acceptedRequests.sort((a, b) => {
                const order = { 'accepted': 1, 'in_progress': 2, 'completed': 3 };
                return order[a.status] - order[b.status];
            });

            acceptedRequests.forEach(request => {
                const requestEl = document.createElement('div');
                requestEl.classList.add('request-item', request.status);
                let statusText = '';
                let actions = '';

                switch (request.status) {
                    case 'accepted':
                        statusText = `Accepted, heading to ${request.store}!`;
                        actions = `
                            <button class="view-chat-button" data-request-id="${request.id}">View Live Map & Chat</button>
                            <button class="update-location-button" data-request-id="${request.id}">Update My Location</button>
                            <button class="mark-arrived-button" data-request-id="${request.id}">Arrived at Store</button>
                        `;
                        break;
                    case 'in_progress':
                        statusText = `Shopping for ${request.helpUser} at ${request.store}`;
                        actions = `
                            <button class="view-chat-button" data-request-id="${request.id}">View Live Map & Chat</button>
                            <button class="update-location-button" data-request-id="${request.id}">Update My Location</button>
                            ${!request.subtotal ? `<button class="confirm-purchase-button" data-request-id="${request.id}">Confirm Purchase</button>` : ''}
                            ${request.subtotal && !request.confirmDeliveryTimestamp ? `<button class="mark-delivered-button" data-request-id="${request.id}">Mark as Delivered</button>` : ''}
                        `;
                        break;
                    case 'completed':
                        statusText = `Delivered to ${request.helpUser}! ${request.confirmDeliveryTimestamp ? '(Confirmed by them)' : '(Awaiting their confirmation)'}`;
                        actions = `<button class="view-chat-button" data-request-id="${request.id}">View Details & Chat</button>`;
                        if (request.confirmDeliveryTimestamp) {
                            actions += `<button class="delete-request-button btn-secondary" data-request-id="${request.id}">Delete Record</button>`;
                        }
                        break;
                }

                requestEl.innerHTML = `
                    <div class="request-header">
                        <h3>Request for ${request.store} from ${request.helpUser}</h3>
                        <div>Status: <strong>${statusText}</strong></div>
                    </div>
                    <p><strong>Items:</strong></p>
                    <ul class="item-list">
                        ${request.items.map(item => `<li>${item}</li>`).join('')}
                    </ul>
                    ${request.subtotal ? `<p><strong>Subtotal:</strong> $${request.subtotal.toFixed(2)}</p>` : ''}
                    ${request.receiptImage ? `<p><strong>Receipt:</strong> <a href="${request.receiptImage}" target="_blank">View Receipt</a><br><img src="${request.receiptImage}" alt="Receipt" style="max-width: 100%; height: auto; display: block; margin-top: 10px; border: 1px solid #ddd;"></p>` : ''}
                    <div style="text-align: right; margin-top: 10px;">${actions}</div>
                `;
                acceptedRequestsDiv.appendChild(requestEl);
            });

            acceptedRequestsDiv.querySelectorAll('.view-chat-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    activeRequestId = e.target.dataset.requestId;
                    renderApp();
                });
            });
            acceptedRequestsDiv.querySelectorAll('.update-location-button').forEach(button => {
                button.addEventListener('click', handleAssistantUpdateLocation);
            });
            acceptedRequestsDiv.querySelectorAll('.mark-arrived-button').forEach(button => {
                button.addEventListener('click', handleAssistantArrivedAtStore);
            });
            acceptedRequestsDiv.querySelectorAll('.confirm-purchase-button').forEach(button => {
                button.addEventListener('click', handleAssistantConfirmPurchase);
            });
            acceptedRequestsDiv.querySelectorAll('.mark-delivered-button').forEach(button => {
                button.addEventListener('click', handleAssistantMarkDelivered);
            });
            acceptedRequestsDiv.querySelectorAll('.delete-request-button').forEach(button => {
                button.addEventListener('click', async (e) => {
                    if (confirm('Are you sure you want to delete this completed request record?')) {
                        const success = await apiFetch(`/requests/${e.target.dataset.requestId}`, 'DELETE');
                        if (success) {
                            requests = requests.filter(r => r.id !== e.target.dataset.requestId);
                            renderApp();
                        }
                    }
                });
            });
        }


        async function handleAcceptRequest(event) {
            const requestId = event.target.dataset.requestId;
            const requestIndex = requests.findIndex(r => r.id === requestId);

            if (requestIndex !== -1 && requests[requestIndex].status === 'pending') {
                if (!currentUser.cashapp || currentUser.cashapp.length < 2 || !currentUser.cashapp.startsWith('$')) {
                    alert("Please set a valid CashApp tag (starting with $) on your login screen before accepting requests.");
                    return;
                }

                // IMPORTANT: Fetch latest from DB to prevent race condition
                const latestRequestsFromServer = await apiFetch(`/requests`);
                const latestRequest = latestRequestsFromServer.find(r => r.id === requestId);

                if (latestRequest && latestRequest.status !== 'pending') {
                    alert(`This request has already been ${latestRequest.status} by another user.`);
                    await fetchRequests(); // Refresh data
                    renderApp();
                    return;
                }

                const initialMessage = {
                    sender: currentUser.username,
                    text: `I've accepted your request! I'm heading to ${requests[requestIndex].store} now. My CashApp tag is ${currentUser.cashapp}.`,
                    timestamp: new Date().toISOString()
                };

                const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                    status: 'accepted',
                    assistUser: currentUser.username,
                    assistUserLoc: { lat: currentUser.lat, lng: currentUser.lng },
                    cashappTag: currentUser.cashapp,
                    messages: [initialMessage] // Send initial message with update
                });

                if (updatedRequest) {
                    // Update the local requests array with the new request data (if API provides it)
                    const idx = requests.findIndex(r => r.id === updatedRequest.id);
                    if (idx !== -1) { requests[idx] = updatedRequest; } else { requests.push(updatedRequest); } // Should be update

                    activeRequestId = requestId;
                    renderApp();
                }
            }
        }

        async function handleDenyRequest(event) {
            const requestId = event.target.dataset.requestId;
            const requestIndex = requests.findIndex(r => r.id === requestId);

            if (requestIndex !== -1 && requests[requestIndex].status === 'pending') {
                const latestRequestsFromServer = await apiFetch(`/requests`);
                const latestRequest = latestRequestsFromServer.find(r => r.id === requestId);

                if (latestRequest && latestRequest.status !== 'pending') {
                    alert(`This request has already been ${latestRequest.status} by another user.`);
                    await fetchRequests();
                    renderApp();
                    return;
                }

                const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                    status: 'denied',
                    assistUser: currentUser.username
                });
                if (updatedRequest) {
                    const idx = requests.findIndex(r => r.id === updatedRequest.id);
                    if (idx !== -1) { requests[idx] = updatedRequest; }
                    alert(`Request from ${requests[requestIndex].helpUser} has been denied.`);
                    renderApp();
                }
            }
        }

        async function handleAssistantUpdateLocation(event) {
            const requestId = event.target.dataset.requestId;
            const requestIndex = requests.findIndex(r => r.id === requestId);

            if (requestIndex !== -1) {
                const loc = await getUserLocation(currentUser.role);
                const currentRequest = requests[requestIndex];

                const newMessage = {
                    sender: currentUser.username,
                    text: `My live location has been updated. I'm currently at ${loc.lat.toFixed(4)}, ${loc.lng.toFixed(4)}.`,
                    timestamp: new Date().toISOString()
                };

                // Update request on server
                const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                    assistantCurrentLoc: { lat: loc.lat, lng: loc.lng },
                    messages: [...currentRequest.messages, newMessage] // Append new message
                });

                if (updatedRequest) {
                    // Firestore listener will automatically update `requests` and re-render the chat screen.
                    alert('Your live location and message sent!');
                }
            }
        }

        async function handleAssistantArrivedAtStore(event) {
            const requestId = event.target.dataset.requestId;
            const requestIndex = requests.findIndex(r => r.id === requestId);

            if (requestIndex !== -1 && requests[requestIndex].status === 'accepted') {
                const currentRequest = requests[requestIndex];
                const newMessage = {
                    sender: currentUser.username,
                    text: `I have arrived at ${currentRequest.store}! What items are hard to find?`,
                    timestamp: new Date().toISOString()
                };

                const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                    status: 'in_progress',
                    messages: [...currentRequest.messages, newMessage] // Append new message
                });

                if (updatedRequest) {
                    // Firestore listener will automatically update `requests` and trigger re-render
                    activeRequestId = requestId; // Keep on this chat screen
                    renderApp(); // Force re-render to update buttons if status changed
                }
            }
        }

        async function handleAssistantConfirmPurchase(event) {
            const requestId = event.target.dataset.requestId;
            const requestIndex = requests.findIndex(r => r.id === requestId);

            if (requestIndex !== -1) {
                const currentRequest = requests[requestIndex];
                const subtotalStr = prompt("Enter the subtotal amount for the items (e.g., 25.50):");
                const subtotal = parseFloat(subtotalStr);

                if (isNaN(subtotal) || subtotal <= 0) {
                    alert("Please enter a valid positive number for the subtotal.");
                    return;
                }

                const receiptUrl = prompt("Enter a URL for the receipt image (optional, leave blank or type N/A if none):");
                const finalReceiptUrl = (receiptUrl && receiptUrl.toLowerCase() !== 'n/a' && receiptUrl.startsWith('http')) ? receiptUrl : null;

                let messageText = `Shopping complete! Your subtotal is $${subtotal.toFixed(2)}.`;
                if (currentRequest.cashappTag) {
                    messageText += ` Please send funds to my CashApp: ${currentRequest.cashappTag}.`;
                }
                if (finalReceiptUrl) {
                    messageText += `\nReceipt attached: ${finalReceiptUrl}`;
                } else {
                    messageText += `\n(No digital receipt provided).`;
                }
                const newMessage = { sender: currentUser.username, text: messageText, timestamp: new Date().toISOString() };

                const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                    subtotal: subtotal,
                    receiptImage: finalReceiptUrl,
                    messages: [...currentRequest.messages, newMessage]
                });

                if (updatedRequest) {
                    // Firestore listener will automatically update `requests` and re-render
                    activeRequestId = requestId;
                    renderApp(); // Force re-render to update buttons if subtotal changed
                }
            }
        }

        async function handleAssistantMarkDelivered(event) {
            const requestId = event.target.dataset.requestId;
            const requestIndex = requests.findIndex(r => r.id === requestId);

            if (requestIndex !== -1 && requests[requestIndex].status === 'in_progress') {
                const currentRequest = requests[requestIndex];
                const newMessage = {
                    sender: currentUser.username,
                    text: "Items delivered! Please confirm delivery on your end.",
                    timestamp: new Date().toISOString()
                };

                const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                    status: 'completed',
                    messages: [...currentRequest.messages, newMessage]
                });

                if (updatedRequest) {
                    alert("Items marked as delivered. Awaiting help user's confirmation.");
                    activeRequestId = requestId;
                    renderApp(); // Force re-render to update buttons if status changed
                }
            }
        }

        async function handleHelpConfirmDelivery(event) {
            const requestId = event.target.dataset.requestId;
            const requestIndex = requests.findIndex(r => r.id === requestId);

            if (requestIndex !== -1 && requests[requestIndex].status === 'completed') {
                const currentRequest = requests[requestIndex];
                const newMessage = {
                    sender: currentUser.username,
                    text: "Delivery confirmed! Thank you for your assistance!",
                    timestamp: new Date().toISOString()
                };

                const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                    confirmDeliveryTimestamp: new Date().toISOString(),
                    messages: [...currentRequest.messages, newMessage]
                });

                if (updatedRequest) {
                    alert("Delivery confirmed! Thank you for using Local Assist!");
                    activeRequestId = null; // Exit chat
                    renderApp();
                }
            }
        }

        function renderChatScreen(request) {
            if (map) { map.remove(); map = null; }

            appContainer.innerHTML = `
                <h2>Chat with ${request.helpUser === currentUser.username ? request.assistUser : request.helpUser} for ${request.store}</h2>
                <p>Status: <strong>${request.status.replace('_', ' ').toUpperCase()}</strong></p>
                <div id="map"></div>
                <div id="chat-messages" class="chat-box"></div>
                <div class="message-input-area">
                    <input type="text" id="chat-input" placeholder="Type your message...">
                    <button id="send-chat-message-button">Send</button>
                </div>
                <div style="margin-top: 15px; text-align: center;">
                    ${currentUser.role === 'assist' && request.status === 'accepted' ?
                        `<button id="assist-update-location-btn">Update My Live Location</button>
                         <button id="assist-mark-arrived-btn">Arrived at Store</button>` : ''}
                    ${currentUser.role === 'assist' && request.status === 'in_progress' ?
                         `<button id="assist-update-location-btn">Update My Live Location</button>
                          ${!request.subtotal ? `<button id="assist-confirm-purchase-btn">Confirm Purchase & Send Subtotal</button>` : ''}
                          ${request.subtotal && !request.confirmDeliveryTimestamp ? `<button id="assist-mark-delivered-btn">Mark as Delivered</button>` : ''}`
                       : ''}
                    ${currentUser.role === 'help' && request.status === 'completed' && !request.confirmDeliveryTimestamp ?
                        `<button id="help-confirm-delivery-btn">Confirm Delivery & Complete</button>` : ''}
                    ${(request.status === 'denied' || (request.status === 'completed' && request.confirmDeliveryTimestamp)) &&
                       (request.helpUser === currentUser.username || (request.assistUser === currentUser.username && request.confirmDeliveryTimestamp)) ?
                        `<button class="delete-request-button btn-secondary" data-request-id="${request.id}">Delete Record</button>` : ''}
                    <button class="btn-secondary" id="back-to-dashboard">Back to Dashboard</button>
                </div>
            `;

            const chatMessagesDiv = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('send-chat-message-button');
            const backButton = document.getElementById('back-to-dashboard');

            sendButton.addEventListener('click', () => handleSendChatMessage(request.id, chatInput.value));
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleSendChatMessage(request.id, chatInput.value);
                }
            });
            backButton.addEventListener('click', () => {
                activeRequestId = null;
                renderApp();
            });

            if (currentUser.role === 'assist') {
                document.getElementById('assist-update-location-btn')?.addEventListener('click', () => handleAssistantUpdateLocation({ target: { dataset: { requestId: request.id } } }));
                document.getElementById('assist-mark-arrived-btn')?.addEventListener('click', () => handleAssistantArrivedAtStore({ target: { dataset: { requestId: request.id } } }));
                document.getElementById('assist-confirm-purchase-btn')?.addEventListener('click', () => handleAssistantConfirmPurchase({ target: { dataset: { requestId: request.id } } }));
                document.getElementById('assist-mark-delivered-btn')?.addEventListener('click', () => handleAssistantMarkDelivered({ target: { dataset: { requestId: request.id } } }));
            } else if (currentUser.role === 'help' && request.status === 'completed' && !request.confirmDeliveryTimestamp) {
                document.getElementById('help-confirm-delivery-btn')?.addEventListener('click', () => handleHelpConfirmDelivery({ target: { dataset: { requestId: request.id } } }));
            }
            document.querySelector('.delete-request-button')?.addEventListener('click', async (e) => {
                if (confirm('Are you sure you want to delete this request record? This cannot be undone.')) {
                    const success = await apiFetch(`/requests/${e.target.dataset.requestId}`, 'DELETE');
                    if (success) {
                        activeRequestId = null;
                        renderApp();
                    }
                }
            });

            renderMessages(request.messages, chatMessagesDiv);
            setupMap(request);

            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;

            // --- Firestore Real-time Listener for the ACTIVE CHAT (NEW in Firebase version) ---
            // Unsubscribe from previous listener if active, to prevent memory leaks
            if (unsubscribeFromRequest) {
                unsubscribeFromRequest();
            }

            // Set up new listener for the specific request document
            unsubscribeFromRequest = db.collection('requests').doc(request.id)
                .onSnapshot(docSnapshot => {
                    if (docSnapshot.exists) {
                        const updatedRequest = { id: docSnapshot.id, ...docSnapshot.data() };
                        // Convert Firestore Timestamp objects to JS Date objects for consistency
                        updatedRequest.timestamp = updatedRequest.timestamp && typeof updatedRequest.timestamp.toDate === 'function' ? updatedRequest.timestamp.toDate() : updatedRequest.timestamp;
                        if (updatedRequest.messages) {
                           updatedRequest.messages = updatedRequest.messages.map(msg => ({
                               ...msg,
                               timestamp: msg.timestamp && typeof msg.timestamp.toDate === 'function' ? msg.timestamp.toDate() : new Date(msg.timestamp) // Handle potential string timestamps from old data/functions
                           }));
                        }
                        if (updatedRequest.confirmDeliveryTimestamp && typeof updatedRequest.confirmDeliveryTimestamp.toDate === 'function') {
                            updatedRequest.confirmDeliveryTimestamp = updatedRequest.confirmDeliveryTimestamp.toDate();
                        }

                        // Find and update this request in the global 'requests' array
                        const reqIndex = requests.findIndex(r => r.id === updatedRequest.id);
                        if (reqIndex !== -1) {
                            requests[reqIndex] = updatedRequest;
                        } else {
                            // This case should theoretically not happen if activeRequestId is correct, but good for robustness
                            requests.push(updatedRequest);
                        }

                        // Re-render the app. This will pick up the updated 'requests' global state
                        // and correctly re-render the chat messages, map, and buttons.
                        renderApp();
                        console.log("Real-time chat/request update from Firestore:", updatedRequest);
                    } else {
                        // Request document was deleted while in chat by the other user
                        alert("The active request has been cancelled or completed by the other user.");
                        activeRequestId = null;
                        renderApp(); // Go back to dashboard
                    }
                }, error => {
                    console.error("Error listening to request document:", error);
                });
        }

        function renderMessages(messages, chatMessagesDiv) {
            chatMessagesDiv.innerHTML = messages.map(msg => `
                <div class="message-item ${msg.sender === currentUser.username ? 'self' : ''}">
                    <strong>${msg.sender === currentUser.username ? 'You' : msg.sender}:</strong> ${msg.text.replace(/\n/g, '<br>')}
                    <small style="float: right; color: #888; font-size: 0.75em;">${new Date(msg.timestamp).toLocaleTimeString()}</small>
                </div>
            `).join('');
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
        }

        async function handleSendChatMessage(requestId, messageText) {
            messageText = messageText.trim();
            if (!messageText) return;

            const currentRequest = requests.find(r => r.id === requestId);
            if (!currentRequest) {
                console.warn("Current request not found for sending message.");
                return;
            }

            const newMessage = {
                sender: currentUser.username,
                text: messageText,
                timestamp: new Date().toISOString() // Send as ISO string, Cloud Function will convert to Firestore Timestamp
            };

            // Update request on server
            const updatedRequest = await apiFetch(`/requests/${requestId}`, 'PUT', {
                messages: [...currentRequest.messages, newMessage] // Append new message
            });

            if (updatedRequest) {
                document.getElementById('chat-input').value = ''; // Clear input
                // The Firestore listener will automatically update `requests` and re-render `renderMessages`
            } else {
                alert("Failed to send message. Please try again.");
            }
        }


        let map = null;
        let helpUserMarker = null;
        let assistantMarker = null;

        function setupMap(request) {
            const mapDiv = document.getElementById('map');
            if (!mapDiv) return;

            if (map) {
                map.remove();
                map = null;
            }

            const initialCenter = request.helpUserLoc || DEFAULT_LOCATIONS.help;
            map = L.map('map').setView([initialCenter.lat, initialCenter.lng], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            const markers = [];

            if (request.helpUserLoc && typeof request.helpUserLoc.lat === 'number' && !isNaN(request.helpUserLoc.lat)) {
                helpUserMarker = L.marker([request.helpUserLoc.lat, request.helpUserLoc.lng], {
                    icon: L.divIcon({
                        className: 'leaflet-div-icon help-marker',
                        html: '<div style="background-color: #007bff; width: 25px; height: 25px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.8em;">HELP</div>',
                        iconSize: [25, 25],
                        iconAnchor: [12.5, 12.5]
                    })
                })
                .addTo(map)
                .bindPopup(`<b>${request.helpUser}</b><br>Help User Location`);
                markers.push(helpUserMarker);
            }

            let currentAssistantLocation = null;
            if (request.assistantCurrentLoc && typeof request.assistantCurrentLoc.lat === 'number' && !isNaN(request.assistantCurrentLoc.lat)) {
                currentAssistantLocation = request.assistantCurrentLoc;
            } else if (request.assistUserLoc && typeof request.assistUserLoc.lat === 'number' && !isNaN(request.assistUserLoc.lat) && request.status !== 'denied') {
                currentAssistantLocation = request.assistUserLoc;
            }

            if (currentAssistantLocation) {
                assistantMarker = L.marker([currentAssistantLocation.lat, currentAssistantLocation.lng], {
                    icon: L.divIcon({
                        className: 'leaflet-div-icon assist-marker',
                        html: '<div style="background-color: #28a745; width: 25px; height: 25px; border-radius: 50%; border: 3px solid white; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.8em;">ASSIST</div>',
                        iconSize: [25, 25],
                        iconAnchor: [12.5, 12.5]
                    })
                })
                .addTo(map)
                .bindPopup(`<b>${request.assistUser}</b><br>Assistant's Location`);
                markers.push(assistantMarker);
            }

            if (markers.length > 0) {
                const group = new L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.5));
            } else {
                map.setView([initialCenter.lat, initialCenter.lng], 13);
            }
        }

        // --- Polling for Dashboard Updates (remains, as Firestore listeners are per-document) ---
        let dashboardPollInterval = null;
        function startDashboardPolling() {
            if (dashboardPollInterval) clearInterval(dashboardPollInterval);

            dashboardPollInterval = setInterval(async () => {
                // Only poll if not in an active chat screen, to save resources
                if (activeRequestId) return;

                const fetchedRequests = await apiFetch('/requests');
                if (fetchedRequests && JSON.stringify(requests) !== JSON.stringify(fetchedRequests)) {
                    // Map timestamps from Firestore format to Date objects
                    requests = fetchedRequests.map(req => ({
                        ...req,
                        timestamp: req.timestamp && req.timestamp._seconds ? new Date(req.timestamp._seconds * 1000 + req.timestamp._nanoseconds / 1000000) : req.timestamp,
                        messages: req.messages ? req.messages.map(msg => ({
                            ...msg,
                            timestamp: msg.timestamp && msg.timestamp._seconds ? new Date(msg.timestamp._seconds * 1000 + msg.timestamp._nanoseconds / 1000000) : msg.timestamp
                        })) : []
                    }));
                    console.log("Dashboard polling detected request changes, re-rendering.");
                    renderApp();
                }
            }, POLL_INTERVAL_DASHBOARD_MS);
        }

        // --- Event Handlers and Initializers ---

        logoutButton.addEventListener('click', () => {
            currentUser = null;
            activeRequestId = null;
            localStorage.removeItem('currentUser');
            if (map) { map.remove(); map = null; }
            if (unsubscribeFromRequest) { unsubscribeFromRequest(); unsubscribeFromRequest = null; } // Crucial: clean up listener
            renderApp();
        });


        // --- Initial Load Logic ---
        document.addEventListener('DOMContentLoaded', async () => {
            appContainer.innerHTML = '<p class="status-message">Initializing Local Assist...</p>';

            // Try to restore user from local storage
            try {
                const storedUserRaw = localStorage.getItem('currentUser');
                if (storedUserRaw) {
                    currentUser = JSON.parse(storedUserRaw);
                }
            } catch (e) {
                console.error("Error parsing currentUser from localStorage on init:", e);
                currentUser = null;
            }

            // If a user was found in local storage, try to refresh their full data from Firestore
            if (currentUser && currentUser.username) {
                // Fetch the user's latest data from the database to ensure consistency
                const userFromServer = await apiFetch('/login', 'POST', { username: currentUser.username }); // Use login to re-fetch/update user
                if (userFromServer) {
                    // Update currentUser with any potentially newer data from server (e.g., location if refreshed elsewhere)
                    currentUser = { ...currentUser, ...userFromServer };
                    localStorage.setItem('currentUser', JSON.stringify(currentUser)); // Persist updated current user locally
                    console.log(`Current user loaded from server: ${currentUser.username} (${currentUser.role})`);
                } else {
                    console.warn("Could not retrieve current user from server. Resetting session.");
                    currentUser = null;
                    localStorage.removeItem('currentUser');
                }
            } else {
                console.log("No current user found in localStorage. Displaying login.");
            }
            
            // Initial fetch of all requests for dashboard views
            await fetchRequests();
            
            // If user logged in but location isn't set/valid, try to get it
            if (currentUser && (currentUser.lat === null || currentUser.lng === null || isNaN(currentUser.lat) || isNaN(currentUser.lng))) {
                console.log("Current user needs location. Attempting to get it on startup.");
                await updateCurrentUserLocation(currentUser.role);
            }

            startDashboardPolling(); // Start polling for general dashboard updates
            renderApp(); // Initial render based on current state
        });

    </script>
</body>
</html>
