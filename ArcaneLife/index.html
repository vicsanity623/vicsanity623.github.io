<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arcane Beasts GO</title>
    <style>
        /* Basic Styles for HTML, body, and canvas */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222222; /* Dark grey background */
            color: #eeeeee; /* Light grey text */
            -webkit-user-select: none; /* Disable text selection for game feel */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none; /* Prevent browser touch gestures like pull to refresh */
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background-color: #222222; /* Match body for seamless look */
        }

        /* UI Overlay Container */
        #uiOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to canvas by default */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Pushes top/bottom menus to edges */
            align-items: center; /* Centers panels horizontally */
            z-index: 10; /* Ensure UI is above canvas */
        }

        /* Generic Panel Styling */
        .ui-panel {
            background: rgba(0, 0, 0, 0.85); /* Semi-transparent black background */
            border: 2px solid #888888; /* Mid-grey border */
            border-radius: 12px; /* Rounded corners */
            padding: 20px;
            box-shadow: 0 0 20px rgba(136, 136, 136, 0.7); /* Glowing shadow */
            pointer-events: auto; /* Re-enable pointer events for interaction */
            margin: 15px; /* Spacing from edges */
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto; /* Scroll for content if needed */
            box-sizing: border-box; /* Include padding/border in width/height */
            text-align: center;
            display: flex; /* Flexbox for internal layout */
            flex-direction: column;
            gap: 10px; /* Space between internal elements */
        }
        .ui-panel h2 {
            color: #aaaaaa; /* Lighter grey heading */
            margin-top: 0;
            margin-bottom: 15px;
            text-shadow: 0 0 5px rgba(170, 170, 170, 0.5);
        }

        /* Buttons */
        .ui-button {
            background: #555555; /* Dark grey button background */
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            transition: background 0.3s ease, transform 0.1s ease; /* Smooth transitions */
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            flex-shrink: 0; /* Prevent buttons from shrinking in flex containers */
        }
        .ui-button:hover {
            background: #777777; /* Lighter grey on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }
        .ui-button:active {
            transform: translateY(0); /* Press effect */
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        .ui-button:disabled {
            background: #444444;
            cursor: not-allowed;
            opacity: 0.7;
            box-shadow: none;
            transform: none;
        }

        /* Flexbox for button rows or stat displays */
        .flex-row {
            display: flex;
            flex-wrap: wrap; /* Allow items to wrap to next line */
            justify-content: center;
            align-items: center;
            gap: 10px; /* Space between items */
        }

        /* Stat/item display within panels */
        .stat-item, .item-entry {
            background: rgba(85, 85, 85, 0.2); /* Light grey background */
            border-radius: 6px;
            padding: 8px 12px;
            text-align: left;
            border: 1px solid rgba(136, 136, 136, 0.5);
            flex-grow: 1; /* Allows items to fill available space */
            min-width: 150px; /* Minimum width for readability */
        }
        .item-entry strong { color: #cccccc; } /* Accent color for item names */
        .item-entry em { font-size: 0.9em; opacity: 0.8; } /* Lighter description text */

        /* Top Bar Layout (GPS, HUD, Menu) */
        #topBar {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: grid;
            grid-template-columns: auto 1fr auto; /* GPS | HUD | Menu */
            gap: 10px; /* Space between elements */
            padding: 0 10px; /* Outer padding */
            box-sizing: border-box; /* Include padding in width */
            align-items: center;
            pointer-events: none; /* Allow clicks through by default */
            z-index: 10;
        }
        #gpsStatus {
            grid-column: 1;
            pointer-events: auto; /* Re-enable for status if clickable for info */
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9em;
            color: #bbbbbb;
        }
        /* Player HUD */
        #playerHud {
            grid-column: 2;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #888888;
            border-radius: 10px;
            padding: 8px 10px; /* Reduced horizontal padding */
            display: flex;
            justify-content: center; /* Center stats within their grid cell */
            align-items: center;
            gap: 5px; /* Reduced gap further */
            font-size: 0.9em; /* Slightly smaller font */
            color: #cccccc;
            pointer-events: none; /* Non-interactive for now */
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow if content is too long */
            text-overflow: ellipsis; /* Add ellipsis for overflowed text */
        }
        #playerHud .stat {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0; /* Prevent stats from shrinking too much */
        }
        #playerHud .stat-value {
            font-weight: bold;
            color: #eeeeee;
        }
        #topMenu {
            grid-column: 3;
            pointer-events: auto; /* Re-enable for menu button */
            display: flex; /* To center its content if needed */
            justify-content: flex-end; /* Push button to right within its cell */
        }

        /* Global message box (moved to bottom center) */
        #messageBox {
            position: absolute;
            bottom: 50px; /* Offset from the bottom */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #888888; /* Grey border for warnings/important messages */
            color: white;
            padding: 15px 25px; /* Reduced padding slightly */
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(136, 136, 136, 0.6);
            font-size: 1.1em; /* Slightly smaller font */
            text-align: center;
            z-index: 1000; /* Highest z-index */
            pointer-events: none; /* Don't block clicks */
            opacity: 0; /* Hidden by default */
            transition: opacity 0.4s ease-in-out; /* Fade in/out */
            max-width: 70%; /* Narrower width */
        }

        /* Creature 3D view in creature panel */
        #creature3DView {
            width: 250px; /* Larger view */
            height: 200px;
            background: rgba(255,255,255,0.05); /* Very subtle background */
            border: 1px dashed rgba(255,255,255,0.2); /* Dashed border */
            margin: 15px auto;
            border-radius: 8px;
            overflow: hidden; /* Ensure canvas fits */
        }
        #creature3DView canvas {
            display: block; /* Remove extra space below canvas */
        }

        /* Taming Bar */
        #tameBarContainer {
            width: 90%;
            height: 35px;
            background: #333;
            border: 2px solid #555;
            border-radius: 18px;
            overflow: hidden;
            margin: 20px auto;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        #tameBar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #444444, #888888); /* Greyscale gradient */
            border-radius: 18px;
            transition: width 0.1s linear, background 0.3s ease; /* Smooth bar filling */
        }

        /* Placement Controls */
        #placementControls {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #888888;
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 0 15px rgba(136, 136, 136, 0.7);
        }

        /* Active Crafts Display */
        #activeCrafts {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #666;
            border-radius: 8px;
            padding: 10px;
            pointer-events: none; /* Read-only for now */
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.9em;
            text-align: left;
            z-index: 10;
        }
        #activeCrafts h4 {
            margin: 0 0 5px 0;
            color: #cccccc;
        }
        #activeCrafts ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #activeCrafts li {
            margin-bottom: 3px;
        }

        /* Joystick */
        #joystickBase {
            position: absolute;
            bottom: 40px; /* Offset from bottom */
            left: 40px; /* Offset from left */
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #888888;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto; /* Make it clickable */
            z-index: 20; /* Above other UI */
        }

        #joystickHandle {
            width: 50px;
            height: 50px;
            background: rgba(136, 136, 136, 0.7); /* Semi-transparent handle */
            border: 2px solid #eeeeee;
            border-radius: 50%;
            position: absolute; /* Allows handle to move within base */
            transform: translate(0, 0); /* Initial position */
            transition: background 0.1s ease; /* Smooth color change on active */
        }
        #joystickHandle.active {
            background: rgba(255, 255, 255, 0.8); /* Brighter when active */
        }


        /* Utility Class */
        .hidden {
            display: none !important;
            opacity: 0;
            visibility: hidden;
        }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            .ui-panel {
                padding: 10px;
                margin: 5px;
                max-width: 95%;
            }
            .ui-button {
                padding: 10px 15px;
                font-size: 1em;
            }
            #creature3DView {
                width: 180px;
                height: 140px;
            }
            #tameBarContainer {
                height: 25px;
            }
            #messageBox {
                font-size: 0.9em;
                padding: 10px 15px;
                bottom: 20px; /* Adjust for smaller screens */
            }
            #placementControls {
                flex-direction: column;
                gap: 5px;
                padding: 8px;
                bottom: 10px;
            }
            #activeCrafts {
                right: 5px;
                bottom: 5px;
                padding: 5px;
                font-size: 0.8em;
            }
            #joystickBase {
                width: 100px;
                height: 100px;
                bottom: 20px;
                left: 20px;
            }
            #joystickHandle {
                width: 40px;
                height: 40px;
            }
            #topBar {
                grid-template-columns: auto 1fr auto; /* Still 3 columns */
                gap: 5px; /* Smaller gap */
                padding: 0 5px; /* Smaller outer padding */
            }
            #gpsStatus {
                padding: 6px 8px;
                font-size: 0.8em;
            }
            #playerHud {
                padding: 6px 8px;
                font-size: 0.8em;
                gap: 3px; /* Even smaller gap for very compact stats */
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="uiOverlay">
        <div id="topBar">
            <!-- GPS Status Indicator -->
            <div id="gpsStatus">Waiting for GPS...</div>

            <!-- Player HUD -->
            <div id="playerHud">
                <div class="stat">HP: <span id="playerHp" class="stat-value">100</span></div>
                <div class="stat">XP: <span id="playerXp" class="stat-value">0</span></div>
                <div class="stat">Hunger: <span id="playerHunger" class="stat-value">100</span></div>
                <div class="stat">Thirst: <span id="playerThirst" class="stat-value">100</span></div>
                <div class="stat">Gold: <span id="playerGoldHud" class="stat-value">0</span></div>
            </div>

            <!-- Top Menu Button -->
            <div id="topMenu">
                <button class="ui-button" id="mainMenuButton">Menu</button>
            </div>
        </div>


        <!-- Main Menu Panel -->
        <div id="mainMenuPanel" class="ui-panel hidden">
            <h2>Main Menu</h2>
            <div class="flex-row">
                <button class="ui-button" id="inventoryButton">Inventory</button>
                <button class="ui-button" id="traderButton">Trader</button>
                <button class="ui-button" id="craftingButton">Crafting</button>
                <button class="ui-button" id="arenaButton">Arena</button>
                <button class="ui-button" id="closeMainMenuButton">Close</button>
            </div>
        </div>

        <!-- Creature Interaction Panel -->
        <div id="creaturePanel" class="ui-panel hidden">
            <h2 id="creatureName"></h2>
            <div id="creature3DView"></div>
            <div id="creatureStats" class="flex-row"></div>
            <div class="flex-row">
                <button class="ui-button" id="feedBerryButton">Feed Berry</button>
                <button class="ui-button" id="tameButton">Tame</button>
                <button class="ui-button" id="closeCreaturePanelButton">Back</button>
            </div>
        </div>

        <!-- Taming Mini-Game Panel -->
        <div id="tamingPanel" class="ui-panel hidden">
            <h2>Tame this Creature!</h2>
            <p>Tap the game screen fast to fill the bar!</p>
            <div id="tameBarContainer"><div id="tameBar"></div></div>
            <button class="ui-button" id="tameCancelButton">Cancel</button>
        </div>

        <!-- Inventory Panel -->
        <div id="inventoryPanel" class="ui-panel hidden">
            <h2>Inventory</h2>
            <p>Gold: <span id="playerGold">0</span></p>
            <div id="inventoryList" style="max-height: 250px; overflow-y: auto;"></div>
            <button class="ui-button" id="closeInventoryButton">Close</button>
        </div>

        <!-- Trader Panel -->
        <div id="traderPanel" class="ui-panel hidden">
            <h2>Trader Shop</h2>
            <p>Your Gold: <span id="traderGold">0</span></p>
            <h3>Buy Items</h3>
            <div id="buyItemsList" style="max-height: 200px; overflow-y: auto;"></div>
            <h3>Sell Items</h3>
            <div id="sellItemsList" style="max-height: 200px; overflow-y: auto;"></div>
            <button class="ui-button" id="closeTraderButton">Close</button>
        </div>

        <!-- Crafting Panel -->
        <div id="craftingPanel" class="ui-panel hidden">
            <h2>Crafting Station</h2>
            <h3>Available Recipes</h3>
            <div id="craftingRecipesList" style="max-height: 300px; overflow-y: auto;"></div>
            <button class="ui-button" id="closeCraftingButton">Close</button>
        </div>

        <!-- Arena Panel -->
        <div id="arenaPanel" class="ui-panel hidden">
            <h2>Arena</h2>
            <p>Welcome to the Arena! Select a creature to battle a wild beast.</p>
            <div id="arenaCreatureList" style="max-height: 200px; overflow-y: auto;"></div>
            <div id="arenaBattleLog" style="height: 150px; overflow-y: auto; background: rgba(0,0,0,0.5); padding: 10px; margin-top: 10px; border-radius: 8px;"></div>
            <button class="ui-button" id="arenaNextOpponentButton">Fight Next Opponent</button>
            <button class="ui-button" id="closeArenaButton">Close</button>
        </div>

        <!-- Placement Controls -->
        <div id="placementControls" class="hidden">
            <button class="ui-button" id="confirmPlacementButton">Place Here</button>
            <button class="ui-button" id="cancelPlacementButton">Cancel</button>
        </div>

        <!-- Active Crafts Display -->
        <div id="activeCrafts">
            <h4>Active Crafts</h4>
            <ul id="activeCraftsList">
                <li>None</li>
            </ul>
        </div>

        <!-- Joystick -->
        <div id="joystickBase">
            <div id="joystickHandle"></div>
        </div>
    </div>

    <!-- Global Message Box -->
    <div id="messageBox" class="hidden"></div>

    <!-- Three.js CDN - Required for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
    <script>
        // --- Core Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const uiOverlay = document.getElementById('uiOverlay');
        const messageBox = document.getElementById('messageBox');
        const gpsStatusElement = document.getElementById('gpsStatus');
        const playerHud = document.getElementById('playerHud'); // The HUD container

        let scene, camera, renderer;
        let player; // Player's 3D avatar (will now move)
        let wildCreatureMeshes = [];
        let activePlacedBuildingMeshes = [];
        let activeTreeMeshes = [];
        let activeStoneMeshes = [];
        let traderModel;

        // Player's game state (will be loaded/saved)
        let playerInventory = {
            gold: 0,
            items: {},
            creatures: [],
            stats: { // New player stats
                health: 100,
                maxHealth: 100,
                xp: 0,
                level: 1, // Basic level for future
                hunger: 100,
                maxHunger: 100,
                thirst: 100,
                maxThirst: 100
            },
            playerPos: { x: 0, y: 1, z: 0 } // Player's world position
        };

        // World objects that persist (will be loaded/saved)
        let worldObjects = {
            placedBuildings: []
        };

        // Active Crafting System
        let activeCrafts = []; // Stores {id, name, startTime, duration, kitName}

        // Game state management for UI and interaction
        const GAME_STATE = {
            EXPLORE: 'explore',
            MENU: 'menu',
            CREATURE_INTERACT: 'creature_interact',
            TAMING: 'taming',
            INVENTORY: 'inventory',
            TRADER: 'trader',
            CRAFTING: 'crafting',
            ARENA: 'arena',
            PLACEMENT: 'placement'
        };
        let currentGameState = GAME_STATE.EXPLORE;

        const MAP_SIZE = 400; // Size of our simulated world map
        const CREATURE_SPAWN_RADIUS = 70; // Max distance from player for creature spawns
        const INITIAL_TREES = 30;
        const INITIAL_STONES = 20;
        const SPAWN_LIFESPAN_SECONDS = 60; // How long a creature spawn lasts

        // Geolocation tracking
        let lastKnownGeoCoords = null;
        const MOVEMENT_THRESHOLD_METERS = 1; // Distance moved to trigger new spawns
        const SPAWN_ON_MOVE_COUNT = 5;
        let gpsWatchId = null;
        let initialCreaturesSpawned = false;

        // Player Movement (Joystick)
        const PLAYER_MOVE_SPEED = 0.5; // Units per frame
        let moveDirection = new THREE.Vector3(); // Current normalized movement direction from joystick

        // Placement mode variables
        let placementMode = false;
        let placementItemData = null;
        let placementGhostMesh = null;
        let placementGroundIntersection = null;

        // Raycaster for object interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(); // For mouse/touch input in 2D screen space
        const raycastPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Ground plane for placement intersection (y=0)

        // UI Element References (for Player HUD)
        const playerHpElem = document.getElementById('playerHp');
        const playerXpElem = document.getElementById('playerXp');
        const playerHungerElem = document.getElementById('playerHunger');
        const playerThirstElem = document.getElementById('playerThirst');
        const playerGoldHudElem = document.getElementById('playerGoldHud'); // New for HUD Gold

        const mainMenuPanel = document.getElementById('mainMenuPanel');
        const creaturePanel = document.getElementById('creaturePanel');
        const tamingPanel = document.getElementById('tamingPanel');
        const inventoryPanel = document.getElementById('inventoryPanel');
        const traderPanel = document.getElementById('traderPanel');
        const craftingPanel = document.getElementById('craftingPanel');
        const arenaPanel = document.getElementById('arenaPanel');
        const placementControls = document.getElementById('placementControls'); // For confirm/cancel
        const activeCraftsList = document.getElementById('activeCraftsList'); // For active crafts display

        const creatureNameElem = document.getElementById('creatureName');
        const creature3DViewDiv = document.getElementById('creature3DView');
        let creatureMiniScene, creatureMiniCamera, creatureMiniRenderer;
        let currentCreature3DModel = null;
        const creatureStatsElem = document.getElementById('creatureStats');
        const tameBar = document.getElementById('tameBar');

        const playerGoldElem = document.getElementById('playerGold'); // For inventory/trader panel
        const traderGoldElem = document.getElementById('traderGold');
        const inventoryListElem = document.getElementById('inventoryList');
        const buyItemsListElem = document.getElementById('buyItemsList');
        const sellItemsListElem = document.getElementById('sellItemsList');
        const craftingRecipesListElem = document.getElementById('craftingRecipesList');
        const arenaCreatureListElem = document.getElementById('arenaCreatureList');
        const arenaBattleLogElem = document.getElementById('arenaBattleLog');
        const arenaNextOpponentButton = document.getElementById('arenaNextOpponentButton');
        const confirmPlacementButton = document.getElementById('confirmPlacementButton');
        const cancelPlacementButton = document.getElementById('cancelPlacementButton');

        // Joystick Elements
        const joystickBase = document.getElementById('joystickBase');
        const joystickHandle = document.getElementById('joystickHandle');
        let joystickActive = false;
        const joystickRadius = joystickBase.clientWidth / 2;


        // --- Game Data Definitions ---

        // Greyscale color definitions for game elements
        const G_BLACK = 0x111111;
        const G_DARK_GREY = 0x333333;
        const G_MEDIUM_GREY = 0x666666;
        const G_LIGHT_GREY = 0xaaaaaa;
        const G_WHITE = 0xeeeeee;
        const G_PLAYER_ORANGE = 0xFF4500; // Player specific color from screenshot example

        // Different creature types with their visual properties (colors converted to greyscale)
        const CREATURE_TYPES = [
            { name: "Glimmerwing", baseColor: 0x888888, modelType: 'flying', size: 1.5, likesBerry: true }, // Light grey
            { name: "Stonehide", baseColor: 0x666666, modelType: 'quadruped', size: 2.2, likesBerry: false }, // Mid grey
            { name: "Whisperoot", baseColor: 0x444444, modelType: 'plantoid', size: 1.8, likesBerry: true }, // Darker grey
            { name: "Blazefang", baseColor: 0x333333, modelType: 'bipedal', size: 2, likesBerry: false }, // Very dark grey
            { name: "Moonpetal", baseColor: 0xcccccc, modelType: 'plantoid', size: 1.5, likesBerry: true }, // Very light grey
            { name: "Deepscale", baseColor: 0x555555, modelType: 'quadruped', size: 2.5, likesBerry: false } // Medium dark grey
        ];

        // Item definitions (properties like value, description, craftTime)
        const ITEM_DEFINITIONS = {
            "Berry": { type: "consumable", value: 5, description: "A juicy berry, some creatures love it!" },
            "Axe": { type: "tool", value: 50, description: "Allows you to chop down trees for wood." },
            "Pickaxe": { type: "tool", value: 75, description: "Allows you to mine stones for stone." },
            "Wood": { type: "material", value: 10, description: "Basic crafting material from trees." },
            "Stone": { type: "material", value: 8, description: "Basic building material from rocks." },
            "Tent Kit": { type: "blueprint", value: 150, description: "Blueprint to build a cozy tent.", crafts: [{item: "Wood", amount: 20}], craftTime: 5 },
            "Campfire Kit": { type: "blueprint", value: 100, description: "Blueprint to build a warm campfire.", crafts: [{item: "Wood", amount: 10}, {item: "Stone", amount: 5}], craftTime: 7 },
            "Small House Kit": { type: "blueprint", value: 500, description: "Blueprint to build a small house.", crafts: [{item: "Wood", amount: 50}, {item: "Stone", amount: 30}], craftTime: 15 },
            "Stone Wall Kit": { type: "blueprint", value: 50, description: "Blueprint for a sturdy stone wall.", crafts: [{item: "Stone", amount: 10}], craftTime: 3 },
            "Wooden Fence Kit": { type: "blueprint", value: 30, description: "Blueprint for a simple wooden fence.", crafts: [{item: "Wood", amount: 10}], craftTime: 3 }
        };

        // Items available at the trader shop
        const TRADER_ITEMS = [
            { id: "Berry", price: 10, stock: 10 },
            { id: "Axe", price: 50, stock: 1 },
            { id: "Pickaxe", price: 75, stock: 1 },
            { id: "Tent Kit", price: 150, stock: 1 },
            { id: "Campfire Kit", price: 100, stock: 1 },
            { id: "Small House Kit", price: 500, stock: 1 },
            { id: "Stone Wall Kit", price: 50, stock: 5 },
            { id: "Wooden Fence Kit", price: 30, stock: 5 }
        ];

        // Crafting recipes
        const CRAFTING_RECIPES = [
            { name: "Tent", requires: { "Wood": 20 }, result: { type: "placeable", name: "Tent", kitName: "Tent Kit" } },
            { name: "Campfire", requires: { "Wood": 10, "Stone": 5 }, result: { type: "placeable", name: "Campfire", kitName: "Campfire Kit" } },
            { name: "Small House", requires: { "Wood": 50, "Stone": 30 }, result: { type: "placeable", name: "Small House", kitName: "Small House Kit" } },
            { name: "Stone Wall", requires: { "Stone": 10 }, result: { type: "placeable", name: "Stone Wall", kitName: "Stone Wall Kit" } },
            { name: "Wooden Fence", requires: { "Wood": 10 }, result: { type: "placeable", name: "Wooden Fence", kitName: "Wooden Fence Kit" } }
        ];

        // --- Helper Functions ---

        function showMessage(text, duration = 2000) {
            messageBox.textContent = text;
            messageBox.classList.remove('hidden');
            messageBox.style.opacity = 1;
            clearTimeout(messageBox.hideTimeout);
            messageBox.hideTimeout = setTimeout(() => {
                messageBox.style.opacity = 0;
                setTimeout(() => messageBox.classList.add('hidden'), 300);
            }, duration);
        }

        function toggleUIPanel(panelElement, stateToSet) {
            document.querySelectorAll('.ui-panel').forEach(panel => {
                if (panel !== panelElement) {
                    panel.classList.add('hidden');
                }
            });
            if (currentGameState === GAME_STATE.PLACEMENT) {
                 exitPlacementMode();
            }
            panelElement.classList.toggle('hidden');
            currentGameState = panelElement.classList.contains('hidden') ? GAME_STATE.EXPLORE : stateToSet;
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function haversineDistance(coords1, coords2) {
            const R = 6371e3;
            const φ1 = coords1.latitude * Math.PI / 180;
            const φ2 = coords2.latitude * Math.PI / 180;
            const Δφ = (coords2.latitude - coords1.latitude) * Math.PI / 180;
            const Δλ = (coords2.longitude - coords1.longitude) * Math.PI / 180;
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // --- Advanced 3D Model Creation Functions ---

        function createCreatureModel(typeDef, isMini = false) {
            let group = new THREE.Group();
            const baseColor = new THREE.Color(typeDef.baseColor);
            const material = new THREE.MeshPhongMaterial({ color: baseColor });
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: G_BLACK });
            const accentMaterial = new THREE.MeshPhongMaterial({ color: baseColor.clone().offsetHSL(0, 0, 0.2) });

            const scale = isMini ? 0.4 : 1;
            const sizeM = typeDef.size * scale;

            let head, body;

            switch (typeDef.modelType) {
                case 'flying':
                    body = new THREE.Mesh(new THREE.SphereGeometry(0.5 * sizeM, 16, 8), material);
                    body.scale.z = 2;
                    body.position.y = 0.5 * sizeM;
                    head = new THREE.Mesh(new THREE.SphereGeometry(0.3 * sizeM, 12, 12), material);
                    head.position.set(0, 0.8 * sizeM, 0.7 * sizeM);
                    group.add(body, head);
                    const wingGeom = new THREE.PlaneGeometry(1.8 * sizeM, 0.6 * sizeM);
                    const wingMat = new THREE.MeshPhongMaterial({ color: accentMaterial.color, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                    const createWingPair = (yPos, zOffset, rotY) => {
                        let w1 = new THREE.Mesh(wingGeom, wingMat); w1.position.set(0.6 * sizeM, yPos, zOffset); w1.rotation.y = rotY;
                        let w2 = w1.clone(); w2.position.x *= -1; w2.rotation.y *= -1;
                        group.add(w1, w2);
                    };
                    createWingPair(0.9 * sizeM, 0.2 * sizeM, Math.PI / 5);
                    createWingPair(0.7 * sizeM, -0.1 * sizeM, Math.PI / 4);
                    break;

                case 'quadruped':
                    body = new THREE.Mesh(new THREE.BoxGeometry(1.5 * sizeM, 1.0 * sizeM, 2.5 * sizeM), material);
                    body.position.y = 0.5 * sizeM;
                    head = new THREE.Mesh(new THREE.ConeGeometry(0.6 * sizeM, 1.0 * sizeM, 12), material);
                    head.rotation.x = Math.PI / 2;
                    head.position.set(0, 0.8 * sizeM, 1.5 * sizeM);
                    group.add(body, head);
                    const legGeom = new THREE.CylinderGeometry(0.2 * sizeM, 0.2 * sizeM, 1.2 * sizeM, 8);
                    const footGeom = new THREE.SphereGeometry(0.25 * sizeM, 8, 8);
                    const createLeg = (xPos, zPos) => {
                        let leg = new THREE.Mesh(legGeom, material);
                        leg.position.set(xPos, -0.1 * sizeM, zPos);
                        let foot = new THREE.Mesh(footGeom, accentMaterial);
                        foot.position.y = -0.6 * sizeM;
                        leg.add(foot);
                        group.add(leg);
                    };
                    createLeg(0.6 * sizeM, 1.0 * sizeM);
                    createLeg(-0.6 * sizeM, 1.0 * sizeM);
                    createLeg(0.6 * sizeM, -1.0 * sizeM);
                    createLeg(-0.6 * sizeM, -1.0 * sizeM);
                    const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.15 * sizeM, 0.3 * sizeM, 1.5 * sizeM, 8), accentMaterial);
                    tail.rotation.x = -Math.PI / 3;
                    tail.position.set(0, 0.8 * sizeM, -1.5 * sizeM);
                    group.add(tail);
                    break;

                case 'plantoid':
                    body = new THREE.Mesh(new THREE.CylinderGeometry(0.8 * sizeM, 1.0 * sizeM, 2.0 * sizeM, 16), material);
                    body.position.y = 1.0 * sizeM;
                    head = new THREE.Mesh(new THREE.SphereGeometry(0.7 * sizeM, 16, 16), accentMaterial);
                    head.position.y = 2.5 * sizeM;
                    group.add(body, head);
                    const rootGeom = new THREE.ConeGeometry(0.3 * sizeM, 1.0 * sizeM, 8);
                    for(let i=0; i<3; i++) {
                        let root = new THREE.Mesh(rootGeom, material);
                        root.rotation.x = Math.PI / 2; root.rotation.z = (i * Math.PI * 2 / 3);
                        root.position.set(Math.sin(root.rotation.z) * 0.7 * sizeM, 0, Math.cos(root.rotation.z) * 0.7 * sizeM);
                        group.add(root);
                    }
                    const leafGeom = new THREE.BoxGeometry(0.3 * sizeM, 1.5 * sizeM, 0.1 * sizeM);
                    const leafArm1 = new THREE.Mesh(leafGeom, accentMaterial);
                    leafArm1.position.set(1.0 * sizeM, 1.5 * sizeM, 0); leafArm1.rotation.z = -Math.PI / 4;
                    const leafArm2 = leafArm1.clone(); leafArm2.position.x *= -1; leafArm2.rotation.z *= -1;
                    group.add(leafArm1, leafArm2);
                    break;

                case 'bipedal':
                    body = new THREE.Mesh(new THREE.BoxGeometry(1.2 * sizeM, 2.0 * sizeM, 0.8 * sizeM), material);
                    body.position.y = 1.0 * sizeM;
                    head = new THREE.Mesh(new THREE.SphereGeometry(0.6 * sizeM, 16, 16), material);
                    head.position.y = 2.3 * sizeM;
                    group.add(body, head);
                    const bipedLegGeom = new THREE.CylinderGeometry(0.3 * sizeM, 0.4 * sizeM, 1.2 * sizeM, 8);
                    const bLeg1 = new THREE.Mesh(bipedLegGeom, material); bLeg1.position.set(0.4 * sizeM, -0.2 * sizeM, 0);
                    const bLeg2 = bLeg1.clone(); bLeg2.position.x *= -1;
                    group.add(bLeg1, bLeg2);
                    const armGeom = new THREE.CapsuleGeometry(0.25 * sizeM, 1.0 * sizeM, 8, 8);
                    const arm1 = new THREE.Mesh(armGeom, material);
                    arm1.position.set(0.9 * sizeM, 1.5 * sizeM, 0); arm1.rotation.z = -Math.PI / 6;
                    const arm2 = arm1.clone(); arm2.position.x *= -1; arm2.rotation.z *= -1;
                    group.add(arm1, arm2);
                    const hornGeom = new THREE.ConeGeometry(0.2 * sizeM, 0.8 * sizeM, 12);
                    const hornMat = new THREE.MeshPhongMaterial({ color: G_LIGHT_GREY });
                    const horn1 = new THREE.Mesh(hornGeom, hornMat);
                    horn1.position.set(-0.35 * sizeM, 2.7 * sizeM, 0.1 * sizeM); horn1.rotation.x = Math.PI / 2; horn1.rotation.y = Math.PI / 8;
                    const horn2 = horn1.clone(); horn2.position.x *= -1; horn2.rotation.y *= -1;
                    group.add(horn1, horn2);
                    break;
            }
            if (head) {
                let eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.08 * sizeM, 8, 8), eyeMaterial);
                let eye2 = eye1.clone();
                eye1.position.set(-0.18 * sizeM, 0.12 * sizeM, 0.45 * sizeM);
                eye2.position.set(0.18 * sizeM, 0.12 * sizeM, 0.45 * sizeM);
                head.add(eye1, eye2);
            }
            group.castShadow = true;
            group.receiveShadow = true;
            return group;
        }

        function createBuildingModel(type) {
            let model;
            const material = new THREE.MeshPhongMaterial({ color: G_MEDIUM_GREY });
            switch(type) {
                case "Tent":
                    model = new THREE.Group();
                    let tentBody = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 0.1, 2.5, 4), material);
                    tentBody.rotation.y = Math.PI / 4; tentBody.position.y = 1.25;
                    model.add(tentBody);
                    break;
                case "Campfire":
                    model = new THREE.Group();
                    let logs = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8), new THREE.MeshPhongMaterial({color: G_DARK_GREY}));
                    logs.position.y = 0.2; logs.rotation.x = Math.PI / 2;
                    let logs2 = logs.clone(); logs2.rotation.y = Math.PI / 2;
                    let stoneRing = new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.2, 8, 16), new THREE.MeshPhongMaterial({color: G_MEDIUM_GREY}));
                    stoneRing.rotation.x = Math.PI / 2; stoneRing.position.y = 0.1;
                    model.add(logs, logs2, stoneRing);
                    let fireCore = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({color: 0xFF5500, transparent: true, opacity: 0.8}));
                    fireCore.position.y = 0.5;
                    model.add(fireCore);
                    break;
                case "Small House":
                    model = new THREE.Group();
                    const houseBody = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 6), new THREE.MeshPhongMaterial({color: G_LIGHT_GREY}));
                    houseBody.position.y = 2;
                    const roof = new THREE.Mesh(new THREE.ConeGeometry(4.5, 3, 4), new THREE.MeshPhongMaterial({color: G_DARK_GREY}));
                    roof.position.y = 5.5; roof.rotation.y = Math.PI / 4;
                    const door = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 0.1), new THREE.MeshPhongMaterial({color: G_BLACK}));
                    door.position.set(0, 1.25, 3.05);
                    const windowGeom = new THREE.BoxGeometry(1.5, 1.5, 0.1);
                    const windowMat = new THREE.MeshPhongMaterial({color: G_MEDIUM_GREY});
                    const window1 = new THREE.Mesh(windowGeom, windowMat); window1.position.set(2.5, 2.5, 3.05);
                    const window2 = window1.clone(); window2.position.x = -2.5;
                    model.add(houseBody, roof, door, window1, window2);
                    break;
                case "Stone Wall":
                    model = new THREE.Group();
                    const segmentGeom = new THREE.BoxGeometry(1, 2, 0.5);
                    const wallMat = new THREE.MeshPhongMaterial({color: G_LIGHT_GREY});
                    for(let i = 0; i < 3; i++) {
                        let segment = new THREE.Mesh(segmentGeom, wallMat);
                        segment.position.set((i-1)*1.05, 1, 0);
                        model.add(segment);
                    }
                    break;
                case "Wooden Fence":
                    model = new THREE.Group();
                    const postGeom = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
                    const railGeom = new THREE.BoxGeometry(3.5, 0.1, 0.1);
                    const fenceMat = new THREE.MeshPhongMaterial({color: G_DARK_GREY});
                    const post1 = new THREE.Mesh(postGeom, fenceMat); post1.position.set(1.75, 0.75, 0);
                    const post2 = post1.clone(); post2.position.x = -1.75;
                    const rail1 = new THREE.Mesh(railGeom, fenceMat); rail1.position.y = 0.5;
                    const rail2 = rail1.clone(); rail2.position.y = 1.2;
                    model.add(post1, post2, rail1, rail2);
                    break;
                default:
                    model = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 2), new THREE.MeshPhongMaterial({color: G_MEDIUM_GREY}));
                    model.position.y = 1;
                    break;
            }
            if (model) {
                 model.castShadow = true;
                 model.receiveShadow = true;
            }
            return model;
        }

        function createTreeModel() {
            const tree = new THREE.Group();
            const trunkHeight = getRandomFloat(3, 5);
            const trunkRadius = getRandomFloat(0.3, 0.5);
            const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius, trunkHeight, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: G_DARK_GREY });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = trunkHeight / 2;
            tree.add(trunk);

            const leavesMaterial = new THREE.MeshPhongMaterial({ color: G_MEDIUM_GREY });
            const numLeavesLayers = getRandomInt(2, 3);
            for (let i = 0; i < numLeavesLayers; i++) {
                const leafSize = getRandomFloat(1.5, 2.5) * (1 - i * 0.2);
                const leafGeometry = new THREE.SphereGeometry(leafSize, 16, 12);
                const leaves = new THREE.Mesh(leafGeometry, leavesMaterial);
                leaves.position.y = trunkHeight + (i * (leafSize * 0.4 + 0.5));
                leaves.position.x = getRandomFloat(-0.5, 0.5);
                leaves.position.z = getRandomFloat(-0.5, 0.5);
                tree.add(leaves);
            }
            tree.castShadow = true;
            tree.receiveShadow = true;
            tree.userData.gameType = 'tree';
            return tree;
        }

        function createStoneModel() {
            const stone = new THREE.Group();
            const stoneSize = getRandomFloat(1, 2);
            const numChunks = getRandomInt(1, 3);
            const stoneMaterial = new THREE.MeshPhongMaterial({ color: G_LIGHT_GREY });

            for (let i = 0; i < numChunks; i++) {
                const chunkGeometry = new THREE.IcosahedronGeometry(stoneSize * getRandomFloat(0.5, 1.0), 0);
                const chunk = new THREE.Mesh(chunkGeometry, stoneMaterial);
                chunk.position.set(getRandomFloat(-stoneSize * 0.3, stoneSize * 0.3), getRandomFloat(0, stoneSize * 0.2), getRandomFloat(-stoneSize * 0.3, stoneSize * 0.3));
                chunk.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                stone.add(chunk);
            }
            stone.castShadow = true;
            stone.receiveShadow = true;
            stone.userData.gameType = 'stone';
            return stone;
        }

        function createTraderModel() {
            const traderGroup = new THREE.Group();
            const woodMaterial = new THREE.MeshPhongMaterial({ color: G_DARK_GREY });
            const roofMaterial = new THREE.MeshPhongMaterial({ color: G_MEDIUM_GREY });

            const base = new THREE.Mesh(new THREE.BoxGeometry(6, 0.5, 4), woodMaterial);
            base.position.y = 0.25;
            traderGroup.add(base);

            const postGeometry = new THREE.CylinderGeometry(0.2, 0.2, 3, 8);
            const post1 = new THREE.Mesh(postGeometry, woodMaterial); post1.position.set(2.5, 2, 1.5);
            const post2 = post1.clone(); post2.position.x = -2.5;
            const post3 = post1.clone(); post3.position.z = -1.5;
            const post4 = post3.clone(); post4.position.x = -2.5;
            traderGroup.add(post1, post2, post3, post4);

            const roof = new THREE.Mesh(new THREE.ConeGeometry(4, 2, 4), roofMaterial);
            roof.position.y = 3.5; roof.rotation.y = Math.PI / 4;
            traderGroup.add(roof);

            const counter = new THREE.Mesh(new THREE.BoxGeometry(5, 0.8, 1.5), woodMaterial);
            counter.position.set(0, 1, 1.5);
            traderGroup.add(counter);

            traderGroup.castShadow = true;
            traderGroup.receiveShadow = true;
            traderGroup.userData.gameType = 'trader';
            return traderGroup;
        }

        function generateCreatureData(typeDef) {
            const stats = {
                strength: getRandomInt(5, 15), stamina: getRandomInt(50, 100),
                luck: getRandomInt(1, 10), defense: getRandomInt(3, 12), hp: getRandomInt(80, 150)
            };
            const skills = [`Attack`, `Defend`];
            if (typeDef.modelType === 'flying') skills.push('Gust');
            if (typeDef.modelType === 'plantoid') skills.push('Heal');
            if (typeDef.modelType === 'quadruped' || typeDef.modelType === 'bipedal') skills.push('Charge');
            return {
                id: THREE.MathUtils.generateUUID(), type: typeDef.name, modelType: typeDef.modelType,
                baseColor: typeDef.baseColor, size: typeDef.size, stats: stats,
                currentHp: stats.hp, skills: skills, affinity: typeDef.likesBerry ? 'likes_berry' : 'dislikes_berry',
                isTamed: false, spawnTime: Date.now()
            };
        }

        // --- Game Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(G_DARK_GREY);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 120, 80); // Initial camera position (will follow player)
            camera.lookAt(0, 0, 0); // Initially looks at origin

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const ambientLight = new THREE.AmbientLight(G_MEDIUM_GREY, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(G_WHITE, 1.5);
            directionalLight.position.set(100, 200, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -MAP_SIZE / 2; directionalLight.shadow.camera.right = MAP_SIZE / 2;
            directionalLight.shadow.camera.top = MAP_SIZE / 2; directionalLight.shadow.camera.bottom = -MAP_SIZE / 2;
            scene.add(directionalLight);

            const playerGeometry = new THREE.CylinderGeometry(0.7, 0.7, 2, 16);
            const playerMaterial = new THREE.MeshPhongMaterial({ color: G_PLAYER_ORANGE });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(playerInventory.playerPos.x, playerInventory.playerPos.y, playerInventory.playerPos.z); // Set initial position from saved data
            player.castShadow = true;
            player.receiveShadow = true;
            scene.add(player);

            // Camera setup relative to player (follow offset)
            const cameraOffset = new THREE.Vector3(0, 120, 80); // Relative offset from player
            camera.position.copy(player.position).add(cameraOffset);
            camera.lookAt(player.position);

            const mapGridSize = 25;
            const blockSize = MAP_SIZE / mapGridSize;
            for (let x = 0; x < mapGridSize; x++) {
                for (let z = 0; z < mapGridSize; z++) {
                    const blockX = (x - mapGridSize / 2 + 0.5) * blockSize;
                    const blockZ = (z - mapGridSize / 2 + 0.5) * blockSize;
                    let objectMesh = null;
                    let blockColor;
                    let blockY = 0;

                    const isRoadX = (x % 5 === 2);
                    const isRoadZ = (z % 5 === 2);

                    if (isRoadX || isRoadZ) {
                        blockColor = G_MEDIUM_GREY;
                        blockY = 0.05;
                        objectMesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(blockSize, blockSize),
                            new THREE.MeshPhongMaterial({ color: blockColor, side: THREE.DoubleSide })
                        );
                        objectMesh.rotation.x = -Math.PI / 2;
                        objectMesh.position.set(blockX, blockY, blockZ);
                    } else if (Math.random() < 0.15) {
                        blockColor = G_LIGHT_GREY;
                        blockY = -0.5;
                        objectMesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(blockSize, blockSize),
                            new THREE.MeshPhongMaterial({ color: blockColor, side: THREE.DoubleSide })
                        );
                        objectMesh.rotation.x = -Math.PI / 2;
                        objectMesh.position.set(blockX, blockY, blockZ);
                    } else if (Math.random() < 0.25) {
                        blockColor = new THREE.Color(G_MEDIUM_GREY).offsetHSL(0, 0, getRandomFloat(-0.1, 0.1));
                        blockY = getRandomFloat(3, 10);
                        objectMesh = new THREE.Mesh(
                            new THREE.BoxGeometry(blockSize * 0.8, blockY, blockSize * 0.8),
                            new THREE.MeshPhongMaterial({ color: blockColor })
                        );
                        objectMesh.position.set(blockX, blockY / 2, blockZ);
                        objectMesh.castShadow = true;
                    } else {
                        blockColor = G_DARK_GREY;
                        blockY = 0.1;
                        objectMesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(blockSize, blockSize),
                            new THREE.MeshPhongMaterial({ color: blockColor, side: THREE.DoubleSide })
                        );
                        objectMesh.rotation.x = -Math.PI / 2;
                        objectMesh.position.set(blockX, blockY, blockZ);
                    }

                    if (objectMesh) {
                        objectMesh.receiveShadow = true;
                        scene.add(objectMesh);
                    }
                }
            }

            creatureMiniScene = new THREE.Scene();
            creatureMiniCamera = new THREE.PerspectiveCamera(75, creature3DViewDiv.clientWidth / creature3DViewDiv.clientHeight, 0.1, 100);
            creatureMiniCamera.position.set(0, 1, 3);
            creatureMiniCamera.lookAt(0, 0.5, 0);

            creatureMiniRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            creatureMiniRenderer.setSize(creature3DViewDiv.clientWidth, creature3DViewDiv.clientHeight);
            creatureMiniRenderer.setClearColor(0x000000, 0);
            creature3DViewDiv.appendChild(creatureMiniRenderer.domElement);

            const miniLight = new THREE.DirectionalLight(G_WHITE, 1.5);
            miniLight.position.set(5, 5, 5);
            creatureMiniScene.add(miniLight);
            creatureMiniScene.add(new THREE.AmbientLight(G_MEDIUM_GREY, 1));

            loadGame();

            spawnInitialTrees();
            spawnInitialStones();
            renderPlacedBuildings();

            traderModel = createTraderModel();
            traderModel.position.set(MAP_SIZE / 4, 0.25, MAP_SIZE / 4);
            scene.add(traderModel);

            setupEventListeners();
            startGPSWatch();
            setInterval(saveGame, 10000);
            animate();
        }

        // --- Spawning and Despawning ---

        function spawnWildCreatures(count = 5) {
            wildCreatureMeshes.forEach(mesh => {
                scene.remove(mesh);
                mesh.traverse(child => {
                    if (child.isMesh) { child.geometry.dispose(); if (Array.isArray(child.material)) { child.material.forEach(material => material.dispose()); } else { child.material.dispose(); } }
                });
            });
            wildCreatureMeshes = [];

            for (let i = 0; i < count; i++) {
                const typeDef = CREATURE_TYPES[getRandomInt(0, CREATURE_TYPES.length - 1)];
                const creatureData = generateCreatureData(typeDef);
                const creatureModel = createCreatureModel(typeDef);
                // Spawn creatures around player's current position
                const angle = Math.random() * Math.PI * 2;
                const distance = getRandomInt(10, CREATURE_SPAWN_RADIUS);
                const spawnX = player.position.x + distance * Math.cos(angle);
                const spawnZ = player.position.z + distance * Math.sin(angle);
                creatureModel.position.x = spawnX;
                creatureModel.position.z = spawnZ;
                creatureModel.position.y = 0.5;
                creatureModel.userData.gameType = 'creature';
                creatureModel.userData.data = creatureData;
                scene.add(creatureModel);
                wildCreatureMeshes.push(creatureModel);
            }
            showMessage(`New creatures detected!`, 2000);
        }

        function spawnInitialTrees() {
            for (let i = 0; i < INITIAL_TREES; i++) {
                const treeModel = createTreeModel();
                treeModel.position.x = getRandomInt(-MAP_SIZE / 2 + 5, MAP_SIZE / 2 - 5);
                treeModel.position.z = getRandomInt(-MAP_SIZE / 2 + 5, MAP_SIZE / 2 - 5);
                treeModel.position.y = 0;
                scene.add(treeModel);
                activeTreeMeshes.push(treeModel);
            }
        }

        function spawnInitialStones() {
            for (let i = 0; i < INITIAL_STONES; i++) {
                const stoneModel = createStoneModel();
                stoneModel.position.x = getRandomInt(-MAP_SIZE / 2 + 5, MAP_SIZE / 2 - 5);
                stoneModel.position.z = getRandomInt(-MAP_SIZE / 2 + 5, MAP_SIZE / 2 - 5);
                stoneModel.position.y = 0;
                scene.add(stoneModel);
                activeStoneMeshes.push(stoneModel);
            }
        }

        function renderPlacedBuildings() {
            activePlacedBuildingMeshes.forEach(mesh => scene.remove(mesh));
            activePlacedBuildingMeshes = [];
            worldObjects.placedBuildings.forEach(bData => {
                const buildingModel = createBuildingModel(bData.type);
                buildingModel.position.set(bData.position.x, bData.position.y, bData.position.z);
                buildingModel.userData.gameType = 'building';
                buildingModel.userData.data = bData;
                scene.add(buildingModel);
                activePlacedBuildingMeshes.push(buildingModel);
            });
        }

        // --- Game Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const currentTime = Date.now();

            // Player Stats Update
            const stats = playerInventory.stats;
            stats.hunger = Math.max(0, stats.hunger - 0.01); // Hunger decay over time
            stats.thirst = Math.max(0, stats.thirst - 0.015); // Thirst decay over time
            
            if (stats.hunger <= 0 || stats.thirst <= 0) {
                stats.health = Math.max(0, stats.health - 0.05); // Health decay if hungry/thirsty
                if (stats.health <= 0) {
                    showMessage("You fainted! Game Over (auto-healing to 50 HP).", 3000);
                    stats.health = 50; // Simple respawn
                    stats.hunger = 50;
                    stats.thirst = 50;
                }
            }
            updatePlayerHud();

            // Player Movement
            if (moveDirection.lengthSq() > 0 && currentGameState === GAME_STATE.EXPLORE) {
                // Determine player's forward direction based on camera rotation (if camera orbits player)
                // Or simply move relative to world axes if a simple top-down joystick
                // For a simple top-down joystick, moveDirection is already global XZ
                player.position.addScaledVector(moveDirection, PLAYER_MOVE_SPEED);
                
                // Clamp player position within map boundaries
                player.position.x = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, player.position.x));
                player.position.z = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, player.position.z));

                // Make player object face direction of movement (relative to world XZ plane)
                const angle = Math.atan2(moveDirection.x, moveDirection.z); // Z for forward, X for sideways
                player.rotation.y = angle;

                // Update camera to follow player
                const cameraOffset = new THREE.Vector3(0, 120, 80); // Keep original camera offset
                camera.position.copy(player.position).add(cameraOffset);
                camera.lookAt(player.position); // Always look at current player position

                // Update playerPos for saving
                playerInventory.playerPos.x = player.position.x;
                playerInventory.playerPos.y = player.position.y;
                playerInventory.playerPos.z = player.position.z;
            }

            // Creature lifespan management
            wildCreatureMeshes = wildCreatureMeshes.filter(creatureMesh => {
                const data = creatureMesh.userData.data;
                const elapsedSeconds = (currentTime - data.spawnTime) / 1000;
                if (elapsedSeconds > SPAWN_LIFESPAN_SECONDS) {
                    scene.remove(creatureMesh);
                    creatureMesh.traverse(child => {
                        if (child.isMesh) { child.geometry.dispose(); if (Array.isArray(child.material)) { child.material.forEach(material => material.dispose()); } else { child.material.dispose(); } }
                    });
                    return false;
                }
                return true;
            });

            // Handle active crafts completion
            activeCrafts = activeCrafts.filter(craft => {
                const timeElapsed = (currentTime - craft.startTime) / 1000;
                if (timeElapsed >= craft.duration) {
                    playerInventory.items[craft.kitName] = (playerInventory.items[craft.kitName] || 0) + 1;
                    showMessage(`Crafted ${craft.name}! Added to your inventory.`, 2000);
                    updateUI();
                    return false;
                }
                return true;
            });
            updateActiveCraftsDisplay();

            // Update placement ghost mesh position and color
            if (currentGameState === GAME_STATE.PLACEMENT && placementGhostMesh) {
                raycaster.setFromCamera(mouse, camera);
                // Intersect with ground planes only
                const groundIntersects = raycaster.intersectObjects(scene.children.filter(c => c instanceof THREE.Mesh && c.geometry instanceof THREE.PlaneGeometry), true);
                
                let isValidPlacement = false;
                if (groundIntersects.length > 0) {
                    placementGroundIntersection = groundIntersects[0].point;
                    
                    const snapSize = 5;
                    placementGroundIntersection.x = Math.round(placementGroundIntersection.x / snapSize) * snapSize;
                    placementGroundIntersection.z = Math.round(placementGroundIntersection.z / snapSize) * snapSize;

                    // Check bounds & proximity to other objects
                    const playerProximityBuffer = 5;
                    const tooCloseToPlayer = placementGroundIntersection.distanceTo(player.position) < playerProximityBuffer;

                    if (!tooCloseToPlayer && Math.abs(placementGroundIntersection.x) < MAP_SIZE / 2 - 5 && Math.abs(placementGroundIntersection.z) < MAP_SIZE / 2 - 5) {
                        const checkRadius = 5;
                        isValidPlacement = true;
                        
                        const objectsToCheck = [...activePlacedBuildingMeshes, ...activeTreeMeshes, ...activeStoneMeshes];
                        if (traderModel) objectsToCheck.push(traderModel);

                        for (const obj of objectsToCheck) {
                            let effectiveRadius = checkRadius;
                            if (obj.userData.gameType === 'building') effectiveRadius = 10;
                            if (obj.userData.gameType === 'tree') effectiveRadius = 7;
                            if (obj.userData.gameType === 'stone') effectiveRadius = 3;

                            if (placementGroundIntersection.distanceTo(obj.position) < effectiveRadius) {
                                isValidPlacement = false;
                                break;
                            }
                        }
                    }

                    placementGhostMesh.position.copy(placementGroundIntersection);
                    if (placementItemData.name === "Campfire") {
                         placementGhostMesh.position.y = 0.3;
                    } else if (placementItemData.name === "Small House") {
                        placementGhostMesh.position.y = 0;
                    } else if (placementItemData.name === "Stone Wall" || placementItemData.name === "Wooden Fence") {
                        placementGhostMesh.position.y = 0;
                    } else {
                        placementGhostMesh.position.y = 0.05;
                    }
                } else {
                    placementGhostMesh.position.y = -1000; // Move off screen if no ground intersection
                    isValidPlacement = false;
                }

                placementGhostMesh.material.color.set(isValidPlacement ? 0x00FF00 : 0xFF0000); // Green/Red feedback
                placementGhostMesh.material.opacity = 0.5;
                confirmPlacementButton.disabled = !isValidPlacement;
            }

            renderer.render(scene, camera);

            if (currentGameState === GAME_STATE.CREATURE_INTERACT && currentCreature3DModel) {
                currentCreature3DModel.rotation.y += 0.01;
                creatureMiniRenderer.render(creatureMiniScene, creatureMiniCamera);
            }
        }

        // --- Input Handling ---
        let isDraggingCamera = false; // Separate flag for camera drag
        let previousMouseX, previousMouseY;

        function onPointerDown(event) {
            event.preventDefault(); // Prevent default touch actions (like scrolling, zooming)
            const targetElement = event.target;
            if (targetElement.closest('#joystickBase')) {
                // Joystick will handle its own pointerdown
                return;
            }

            // Only allow camera drag if not in a UI panel and not placement mode
            if (currentGameState === GAME_STATE.EXPLORE) {
                isDraggingCamera = true;
                previousMouseX = event.clientX || event.touches[0].clientX;
                previousMouseY = event.clientY || event.touches[0].clientY;
            }
        }

        function onPointerMove(event) {
            event.preventDefault(); // Prevent default
            const currentX = event.clientX || event.touches[0].clientX;
            const currentY = event.clientY || event.touches[0].clientY;
            mouse.x = (currentX / window.innerWidth) * 2 - 1;
            mouse.y = -(currentY / window.innerHeight) * 2 + 1; // Update global mouse coords for raycaster

            if (isDraggingCamera && currentGameState === GAME_STATE.EXPLORE) {
                const deltaX = currentX - previousMouseX;
                const deltaY = currentY - previousMouseY;
                const rotationSpeed = 0.005;
                const verticalPanSpeed = 0.5;

                const relativeCameraPos = camera.position.clone().sub(player.position);
                const angleX = deltaX * rotationSpeed;
                const currentAngle = Math.atan2(relativeCameraPos.x, relativeCameraPos.z);
                const newAngle = currentAngle - angleX;
                const distanceXY = Math.sqrt(relativeCameraPos.x * relativeCameraPos.x + relativeCameraPos.z * relativeCameraPos.z);
                
                relativeCameraPos.x = distanceXY * Math.sin(newAngle);
                relativeCameraPos.z = distanceXY * Math.cos(newAngle);

                relativeCameraPos.y = Math.max(20, Math.min(200, relativeCameraPos.y + deltaY * verticalPanSpeed));

                camera.position.copy(player.position).add(relativeCameraPos);
                camera.lookAt(player.position);
                
                previousMouseX = currentX;
                previousMouseY = currentY;
            }
        }

        function onPointerUp(event) {
            event.preventDefault(); // Prevent default
            isDraggingCamera = false;
        }

        function onCanvasClick(event) {
            // Check if it was a drag or a click originating from UI
            const currentX = event.clientX || (event.changedTouches && event.changedTouches[0] ? event.changedTouches[0].clientX : 0);
            const currentY = event.clientY || (event.changedTouches && event.changedTouches[0] ? event.changedTouches[0].clientY : 0);
            if (isDraggingCamera && (Math.abs(currentX - previousMouseX) > 5 || Math.abs(currentY - previousMouseY) > 5)) {
                return;
            }
            if (event.target.closest('.ui-panel') || event.target.closest('#topBar') || event.target.closest('#joystickBase') || event.target.closest('#activeCrafts')) {
                // Click was on a UI element, not the game world
                return;
            }

            if (currentGameState === GAME_STATE.TAMING) {
                handleTamingClick();
                return;
            }

            if (currentGameState === GAME_STATE.PLACEMENT) {
                if (placementGhostMesh && confirmPlacementButton.disabled === false) {
                    confirmPlacement();
                } else {
                    showMessage("Cannot place here. Move ghost to a valid spot.", 2000);
                }
                return;
            }

            if (currentGameState === GAME_STATE.EXPLORE) {
                mouse.x = (currentX / window.innerWidth) * 2 - 1;
                mouse.y = -(currentY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const allWorldGroups = [...wildCreatureMeshes, ...activeTreeMeshes, ...activeStoneMeshes, ...activePlacedBuildingMeshes];
                if (traderModel) allWorldGroups.push(traderModel);
                allWorldGroups.push(player); // Player can be clicked too
                
                const intersects = raycaster.intersectObjects(allWorldGroups, true);

                if (intersects.length > 0) {
                    const clickedChildMesh = intersects[0].object;
                    let rootInteractiveObject = clickedChildMesh;
                    while (rootInteractiveObject && !rootInteractiveObject.userData.gameType && rootInteractiveObject.parent) {
                        rootInteractiveObject = rootInteractiveObject.parent;
                    }

                    if (rootInteractiveObject && rootInteractiveObject.userData.gameType) {
                        switch (rootInteractiveObject.userData.gameType) {
                            case 'creature':
                                selectedCreature = rootInteractiveObject.userData.data;
                                showCreaturePanel(selectedCreature);
                                break;
                            case 'tree':
                                if (playerInventory.items["Axe"] > 0) {
                                    chopTree(rootInteractiveObject);
                                } else {
                                    showMessage("Need an Axe to chop trees! Check the Trader.", 2500);
                                }
                                break;
                            case 'stone':
                                if (playerInventory.items["Pickaxe"] > 0) {
                                    mineStone(rootInteractiveObject);
                                } else {
                                    showMessage("Need a Pickaxe to mine stones! Check the Trader.", 2500);
                                }
                                break;
                            case 'building':
                                showMessage(`This is a ${rootInteractiveObject.userData.data.type}.`, 1500);
                                break;
                            case 'trader':
                                showMessage("Welcome to the Trader! Buy and sell here.", 1500);
                                showTraderPanel();
                                break;
                            case 'player':
                                showMessage("That's you!", 1000);
                                break;
                            default:
                                break;
                        }
                    }
                } else {
                    // Clicked on empty ground
                    showMessage("Nothing here to interact with.", 1000); // Optional feedback
                }
            }
        }

        // Joystick Control Functions
        function onJoystickDown(event) {
            event.preventDefault();
            joystickActive = true;
            joystickHandle.classList.add('active');
            // Initial position based on touch/mouse
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const clientX = event.clientX || event.touches[0].clientX;
            const clientY = event.clientY || event.touches[0].clientY;
            
            let deltaX = clientX - centerX;
            let deltaY = clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (distance > joystickRadius) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = joystickRadius * Math.cos(angle);
                deltaY = joystickRadius * Math.sin(angle);
            }
            joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            moveDirection.set(deltaX, 0, deltaY).normalize();

            if (currentGameState !== GAME_STATE.EXPLORE) { // Stop movement if UI is open
                moveDirection.set(0,0,0);
            }
        }

        function onJoystickMove(event) {
            event.preventDefault();
            if (!joystickActive) return;

            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            const clientX = event.clientX || event.touches[0].clientX;
            const clientY = event.clientY || event.touches[0].clientY;

            let deltaX = clientX - centerX;
            let deltaY = clientY - centerY;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            if (distance > joystickRadius) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = joystickRadius * Math.cos(angle);
                deltaY = joystickRadius * Math.sin(angle);
            }

            joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

            moveDirection.set(deltaX, 0, deltaY).normalize();

            if (currentGameState !== GAME_STATE.EXPLORE) {
                moveDirection.set(0,0,0);
            }
        }

        function onJoystickUp(event) {
            event.preventDefault();
            joystickActive = false;
            joystickHandle.classList.remove('active');
            joystickHandle.style.transform = `translate(0, 0)`; // Reset handle to center
            moveDirection.set(0, 0, 0); // Stop player movement
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointermove', onPointerMove);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointerleave', onPointerUp);
            canvas.addEventListener('click', onCanvasClick);

            // Joystick event listeners (use pointer events for universal touch/mouse)
            joystickBase.addEventListener('pointerdown', onJoystickDown);
            joystickBase.addEventListener('pointermove', onJoystickMove);
            joystickBase.addEventListener('pointerup', onJoystickUp);
            joystickBase.addEventListener('pointerleave', onJoystickUp);

            document.getElementById('mainMenuButton').addEventListener('click', () => toggleUIPanel(mainMenuPanel, GAME_STATE.MENU));
            document.getElementById('closeMainMenuButton').addEventListener('click', () => toggleUIPanel(mainMenuPanel, GAME_STATE.EXPLORE));

            document.getElementById('inventoryButton').addEventListener('click', () => { toggleUIPanel(inventoryPanel, GAME_STATE.INVENTORY); updateInventoryList(); });
            document.getElementById('traderButton').addEventListener('click', () => { toggleUIPanel(traderPanel, GAME_STATE.TRADER); updateTraderLists(); });
            document.getElementById('craftingButton').addEventListener('click', () => { toggleUIPanel(craftingPanel, GAME_STATE.CRAFTING); updateCraftingRecipes(); });
            document.getElementById('arenaButton').addEventListener('click', () => { toggleUIPanel(arenaPanel, GAME_STATE.ARENA); updateArenaCreatureList(); arenaBattleLogElem.innerHTML = ''; });

            document.getElementById('closeCreaturePanelButton').addEventListener('click', () => toggleUIPanel(creaturePanel, GAME_STATE.EXPLORE));
            document.getElementById('feedBerryButton').addEventListener('click', feedBerryToCreature);
            document.getElementById('tameButton').addEventListener('click', startTamingMiniGame);
            document.getElementById('tameCancelButton').addEventListener('click', cancelTaming);

            document.getElementById('closeInventoryButton').addEventListener('click', () => toggleUIPanel(inventoryPanel, GAME_STATE.EXPLORE));
            document.getElementById('closeTraderButton').addEventListener('click', () => toggleUIPanel(traderPanel, GAME_STATE.EXPLORE));
            document.getElementById('closeCraftingButton').addEventListener('click', () => toggleUIPanel(craftingPanel, GAME_STATE.EXPLORE));
            document.getElementById('closeArenaButton').addEventListener('click', () => toggleUIPanel(arenaPanel, GAME_STATE.EXPLORE));
            document.getElementById('arenaNextOpponentButton').addEventListener('click', () => {
                if (playerInventory.creatures.length > 0) {
                    const randomTamedCreature = playerInventory.creatures[getRandomInt(0, playerInventory.creatures.length - 1)];
                    if (randomTamedCreature.currentHp > 0) {
                        startArenaBattle(randomTamedCreature);
                    } else {
                        showMessage("Your selected creature has fainted! Choose another or heal it.", 2500);
                        updateArenaCreatureList();
                    }
                } else {
                    showMessage("You need to tame creatures to battle in the Arena!", 2500);
                }
            });

            confirmPlacementButton.addEventListener('click', confirmPlacement);
            cancelPlacementButton.addEventListener('click', exitPlacementMode);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (creatureMiniRenderer && creature3DViewDiv.clientWidth > 0 && creature3DViewDiv.clientHeight > 0) {
                 creatureMiniCamera.aspect = creature3DViewDiv.clientWidth / creature3DViewDiv.clientHeight;
                 creatureMiniCamera.updateProjectionMatrix();
                 creatureMiniRenderer.setSize(creature3DViewDiv.clientWidth, creature3DViewDiv.clientHeight);
            }
        }

        // --- UI Update Functions ---
        function updateUI() {
            playerGoldElem.textContent = playerInventory.gold; // Update gold in inventory/trader panels
            traderGoldElem.textContent = playerInventory.gold;
            updateInventoryList();
            updateTraderLists();
            updateCraftingRecipes();
            updateArenaCreatureList();
            updateActiveCraftsDisplay();
            updatePlayerHud(); // Update new player HUD
        }

        function updatePlayerHud() {
            playerHpElem.textContent = `${playerInventory.stats.health.toFixed(0)}/${playerInventory.stats.maxHealth}`;
            playerXpElem.textContent = playerInventory.stats.xp.toFixed(0);
            playerHungerElem.textContent = `${playerInventory.stats.hunger.toFixed(0)}/${playerInventory.stats.maxHunger}`;
            playerThirstElem.textContent = `${playerInventory.stats.thirst.toFixed(0)}/${playerInventory.stats.maxThirst}`;
            playerGoldHudElem.textContent = playerInventory.gold.toFixed(0);
        }

        function updateActiveCraftsDisplay() {
            activeCraftsList.innerHTML = '';
            if (activeCrafts.length === 0) {
                const li = document.createElement('li');
                li.textContent = "No active crafts.";
                activeCraftsList.appendChild(li);
                return;
            }

            const currentTime = Date.now();
            activeCrafts.forEach(craft => {
                const timeRemaining = Math.max(0, craft.duration - ((currentTime - craft.startTime) / 1000));
                const li = document.createElement('li');
                li.textContent = `${craft.name}: ${timeRemaining.toFixed(0)}s remaining`;
                activeCraftsList.appendChild(li);
            });
        }

        function showCreaturePanel(creatureData) {
            if (currentCreature3DModel) {
                creatureMiniScene.remove(currentCreature3DModel);
                currentCreature3DModel.traverse(child => {
                    if (child.isMesh) { child.geometry.dispose(); if (Array.isArray(child.material)) { child.material.forEach(material => material.dispose()); } else { child.material.dispose(); } }
                });
            }
            const typeDef = CREATURE_TYPES.find(type => type.name === creatureData.type);
            currentCreature3DModel = createCreatureModel(typeDef, true);
            creatureMiniScene.add(currentCreature3DModel);
            creatureNameElem.textContent = creatureData.type;
            creatureStatsElem.innerHTML = `
                <div class="stat-item">Strength: ${creatureData.stats.strength}</div>
                <div class="stat-item">Stamina: ${creatureData.stats.stamina}</div>
                <div class="stat-item">Luck: ${creatureData.stats.luck}</div>
                <div class="stat-item">Defense: ${creatureData.stats.defense}</div>
                <div class="stat-item">HP: ${creatureData.currentHp}/${creatureData.stats.hp}</div>
                <div class="stat-item">Skills: ${creatureData.skills.join(', ')}</div>
            `;
            toggleUIPanel(creaturePanel, GAME_STATE.CREATURE_INTERACT);
        }

        function updateInventoryList() {
            inventoryListElem.innerHTML = '';
            let hasItemsOrCreatures = false;
            for (const item in playerInventory.items) {
                if (playerInventory.items[item] > 0) {
                    const itemDef = ITEM_DEFINITIONS[item];
                    const li = document.createElement('div');
                    li.classList.add('item-entry');
                    li.innerHTML = `<strong>${item}</strong> x ${playerInventory.items[item]} <br> <em>${itemDef.description}</em>`;
                    if (itemDef.type === "blueprint") {
                        const placeButton = document.createElement('button');
                        placeButton.classList.add('ui-button');
                        placeButton.textContent = `Place ${item.replace(' Kit', '')}`;
                        placeButton.style.marginLeft = '10px';
                        placeButton.onclick = () => enterPlacementMode(item.replace(' Kit', ''), item);
                        li.appendChild(placeButton);
                    }
                    inventoryListElem.appendChild(li);
                    hasItemsOrCreatures = true;
                }
            }
            if (playerInventory.creatures.length > 0) {
                const creatureHeader = document.createElement('h4');
                creatureHeader.textContent = "Tamed Creatures:";
                inventoryListElem.appendChild(creatureHeader);
                playerInventory.creatures.forEach(creature => {
                    const li = document.createElement('div');
                    li.classList.add('item-entry');
                    li.textContent = `${creature.type} (HP: ${creature.currentHp}/${creature.stats.hp}, Str: ${creature.stats.strength})`;
                    inventoryListElem.appendChild(li);
                    hasItemsOrCreatures = true;
                });
            }
            if (!hasItemsOrCreatures) {
                inventoryListElem.textContent = "Your inventory is empty.";
            }
        }

        function updateTraderLists() {
            buyItemsListElem.innerHTML = '';
            TRADER_ITEMS.forEach(item => {
                const itemDef = ITEM_DEFINITIONS[item.id];
                const li = document.createElement('div');
                li.classList.add('item-entry');
                li.innerHTML = `<strong>${item.id}</strong> - ${item.price} Gold (Stock: ${item.stock}) <br> <em>${itemDef.description}</em>`;
                const buyButton = document.createElement('button');
                buyButton.classList.add('ui-button');
                buyButton.textContent = 'Buy';
                buyButton.style.marginLeft = '10px';
                buyButton.onclick = () => buyItem(item.id, item.price);
                if (playerInventory.gold < item.price || item.stock <= 0) {
                    buyButton.disabled = true;
                }
                li.appendChild(buyButton);
                buyItemsListElem.appendChild(li);
            });

            sellItemsListElem.innerHTML = '';
            let canSellAnything = false;
            for (const item in playerInventory.items) {
                if (playerInventory.items[item] > 0 && ITEM_DEFINITIONS[item] && ITEM_DEFINITIONS[item].value > 0) {
                    const itemDef = ITEM_DEFINITIONS[item];
                    const li = document.createElement('div');
                    li.classList.add('item-entry');
                    li.innerHTML = `<strong>${item}</strong> x ${playerInventory.items[item]} - Sell for ${itemDef.value} Gold each`;
                    const sellButton = document.createElement('button');
                    sellButton.classList.add('ui-button');
                    sellButton.textContent = 'Sell One';
                    sellButton.style.marginLeft = '10px';
                    sellButton.onclick = () => sellItem(item, itemDef.value);
                    li.appendChild(sellButton);
                    canSellAnything = true;
                }
            }
            if (!canSellAnything) {
                sellItemsListElem.textContent = "Nothing to sell.";
            }
        }

        function updateCraftingRecipes() {
            craftingRecipesListElem.innerHTML = '';
            CRAFTING_RECIPES.forEach(recipe => {
                const li = document.createElement('div');
                li.classList.add('item-entry');
                let requiresText = Object.entries(recipe.requires).map(([item, amount]) => `${item} x${amount}`).join(', ');
                li.innerHTML = `<strong>${recipe.name}</strong><br>Requires: ${requiresText}`;
                if (ITEM_DEFINITIONS[recipe.result.kitName]) {
                     li.innerHTML += `<br>Craft Time: ${ITEM_DEFINITIONS[recipe.result.kitName].craftTime}s`;
                }

                const craftButton = document.createElement('button');
                craftButton.classList.add('ui-button');
                craftButton.textContent = `Craft ${recipe.name}`;
                craftButton.style.marginLeft = '10px';
                craftButton.onclick = () => craftItem(recipe);

                let canCraft = true;
                for (const reqItem in recipe.requires) {
                    if (playerInventory.items[reqItem] === undefined || playerInventory.items[reqItem] < recipe.requires[reqItem]) {
                        canCraft = false;
                        break;
                    }
                }
                if (!canCraft) {
                    craftButton.disabled = true;
                    craftButton.textContent = `Cannot Craft (Missing Resources)`;
                }
                li.appendChild(craftButton);
                craftingRecipesListElem.appendChild(li);
            });
        }

        // --- Game Actions ---

        function feedBerryToCreature() {
            if (!selectedCreature) return;
            if (playerInventory.items["Berry"] > 0) {
                playerInventory.items["Berry"]--;
                // Restore some hunger/thirst by consuming berry
                playerInventory.stats.hunger = Math.min(playerInventory.stats.maxHunger, playerInventory.stats.hunger + 10);
                playerInventory.stats.thirst = Math.min(playerInventory.stats.maxThirst, playerInventory.stats.thirst + 10);
                showMessage(`Used a Berry. You have ${playerInventory.items["Berry"]} left.`, 1500);
                if (selectedCreature.affinity === 'likes_berry') {
                    showMessage(`${selectedCreature.type} glows green! It likes the berry!`, 2500);
                } else {
                    showMessage(`${selectedCreature.type} glows red. It didn't like that berry.`, 2500);
                }
                updateUI();
            } else {
                showMessage("You don't have any Berries!", 2000);
            }
        }

        function startTamingMiniGame() {
            if (!selectedCreature) return;
            toggleUIPanel(creaturePanel, GAME_STATE.EXPLORE);
            toggleUIPanel(tamingPanel, GAME_STATE.TAMING);
            tamingBarProgress = 10;
            tameBar.style.width = `${tamingBarProgress}%`;
            tameBar.style.background = `linear-gradient(to right, ${G_DARK_GREY}, ${G_MEDIUM_GREY})`;
            showMessage("Tap the game screen fast to fill the bar!", 3000);
            clearInterval(tamingInterval);
            tamingInterval = setTimeout(() => {
                tamingInterval = setInterval(() => {
                    const decayRate = selectedCreature.affinity === 'likes_berry' ? 0.7 : 1.5;
                    tamingBarProgress = Math.max(0, tamingBarProgress - decayRate);
                    tameBar.style.width = `${tamingBarProgress}%`;
                    if (tamingBarProgress <= 0) {
                        cancelTaming();
                        showMessage(`The ${selectedCreature.type} got away!`, 2500);
                    }
                }, 100);
            }, 500);
        }

        function handleTamingClick() {
            if (currentGameState !== GAME_STATE.TAMING || !selectedCreature) return;
            const fillRate = selectedCreature.affinity === 'likes_berry' ? 5 : 3;
            tamingBarProgress = Math.min(100, tamingBarProgress + fillRate);
            tameBar.style.width = `${tamingBarProgress}%`;
            if (tamingBarProgress >= 100) {
                completeTaming();
            } else if (tamingBarProgress > 75) {
                 tameBar.style.background = `linear-gradient(to right, #00FF00, #AAFF00)`; // Green
            } else if (tamingBarProgress > 50) {
                 tameBar.style.background = `linear-gradient(to right, #DDDD00, #FFFF00)`; // Yellow
            } else {
                 tameBar.style.background = `linear-gradient(to right, ${G_DARK_GREY}, ${G_DARK_GREY})`; // Dark Grey
            }
        }

        function completeTaming() {
            clearInterval(tamingInterval); clearTimeout(tamingInterval);
            toggleUIPanel(tamingPanel, GAME_STATE.EXPLORE);
            selectedCreature.isTamed = true;
            playerInventory.creatures.push(selectedCreature);
            const objToRemove = wildCreatureMeshes.find(obj => obj.userData.data.id === selectedCreature.id);
            if (objToRemove) {
                scene.remove(objToRemove);
                objToRemove.traverse(child => { if (child.isMesh) { child.geometry.dispose(); if (Array.isArray(child.material)) { child.material.forEach(material => material.dispose()); } else { child.material.dispose(); } } });
                wildCreatureMeshes = wildCreatureMeshes.filter(c => c !== objToRemove);
            }
            showMessage(`Successfully tamed ${selectedCreature.type}! It's now in your inventory.`, 3000);
            selectedCreature = null;
            updateUI();
        }

        function cancelTaming() {
            clearInterval(tamingInterval); clearTimeout(tamingInterval);
            toggleUIPanel(tamingPanel, GAME_STATE.EXPLORE);
            selectedCreature = null;
            showMessage("Taming cancelled.", 1500);
        }

        function buyItem(itemId, price) {
            const item = TRADER_ITEMS.find(i => i.id === itemId);
            if (item && playerInventory.gold >= price && item.stock > 0) {
                playerInventory.gold -= price;
                playerInventory.items[itemId] = (playerInventory.items[itemId] || 0) + 1;
                item.stock--;
                showMessage(`Bought ${itemId} for ${price} gold.`, 1500);
                updateUI();
            } else {
                showMessage("Not enough gold or item out of stock!", 2000);
            }
        }

        function sellItem(itemId, value) {
            if (playerInventory.items[itemId] > 0) {
                playerInventory.gold += value;
                playerInventory.items[itemId]--;
                showMessage(`Sold ${itemId} for ${value} gold.`, 1500);
                updateUI();
            } else {
                showMessage(`You don't have any ${itemId} to sell!`, 2000);
            }
        }

        function craftItem(recipe) {
            let canCraft = true;
            for (const reqItem in recipe.requires) {
                if (playerInventory.items[reqItem] === undefined || playerInventory.items[reqItem] < recipe.requires[reqItem]) {
                    canCraft = false;
                    break;
                }
            }
            const itemDef = ITEM_DEFINITIONS[recipe.result.kitName];
            if (!itemDef || !itemDef.craftTime) {
                showMessage("Crafting recipe data incomplete!", 2000);
                return;
            }

            if (canCraft) {
                for (const reqItem in recipe.requires) {
                    playerInventory.items[reqItem] -= recipe.requires[reqItem];
                }
                activeCrafts.push({
                    id: THREE.MathUtils.generateUUID(),
                    name: recipe.name,
                    kitName: recipe.result.kitName,
                    startTime: Date.now(),
                    duration: itemDef.craftTime
                });
                showMessage(`Started crafting ${recipe.name}! Check 'Active Crafts'.`, 2500);
                updateUI();
            } else {
                showMessage("Not enough resources to craft this!", 2000);
            }
        }

        function chopTree(treeObject) {
            if (playerInventory.items["Axe"] <= 0) {
                showMessage("You need an Axe to chop trees! Check the Trader.", 2000);
                return;
            }
            const woodGained = getRandomInt(5, 15);
            playerInventory.items["Wood"] = (playerInventory.items["Wood"] || 0) + woodGained;
            showMessage(`Chopped down a tree! Gained ${woodGained} Wood.`, 2000);
            updateUI();
            scene.remove(treeObject);
            treeObject.traverse(child => { if (child.isMesh) { child.geometry.dispose(); if (Array.isArray(child.material)) { child.material.forEach(material => material.dispose()); } else { child.material.dispose(); } } });
            activeTreeMeshes = activeTreeMeshes.filter(tree => tree !== treeObject);
        }

        function mineStone(stoneObject) {
            if (playerInventory.items["Pickaxe"] <= 0) {
                showMessage("You need a Pickaxe to mine stones! Check the Trader.", 2000);
                return;
            }
            const stoneGained = getRandomInt(3, 8);
            playerInventory.items["Stone"] = (playerInventory.items["Stone"] || 0) + stoneGained;
            showMessage(`Mined a stone! Gained ${stoneGained} Stone.`, 2000);
            updateUI();
            scene.remove(stoneObject);
            stoneObject.traverse(child => { if (child.isMesh) { child.geometry.dispose(); if (Array.isArray(child.material)) { child.material.forEach(material => material.dispose()); } else { child.material.dispose(); } } });
            activeStoneMeshes = activeStoneMeshes.filter(stone => stone !== stoneObject);
        }

        function enterPlacementMode(itemName, kitName) {
            if (playerInventory.items[kitName] <= 0) {
                showMessage(`You don't have a ${kitName} to place!`, 2000);
                return;
            }
            toggleUIPanel(document.getElementById('inventoryPanel'), GAME_STATE.PLACEMENT);
            placementMode = true;
            placementItemData = { name: itemName, kitName: kitName };

            placementGhostMesh = createBuildingModel(itemName);
            placementGhostMesh.material = new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.5 });
            scene.add(placementGhostMesh);

            placementControls.classList.remove('hidden');
            showMessage(`Tap/drag to position the ${itemName}. Tap 'Place Here' to confirm.`, 3000);
        }

        function confirmPlacement() {
            if (!placementMode || !placementGhostMesh || !placementGroundIntersection || confirmPlacementButton.disabled) {
                showMessage("Invalid placement location or no item selected.", 2000);
                return;
            }
            const buildingType = placementItemData.name;
            const kitName = placementItemData.kitName;

            if (playerInventory.items[kitName] > 0) {
                const finalBuilding = createBuildingModel(buildingType);
                finalBuilding.position.copy(placementGhostMesh.position);
                finalBuilding.userData.gameType = 'building';
                finalBuilding.userData.data = {
                    id: THREE.MathUtils.generateUUID(),
                    type: buildingType,
                    position: { x: finalBuilding.position.x, y: finalBuilding.position.y, z: finalBuilding.position.z }
                };
                scene.add(finalBuilding);
                activePlacedBuildingMeshes.push(finalBuilding);
                worldObjects.placedBuildings.push(finalBuilding.userData.data);
                playerInventory.items[kitName]--;
                showMessage(`Placed a ${buildingType}!`, 2000);
                updateUI();
            } else {
                showMessage(`You ran out of ${kitName}s!`, 2000);
            }
            exitPlacementMode();
        }

        function exitPlacementMode() {
            if (placementGhostMesh) {
                scene.remove(placementGhostMesh);
                placementGhostMesh.geometry.dispose();
                if (Array.isArray(placementGhostMesh.material)) {
                    placementGhostMesh.material.forEach(m => m.dispose());
                } else {
                    placementGhostMesh.material.dispose();
                }
                placementGhostMesh = null;
            }
            placementMode = false;
            placementItemData = null;
            placementGroundIntersection = null;
            placementControls.classList.add('hidden');
            currentGameState = GAME_STATE.EXPLORE;
            showMessage("Placement cancelled.", 1500);
        }

        function startArenaBattle(playerCreature) {
            arenaBattleLogElem.innerHTML = '';
            if (playerCreature.currentHp <= 0) {
                 logBattleMessage(`Your ${playerCreature.type} has fainted and cannot battle!`);
                 return;
            }
            const enemyTypeDef = CREATURE_TYPES[getRandomInt(0, CREATURE_TYPES.length - 1)];
            const enemyCreature = generateCreatureData(enemyTypeDef);
            enemyCreature.type = "Wild " + enemyCreature.type;
            logBattleMessage(`A ${enemyCreature.type} challenges your ${playerCreature.type}!`);
            logBattleMessage(`Your HP: ${playerCreature.currentHp}/${playerCreature.stats.hp} | Enemy HP: ${enemyCreature.currentHp}/${enemyCreature.stats.hp}`);
            let turn = 0;
            const battleInterval = setInterval(() => {
                turn++; logBattleMessage(`--- Turn ${turn} ---`);
                const playerDamage = Math.max(1, playerCreature.stats.strength + getRandomInt(-2, 2) - enemyCreature.stats.defense / 2);
                enemyCreature.currentHp -= playerDamage;
                logBattleMessage(`${playerCreature.type} attacks! Deals ${playerDamage.toFixed(0)} damage to ${enemyCreature.type}.`);
                if (enemyCreature.currentHp <= 0) {
                    enemyCreature.currentHp = 0;
                    logBattleMessage(`${enemyCreature.type} defeated! Your ${playerCreature.type} wins!`);
                    playerInventory.gold += 50;
                    playerInventory.stats.xp += 20;
                    playerCreature.currentHp = playerCreature.stats.hp;
                    showMessage(`You won the battle and gained 50 gold & 20 XP! Your ${playerCreature.type} is fully healed.`, 3000);
                    updateUI(); clearInterval(battleInterval);
                    logBattleMessage(`Battle finished! Click 'Fight Next Opponent' for another challenge.`);
                    return;
                }
                const enemyDamage = Math.max(1, enemyCreature.stats.strength + getRandomInt(-2, 2) - playerCreature.stats.defense / 2);
                playerCreature.currentHp -= enemyDamage;
                logBattleMessage(`${enemyCreature.type} attacks! Deals ${enemyDamage.toFixed(0)} damage to ${playerCreature.type}.`);
                if (playerCreature.currentHp <= 0) {
                    playerCreature.currentHp = 0;
                    logBattleMessage(`Your ${playerCreature.type} was defeated!`);
                    showMessage(`Your ${playerCreature.type} fainted! You lost the battle.`, 3000);
                    updateUI(); clearInterval(battleInterval);
                    logBattleMessage(`Battle finished! Your creature fainted. Choose another or find a way to heal.`);
                    return;
                }
                logBattleMessage(`Your HP: ${playerCreature.currentHp}/${playerCreature.stats.hp} | Enemy HP: ${enemyCreature.currentHp}/${enemyCreature.stats.hp}`);
            }, 1500);
        }

        function logBattleMessage(message) {
            const p = document.createElement('p');
            p.textContent = message;
            arenaBattleLogElem.appendChild(p);
            arenaBattleLogElem.scrollTop = arenaBattleLogElem.scrollHeight;
        }

        // --- Geolocation Functions ---
        function startGPSWatch() {
            if ("geolocation" in navigator) {
                if (gpsWatchId) navigator.geolocation.clearWatch(gpsWatchId);
                gpsStatusElement.textContent = "Requesting GPS permission...";
                gpsStatusElement.style.color = '#DDDD00';
                gpsWatchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const currentCoords = { latitude: position.coords.latitude, longitude: position.coords.longitude };
                        gpsStatusElement.textContent = `GPS Active: Lat ${currentCoords.latitude.toFixed(4)}, Lon ${currentCoords.longitude.toFixed(4)} (Acc: ${position.coords.accuracy.toFixed(1)}m)`;
                        gpsStatusElement.style.color = '#00DD00';
                        if (!lastKnownGeoCoords) {
                            lastKnownGeoCoords = currentCoords;
                            if (!initialCreaturesSpawned) {
                                spawnWildCreatures(SPAWN_ON_MOVE_COUNT);
                                showMessage("GPS Active. Creatures appearing!", 2500);
                                initialCreaturesSpawned = true;
                            }
                        } else {
                            const distance = haversineDistance(lastKnownGeoCoords, currentCoords);
                            if (distance >= MOVEMENT_THRESHOLD_METERS) {
                                showMessage(`Moved ${distance.toFixed(1)}m. New creatures appear!`, 2500);
                                spawnWildCreatures(SPAWN_ON_MOVE_COUNT);
                                lastKnownGeoCoords = currentCoords;
                            }
                        }
                    },
                    (error) => {
                        let errorMessage;
                        switch(error.code) {
                            case error.PERMISSION_DENIED: errorMessage = "GPS Error: Permission denied. Cannot track movement."; break;
                            case error.POSITION_UNAVAILABLE: errorMessage = "GPS Error: Position unavailable. Check device settings."; break;
                            case error.TIMEOUT: errorMessage = "GPS Error: Timeout. Cannot get GPS fix."; break;
                            default: errorMessage = `GPS Error: ${error.message}.`;
                        }
                        gpsStatusElement.textContent = errorMessage;
                        gpsStatusElement.style.color = '#DD0000';
                        console.error("Geolocation error:", error);
                        if (error.code === error.PERMISSION_DENIED) {
                             showMessage("GPS permission denied. Real-world movement features disabled.", 5000);
                        } else {
                             showMessage("GPS issues. Cannot track real-world movement or find new creatures.", 4000);
                        }
                        if (!initialCreaturesSpawned && (error.code === error.PERMISSION_DENIED || error.code === error.POSITION_UNAVAILABLE)) {
                            showMessage("Starting game without real-world tracking. Creatures will not respawn from movement.", 5000);
                            lastKnownGeoCoords = { latitude: 0, longitude: 0 };
                            spawnWildCreatures(SPAWN_ON_MOVE_COUNT);
                            initialCreaturesSpawned = true;
                        }
                    },
                    { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
                );
            } else {
                gpsStatusElement.textContent = "Geolocation not supported by your browser.";
                gpsStatusElement.style.color = '#DD0000';
                showMessage("Geolocation not supported. Cannot track real-world movement or find new creatures. Spawning some for demo.", 4000);
                if (!initialCreaturesSpawned) {
                    spawnWildCreatures(SPAWN_ON_MOVE_COUNT);
                    initialCreaturesSpawned = true;
                    lastKnownGeoCoords = { latitude: 0, longitude: 0 };
                }
            }
        }

        // --- Save/Load Game Functions ---
        const SAVE_KEY = 'arcaneBeastsSave';

        function saveGame() {
            try {
                const saveData = {
                    playerInventory: {
                        gold: playerInventory.gold,
                        items: playerInventory.items,
                        creatures: playerInventory.creatures,
                        stats: playerInventory.stats,
                        playerPos: playerInventory.playerPos
                    },
                    worldObjects: worldObjects
                };
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                showMessage("Game saved!", 1000);
            } catch (e) {
                console.error("Failed to save game:", e);
                showMessage("Error: Could not save game!", 2000);
            }
        }

        function loadGame() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (savedData) {
                    const data = JSON.parse(savedData);
                    playerInventory = data.playerInventory || {};
                    playerInventory.items = playerInventory.items || {};
                    playerInventory.creatures = playerInventory.creatures || [];
                    playerInventory.stats = playerInventory.stats || {};
                    playerInventory.playerPos = playerInventory.playerPos || { x: 0, y: 1, z: 0 };

                    worldObjects = data.worldObjects || { placedBuildings: [] };
                    
                    // Initialize new default stats if not present in old saves
                    playerInventory.stats.health = playerInventory.stats.health !== undefined ? playerInventory.stats.health : 100;
                    playerInventory.stats.maxHealth = playerInventory.stats.maxHealth !== undefined ? playerInventory.stats.maxHealth : 100;
                    playerInventory.stats.xp = playerInventory.stats.xp !== undefined ? playerInventory.stats.xp : 0;
                    playerInventory.stats.level = playerInventory.stats.level !== undefined ? playerInventory.stats.level : 1;
                    playerInventory.stats.hunger = playerInventory.stats.hunger !== undefined ? playerInventory.stats.hunger : 100;
                    playerInventory.stats.maxHunger = playerInventory.stats.maxHunger !== undefined ? playerInventory.stats.maxHunger : 100;
                    playerInventory.stats.thirst = playerInventory.stats.thirst !== undefined ? playerInventory.stats.thirst : 100;
                    playerInventory.stats.maxThirst = playerInventory.stats.maxThirst !== undefined ? playerInventory.stats.maxThirst : 100;

                    // Ensure player's 3D object position is set from loaded data
                    player.position.set(playerInventory.playerPos.x, playerInventory.playerPos.y, playerInventory.playerPos.z);
                    // Also update camera to follow immediately
                    const cameraOffset = new THREE.Vector3(0, 120, 80);
                    camera.position.copy(player.position).add(cameraOffset);
                    camera.lookAt(player.position);

                    // Ensure basic items for starting if inventory is empty (for new players or corrupted saves)
                    if (Object.keys(playerInventory.items).length === 0 || playerInventory.items["Berry"] === undefined) {
                        playerInventory.items["Berry"] = 10;
                    }
                    if (playerInventory.gold === 0) { playerInventory.gold = 200; }
                    if (playerInventory.items["Axe"] === undefined) playerInventory.items["Axe"] = 0;
                    if (playerInventory.items["Pickaxe"] === undefined) playerInventory.items["Pickaxe"] = 0;


                    showMessage("Game loaded!", 1500);
                } else {
                    resetGameData();
                    showMessage("New game started!", 1500);
                }
            } catch (e) {
                console.error("Failed to load game, starting new:", e);
                resetGameData();
                showMessage("Error: Could not load game, starting new!", 2000);
            }
        }

        function resetGameData() {
            playerInventory = {
                gold: 200,
                items: { "Berry": 10, "Axe": 0, "Pickaxe": 0, "Wood": 0, "Stone": 0 },
                creatures: [],
                stats: {
                    health: 100, maxHealth: 100, xp: 0, level: 1,
                    hunger: 100, maxHunger: 100, thirst: 100, maxThirst: 100
                },
                playerPos: { x: 0, y: 1, z: 0 } // Reset player position
            };
            worldObjects = { placedBuildings: [] };
            activeCrafts = [];
            
            // Reset player's 3D object position to initial
            player.position.set(0, 1, 0);
        }

        // --- Start the game ---
        init();
    </script>
</body>
</html>