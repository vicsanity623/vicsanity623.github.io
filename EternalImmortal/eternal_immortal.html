<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EternalImmortal RPG</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#031018">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-icon" href="icon-192x192.PNG">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto:wght@300;400;500;700&display=swap');
        
        :root {
            --primary-text: #e0e0e0;
            --fantasy-gold: #ffd700;
            --fantasy-ruby: #e63946;
            --fantasy-energy: #6efcff;
            --ui-bg-dark: rgba(20, 25, 35, 0.75);
            --ui-border-light: rgba(180, 190, 210, 0.4);
            --ui-border-dark: rgba(0, 0, 0, 0.5);
        }

        body { margin: 0; background-color: #031018; color: var(--primary-text); font-family: 'Roboto', sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; user-select: none; }
        
        /* --- BOOT SCREEN STYLES (Unchanged) --- */
        #boot-screen {
            background-image: radial-gradient(ellipse at 50% 0%, #3d2c58, #031018 70%);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.7s ease-out;
            z-index: 999;
        }
        #boot-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        .boot-content {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 35px; /* Adjusted gap */
            width: 100%; /* Ensure proper centering */
        }
        #boot-title {
            font-family: 'Cinzel', serif;
            font-size: 44px; /* Reduced font size */
            font-weight: 700;
            color: #fff;
            letter-spacing: 1px; /* Reduced letter spacing */
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5), 
                         0 0 15px #6efcff, 
                         0 0 25px #6efcff, 
                         0 0 40px #6efcff;
            animation: boot-title-glow 2.5s ease-in-out infinite alternate;
            text-align: center; /* Ensure text is centered */
        }
        @keyframes boot-title-glow {
            from {
                text-shadow: 0 0 8px rgba(255, 255, 255, 0.5), 
                             0 0 15px #6efcff, 
                             0 0 25px #6efcff, 
                             0 0 40px #6efcff;
            }
            to {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 
                             0 0 20px #aaffff, 
                             0 0 35px #aaffff, 
                             0 0 55px #aaffff;
            }
        }
        #boot-progress-container {
            width: 300px;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #5a4a78;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(90, 74, 120, 0.5) inset;
        }
        #boot-progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #6efcff, #aaffff);
            box-shadow: 0 0 10px #aaffff, 0 0 20px #aaffff;
            border-radius: 5px;
            transition: width 0.1s linear;
        }
        #start-game-button {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: opacity 0.5s ease 0.2s, transform 0.5s ease 0.2s;
        }
        #start-game-button.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        /* --- END BOOT SCREEN STYLES --- */

        /* --- ENHANCED PLAYER UI BAR --- */
        #player-xp-container { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 60px;
            z-index: 200; 
            display: flex; 
            justify-content: flex-end; /* Align items to the right */
            align-items: center; 
            padding: 5px 20px; /* MODIFIED: Increased right padding */
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
            box-sizing: border-box;
            transform: none; 
            background-color: transparent; 
            backdrop-filter: none;
            box-shadow: none;
            border: none;
            gap: 20px; /* MODIFIED: Added gap between resources and profile */
        }

        /* NEW: Wrapper for resource icons */
        #main-menu-resources {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .resource-display {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            font-size: 16px;
            color: #fff;
            background-color: var(--ui-bg-dark);
            padding: 4px 12px;
            border-radius: 20px;
            border: 1px solid var(--ui-border-light);
            box-shadow: 0 1px 3px var(--ui-border-dark);
            min-width: 80px;
            justify-content: center;
        }
        .resource-display i {
            font-size: 14px;
        }
        #player-gold-display .fa-coins { color: var(--fantasy-gold); }
        #player-energy-display .fa-bolt { color: var(--fantasy-energy); }
        #player-rubies-display { display: none; /* Hide the old one */ }

        #main-menu-profile {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: var(--ui-bg-dark);
            border-radius: 25px;
            padding: 4px 15px 4px 4px;
            border: 1px solid var(--ui-border-light);
            box-shadow: 0 1px 3px var(--ui-border-dark);
        }
        
        .profile-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: linear-gradient(145deg, #454955, #22252a);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #9fa6b8;
            border: 2px solid #6b7385;
        }

        /* NEW: Wrapper for profile text */
        .profile-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        #player-level { 
            font-weight: 500;
            font-size: 16px; 
            color: #fff;
            line-height: 1.2;
            text-align: right;
            margin: 0;
        }
        #player-level .level-num {
            font-size: 13px;
            font-weight: 400;
            color: #b0c4de;
        }
        
        #xp-bar { 
            width: 100px;
            height: 8px;
            background-color: #1a1c22;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            border: 1px solid #000;
            margin-top: 2px;
        }
        #xp-bar-fill { 
            width: 60%; /* Example fill */
            height: 100%;
            background: linear-gradient(90deg, #5eabff, var(--fantasy-energy));
            transition: width 0.3s ease;
        }
        #xp-text { display: none; /* Text not needed in this style */ }
        #player-rubies-display.resource-display { display: flex; } /* Re-enable as resource */
        
        @keyframes xp-level-up-flash { 0%, 100% { transform: scale(1); box-shadow: 0 1px 3px var(--ui-border-dark); } 50% { transform: scale(1.05); box-shadow: 0 0 15px var(--fantasy-gold); } }

        /* --- END PLAYER UI BAR --- */

        .screen-container { position: relative; width: 450px; height: 800px; box-shadow: 0 0 30px rgba(0, 0, 0, 0.5); overflow: hidden; }
        .hidden { display: none !important; }

        /* --- ENHANCED MAIN SCREEN --- */
        #main-screen { 
            background-image: linear-gradient(to top, #c1d9e8 0%, #87b3d1 40%, #5b8aab 100%);
            border: 2px solid #5a4a78; 
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #character-showcase-platform {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 380px;
            height: 250px;
            background: radial-gradient(ellipse at 50% 100%, rgba(255, 230, 180, 0.4) 0%, rgba(255, 220, 150, 0) 70%);
            pointer-events: none;
        }
        #character-showcase-platform::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 2px;
            background: linear-gradient(to right, transparent, rgba(255, 230, 180, 0.7), transparent);
            filter: blur(1px);
        }

        #main-menu-sidebar {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
        }
        
        .world-button { 
            /* Base styles for all buttons, if any */
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #main-menu-sidebar .world-button {
            position: relative;
            width: 70px;
            height: 70px;
            background: linear-gradient(145deg, #4a4e5a, #2c2f37);
            border: 2px solid #7a8294;
            border-top-color: #a0a8ba;
            border-left-color: #a0a8ba;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.1);
        }
        #main-menu-sidebar .world-button:hover {
            transform: scale(1.1);
            border-color: var(--fantasy-energy);
            box-shadow: 0 0 15px var(--fantasy-energy);
        }
        #main-menu-sidebar .world-button .icon {
            font-size: 32px;
            margin: 0;
            color: #c8d3e8;
            text-shadow: 0 0 8px rgba(0,0,0,0.5);
        }
        #main-menu-sidebar .world-button .label {
            display: none; /* Labels are hidden in this design */
        }
        #main-menu-sidebar .world-button:hover .label {
            display: block;
            position: absolute;
            left: 110%;
            top: 50%;
            transform: translateY(-50%);
            background: var(--ui-bg-dark);
            padding: 8px 15px;
            border-radius: 5px;
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            white-space: nowrap;
            border: 1px solid var(--ui-border-light);
        }

        /* Old button styles override */
        #dungeons-button, #exploration-button, #station-button {
            position: static;
            transform: none;
            width: auto;
            height: auto;
            flex-direction: row;
        }

        #main-quest-tracker {
            position: absolute;
            bottom: 25px;
            right: 20px;
            width: 280px;
            background-color: var(--ui-bg-dark);
            border: 1px solid var(--ui-border-light);
            border-radius: 8px;
            padding: 12px 18px;
            box-shadow: 0 2px 5px var(--ui-border-dark);
            color: white;
            font-family: 'Roboto', sans-serif;
            z-index: 10;
        }
        #main-quest-tracker h3 {
            font-family: 'Cinzel', serif;
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 700;
            color: var(--fantasy-gold);
            text-shadow: none;
            text-align: left;
        }
        #main-quest-tracker p {
            margin: 0;
            font-size: 14px;
            color: #ccc;
            text-shadow: none;
            text-align: left;
        }
        #main-quest-tracker span {
            display: block;
            margin-top: 5px;
            font-size: 12px;
            color: #999;
            text-align: right;
        }
        /* --- END ENHANCED MAIN SCREEN --- */

        #map-screen { border: 2px solid #4a6a7c; }
        #map-background-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #map-scroll-area { position: relative; z-index: 2; width: 100%; height: 100%; overflow-y: auto; overflow-x: hidden; }
        #map-scroll-area::-webkit-scrollbar { width: 6px; }
        #map-scroll-area::-webkit-scrollbar-track { background: transparent; }
        #map-scroll-area::-webkit-scrollbar-thumb { background-color: rgba(110, 252, 255, 0.3); border-radius: 10px; border: 1px solid rgba(0, 0, 0, 0.2); }
        #map-scroll-area::-webkit-scrollbar-thumb:hover { background-color: rgba(110, 252, 255, 0.5); }
        #map-button-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 10px; }
        #map-content { position: relative; width: 100%; height: 100%; }
        .dungeon-node { position: absolute; width: 80px; height: 80px; cursor: pointer; transition: transform 0.3s ease, filter 0.3s ease; display: flex; justify-content: center; align-items: center; flex-direction: column; }
        .dungeon-node:hover { transform: scale(1.1); }
        .dungeon-node .icon { font-size: 50px; color: #c5dce8; text-shadow: 0 0 10px #6efcff; }
        .dungeon-node .name { font-family: 'Cinzel', serif; font-size: 14px; font-weight: bold; color: #fff; background-color: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; margin-top: 5px; white-space: nowrap; }
        .dungeon-node.locked { filter: grayscale(1) brightness(0.6); cursor: not-allowed; }
        .dungeon-node.locked .icon { color: #6a7f8c; text-shadow: none; }
        .dungeon-node.locked::after { content: "\f023"; font-family: "Font Awesome 6 Free"; font-weight: 900; position: absolute; font-size: 40px; color: rgba(255, 255, 255, 0.8); text-shadow: 0 0 5px black; }
        .dungeon-node.completed .icon { color: #a0b8c8; text-shadow: 0 0 5px #3a4850; }
        .dungeon-node.active .icon { animation: pulse 2s infinite; }
        @keyframes pulse { 0% { transform: scale(1); text-shadow: 0 0 10px #6efcff; } 50% { transform: scale(1.1); text-shadow: 0 0 20px #aaffff; } 100% { transform: scale(1); text-shadow: 0 0 10px #6efcff; } }
        #path-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #path-svg path { fill: none; stroke: url(#line-gradient); stroke-width: 4; stroke-linecap: round; stroke-dasharray: 10 10; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -20; } }
        .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 26, 34, 0.8); backdrop-filter: blur(4px); display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 100; }
        .modal-overlay.visible { opacity: 1; pointer-events: all; }
        .modal-content { background: #10212a; border: 2px solid #4a6a7c; border-radius: 10px; padding: 20px; width: 90%; max-width: 380px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); position: relative; }
        .modal-content .close-button { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: #a0b8c8; }
        .modal-content .close-button:hover { color: #fff; }
        .dungeon-title { font-family: 'Cinzel', serif; font-size: 24px; text-align: center; color: #6efcff; margin: 0 0 5px 0; }
        .dungeon-mode { text-align: center; font-style: italic; color: #a0b8c8; margin-bottom: 20px; }
        .boss-section { display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 20px; }
        .boss-portrait { font-size: 60px; width: 70px; height: 70px; display: flex; justify-content: center; align-items: center; background: #234758; border-radius: 5px; color: #e63946; }
        .boss-info h4 { margin: 0 0 5px; font-size: 18px; }
        .boss-info p { margin: 0; color: #a0b8c8; }
        .rewards-section h4 { text-align: center; margin-bottom: 10px; }
        .rewards-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; justify-items: center; }
        .reward-item { display: flex; flex-direction: column; align-items: center; font-size: 12px; background-color: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; width: 60px; }
        .reward-icon { font-size: 30px; margin-bottom: 5px; }
        .icon-ruby { color: var(--fantasy-ruby); } .icon-shard { color: #f3722c; } .icon-potion { color: #90be6d; } .icon-gold { color: var(--fantasy-gold); } .icon-chest { color: #577590; }
        .start-button { display: block; width: 100%; padding: 15px; margin-top: 25px; font-size: 20px; font-weight: bold; font-family: 'Cinzel', serif; color: #e0e0e0; background: linear-gradient(45deg, #4CAF50, #2E7D32); border: 2px solid #81C784; border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s ease; }
        .start-button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4); }
        #locked-modal .modal-content { text-align: center; font-size: 18px; }
        #game-container { background: #0c0c14; border: 2px solid #444; }
        #exploration-container { background: #031018; border: 2px solid #4a6a7c; }
        #exploration-exit-button { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-canvas { z-index: 15; pointer-events: none; }
        .ui-panel { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(18, 18, 26, 0.9); backdrop-filter: blur(5px); transition: opacity 0.5s ease; z-index: 10; padding-top: 80px; box-sizing: border-box; }
        .panel-hidden { opacity: 0; pointer-events: none; }
        .scrollable-panel { justify-content: flex-start; overflow-y: auto; padding-bottom: 50px; }
        .scrollable-panel::-webkit-scrollbar { display: none; }
        .scrollable-panel { -ms-overflow-style: none; scrollbar-width: none; }
        .button { padding: 15px 30px; font-size: 24px; font-weight: bold; color: #fff; background: linear-gradient(45deg, #5f72be, #3c4a8a); border: 2px solid #8a9ce2; border-radius: 10px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 4px 15px rgba(95, 114, 190, 0.4); margin: 10px; }
        .button:hover { transform: translateY(-3px) scale(1.05); }
        .button:active { transform: translateY(1px) scale(0.98); }
        .button.disabled { background: #555; border-color: #777; cursor: not-allowed; box-shadow: none; transform: none; }
        .button.small { padding: 10px 20px; font-size: 18px; }
        .button.danger { background: linear-gradient(45deg, #e63946, #a11d2b); border-color: #f08080; }
        h1, h2, p { text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); }
        h1 { font-size: 48px; margin-bottom: 20px; }
        h2 { font-size: 32px; color: #a2b0f0; }
        p.subtitle { font-size: 18px; color: #ccc; margin-top: -15px; margin-bottom: 30px; }
        .shop-item { display: flex; justify-content: space-between; align-items: center; width: 85%; background: rgba(0,0,0,0.2); border: 1px solid #444; border-radius: 8px; padding: 15px; margin: 8px 0; }
        .shop-item-info { text-align: left; }
        .shop-item-info h3 { margin: 0; font-size: 20px; }
        .shop-item-info p { margin: 5px 0 0; font-size: 14px; color: #aaa; text-align: left; }
        .cost-text { color: var(--fantasy-gold); }
        .gold-display { position: absolute; top: 20px; right: 20px; font-size: 24px; font-weight: bold; color: var(--fantasy-gold); background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px; }
        #game-over-screen h2 { color: #e63946; }
        .stats-container, .skills-container { width: 85%; }
        .skills-container h2 { font-size: 24px; margin-top: 10px; margin-bottom: 10px; }
        .stat-block, .skill-block { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; margin-bottom: 10px; }
        .stat-header, .skill-header { display: flex; justify-content: space-between; align-items: baseline; }
        .stat-header h3, .skill-header h3 { margin: 0; font-size: 18px; color: #a2b0f0; }
        .stat-header span, .skill-header span { font-size: 14px; color: #aaa; }
        .stat-value { font-size: 22px; color: #fff; margin: 5px 0; }
        .progress-bar-container { width: 100%; height: 8px; background-color: #333; border-radius: 4px; overflow: hidden; margin-top: 8px; }
        .progress-bar-fill { height: 100%; border-radius: 4px; transition: width 0.3s ease; }
        .progress-bar-fill.health { background-color: #c1121f; } .progress-bar-fill.attack { background-color: #f77f00; } .progress-bar-fill.rage { background-color: #7209b7; } .progress-bar-fill.regen { background-color: #4caf50; } .progress-bar-fill.skill { background-color: #00b4d8; }
        .skill-block p { font-size: 14px; color: #ccc; text-align: left; margin: 5px 0 0; }
        .skill-block.locked { opacity: 0.5; } .skill-block.locked h3 { color: #aaa; }
        #player-screen h3.level-up, #player-upgrade-screen h3.level-up { animation: level-up-flash 1s ease; }
        @keyframes level-up-flash { 0%, 100% { color: #a2b0f0; transform: scale(1); } 50% { color: var(--fantasy-gold); transform: scale(1.1); } }
        .battle-banner { position: absolute; top: 40%; left: 50%; transform: translateX(-50%); font-size: 48px; font-weight: bold; color: #fff; padding: 10px 30px; border-radius: 10px; z-index: 20; pointer-events: none; opacity: 0; }
        .stage-clear-banner { background: linear-gradient(90deg, #4CAF50, #2E7D32); text-shadow: 0 0 10px #fff; animation: ultimate-flash 2.5s ease-out forwards; }
        .ultimate-banner { background: linear-gradient(90deg, #f72585, #7209b7); text-shadow: 0 0 10px #fff; animation: ultimate-flash 1.5s ease-out forwards; }
        @keyframes ultimate-flash { 0% { transform: translateX(-50%) scale(0.5); opacity: 0; } 50% { transform: translateX(-50%) scale(1.1); opacity: 1; } 80% { transform: translateX(-50%) scale(1); opacity: 1; } 100% { transform: translateX(-50%) scale(1); opacity: 0; } }
        .combat-button { position: absolute; padding: 10px; width: 80px; height: 80px; display: flex; justify-content: center; align-items: center; flex-direction: column; line-height: 1; font-size: 20px; z-index: 5; }
        #ult-button { left: 10px; bottom: 10px; background: #5a1835; border-color: #f72585; }
        #auto-battle-button { right: 10px; bottom: 10px; background: #555; border-color: #888; }
        #auto-battle-button.active { background: linear-gradient(45deg, #4CAF50, #2E7D32); border-color: #81C784; }
        #ult-button.is-flashing { animation: flash-effect 0.8s infinite; border: 2px solid var(--fantasy-gold); }
        @keyframes flash-effect { 0%, 100% { filter: brightness(1); box-shadow: 0 4px 15px rgba(247, 37, 133, 0.4); } 50% { filter: brightness(1.8); box-shadow: 0 6px 30px rgba(247, 37, 133, 0.9); } }
    </style>
</head>
<body>
    <div id="boot-screen" class="screen-container">
        <div class="boot-content">
            <h1 id="boot-title">EternalImmortal</h1>
            <div id="boot-progress-container">
                <div id="boot-progress-bar"></div>
            </div>
            <button id="start-game-button" class="button">Start Game</button>
        </div>
    </div>

    <!-- ENHANCED PLAYER UI BAR -->
    <div id="player-xp-container" class="hidden">
        <div id="main-menu-resources">
            <div id="player-gold-display" class="resource-display">
                <i class="fas fa-coins"></i> <span id="player-gold-total">0</span>
            </div>
            <div id="player-rubies-display" class="resource-display">
                <i class="fas fa-gem icon-ruby"></i> <span id="player-rubies-total">0</span>
            </div>
            <div id="player-energy-display" class="resource-display">
                <i class="fas fa-bolt"></i> <span>79/85</span>
            </div>
        </div>
        <div id="main-menu-profile">
            <div class="profile-info">
                 <div id="player-level">Player<br><span class="level-num">Level 1</span></div>
                 <div id="xp-bar">
                    <div id="xp-bar-fill"></div>
                    <div id="xp-text">0 / 100 XP</div>
                </div>
            </div>
            <div class="profile-avatar"><i class="fas fa-user-shield"></i></div>
        </div>
    </div>
    
    <!-- ENHANCED MAIN SCREEN -->
    <div id="main-screen" class="screen-container hidden">
        <div id="character-showcase-platform"></div>
        <div id="main-menu-sidebar">
            <div id="dungeons-button" class="world-button">
                <div class="icon"><i class="fas fa-dungeon"></i></div>
                <div class="label">Dungeons</div>
            </div>
            <div id="exploration-button" class="world-button">
                <div class="icon"><i class="fas fa-compass"></i></div>
                <div class="label">Adventure</div>
            </div>
            <div id="station-button" class="world-button">
                <div class="icon"><i class="fas fa-hammer"></i></div>
                <div class="label">Station</div>
            </div>
        </div>
        <div id="main-quest-tracker">
            <h3>Main Quest</h3>
            <p id="main-quest-name">Loading quest...</p>
            <span id="main-quest-progress">0/1 (In Progress)</span>
        </div>
    </div>

    <!-- Rest of your HTML is unchanged -->
    <div id="player-upgrade-screen" class="ui-panel scrollable-panel hidden">
         <h1>Player Station</h1>
         <p class="subtitle">Hone your skills and forge your power.</p>
         <div class="gold-display">💰 <span id="upgrade-gold-total">0</span></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-attack-title">Attack Power</h3><p>Current: <span id="upgrade-screen-attack-power-stat">10</span></p></div><div class="button" id="upgrade-screen-attack-button">Upgrade (<span class="cost-text" id="upgrade-screen-attack-cost">10</span>)</div></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-health-title">Max Health</h3><p>Current: <span id="upgrade-screen-max-health-stat">100</span></p></div><div class="button" id="upgrade-screen-health-button">Upgrade (<span class="cost-text" id="upgrade-screen-health-cost">10</span>)</div></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-rage-title">Rage Gain</h3><p>Current: <span id="upgrade-screen-rage-gain-stat">5</span></p></div><div class="button" id="upgrade-screen-rage-button">Upgrade (<span class="cost-text" id="upgrade-screen-rage-cost">20</span>)</div></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-regen-title">Health Regen</h3><p>Current: <span id="upgrade-screen-health-regen-stat">0</span>/s</p></div><div class="button" id="upgrade-screen-regen-button">Upgrade (<span class="cost-text" id="upgrade-screen-regen-cost">30</span>)</div></div>
         <div id="upgrade-screen-back-button" class="button small" style="margin-top: 30px;">Back to World</div>
    </div>
    <div id="map-screen" class="screen-container hidden">
        <canvas id="map-background-canvas"></canvas>
        <div id="map-scroll-area">
            <div id="map-content">
                <svg id="path-svg"></svg>
            </div>
        </div>
        <div id="map-button-container">
            <button id="map-back-button" class="button small">Back to World</button>
            <button id="global-reset-button" class="button small danger">Reset</button>
        </div>
    </div>
    <div id="details-modal" class="modal-overlay">
        <div class="modal-content"><i class="fas fa-times close-button" onclick="hideModal()"></i><h3 class="dungeon-title" id="modal-title">Dungeon Name</h3><p class="dungeon-mode" id="modal-mode">Challenge Mode</p><div class="boss-section"><div class="boss-portrait" id="modal-boss-icon"></div><div class="boss-info"><h4 id="modal-boss-name">Boss Name</h4><p>Level <span id="modal-boss-level">10</span></p></div></div><div class="rewards-section"><h4>Potential Rewards</h4><div class="rewards-grid" id="modal-rewards"></div></div><div id="modal-start-button" class="start-button">Start</div></div>
    </div>
    <div id="locked-modal" class="modal-overlay">
        <div class="modal-content"><i class="fas fa-times close-button" onclick="hideModal()"></i><p>This dungeon is surrounded by dread. Clear a path by completing previous dungeons first!</p></div>
    </div>
    <div id="game-container" class="screen-container hidden">
        <canvas id="game-canvas"></canvas>
        <canvas id="ui-canvas"></canvas>
        <div id="shop-screen" class="ui-panel scrollable-panel panel-hidden"><h1 id="shop-title">Stage Cleared!</h1><p class="subtitle" id="shop-subtitle">Spend Gold to grow stronger.</p><div class="gold-display">💰 <span id="gold-total">0</span></div><div class="shop-item"><div class="shop-item-info"><h3>Attack Power</h3><p>Current: <span id="attack-power-stat">10</span></p></div><div class="button" id="upgrade-attack-button">Upgrade (<span class="cost-text" id="attack-cost">10</span>)</div></div><div class="shop-item"><div class="shop-item-info"><h3>Max Health</h3><p>Current: <span id="max-health-stat">100</span></p></div><div class="button" id="upgrade-health-button">Upgrade (<span class="cost-text" id="health-cost">10</span>)</div></div><div class="shop-item"><div class="shop-item-info"><h3>Rage Gain</h3><p>Current: <span id="rage-gain-stat">5</span></p></div><div class="button" id="upgrade-rage-button">Upgrade (<span class="cost-text" id="rage-cost">20</span>)</div></div><div class="shop-item"><div class="shop-item-info"><h3>Health Regen</h3><p>Current: <span id="health-regen-stat">0</span>/s</p></div><div class="button" id="upgrade-regen-button">Upgrade (<span class="cost-text" id="regen-cost">30</span>)</div></div><div style="display: flex; justify-content: center; width: 100%; margin-top: 20px;"><div id="player-stats-button" class="button small">Player Stats</div><div id="proceed-button" class="button" style="margin: 10px; background: linear-gradient(45deg, #4CAF50, #2E7D32);">Next Stage</div></div></div>
        <div id="game-over-screen" class="ui-panel panel-hidden"><h1>Defeated!</h1><h2 id="game-over-message">You reached Stage <span id="final-stage-reached">1</span></h2><div id="retry-button" class="button">Try Again</div></div>
        <div id="player-screen" class="ui-panel scrollable-panel panel-hidden"><h1>SoulCraft</h1><div class="stats-container"></div><div class="skills-container"></div><div id="player-screen-back-button" class="button small">Back to Shop</div></div>
        <div id="battle-event-banner" class="battle-banner"></div>
        <div id="ult-button" class="button combat-button panel-hidden">RAGE</div>
        <div id="auto-battle-button" class="button combat-button panel-hidden">AUTO</div>
    </div>
    <div id="exploration-container" class="screen-container hidden">
        <canvas id="exploration-canvas"></canvas>
        <div id="exploration-exit-button" class="button small danger">Exit</div>
    </div>

    <script>
    const bootScreen = document.getElementById('boot-screen');
    const bootProgressBar = document.getElementById('boot-progress-bar');
    const startGameButton = document.getElementById('start-game-button');
    const mainScreen = document.getElementById('main-screen');
    const playerUpgradeScreen = document.getElementById('player-upgrade-screen');
    const mapScreen = document.getElementById('map-screen');
    const gameContainer = document.getElementById('game-container');
    const explorationContainer = document.getElementById('exploration-container');
    const detailsModal = document.getElementById('details-modal');
    const lockedModal = document.getElementById('locked-modal');
    const playerXpContainer = document.getElementById('player-xp-container');
    const playerLevelUI = document.getElementById('player-level');
    const xpBarFillUI = document.getElementById('xp-bar-fill');
    const xpTextUI = document.getElementById('xp-text');
    const playerRubiesTotalUI = document.getElementById('player-rubies-total');
    const playerGoldTotalUI = document.getElementById('player-gold-total');
    const mainQuestNameUI = document.getElementById('main-quest-name');
    const mainQuestProgressUI = document.getElementById('main-quest-progress');

    const SAVE_KEY = 'endlessShapesSaveData';
    const DUNGEON_SAVE_KEY = 'endlessShapesDungeonProgress';
    let currentDungeon = null;
    let playerProgress = { completed: [] };
    const GEN_DATA = {
        nameParts1: ["Tomb", "Crypt", "Cave", "Den", "Lair", "Dungeon", "Fortress", "Catacomb", "Hall", "Spire", "Pits"],
        nameParts2: ["of the", "of", "beneath the", "in the"],
        nameParts3: ["Sorrow", "Lost King", "Fallen", "Dread", "Screaming", "Whispering", "Ancient", "Forgotten", "Gloom", "Abyss"],
        icons: ['fa-chess-rook', 'fa-cross', 'fa-fort-awesome', 'fa-skull', 'fa-spider', 'fa-dragon', 'fa-mountain', 'fa-tree', 'fa-ankh'],
        bossIcons: ['fa-ghost', 'fa-skull-crossbones', 'fa-robot', 'fa-hat-wizard', 'fa-pastafarianism', 'fa-user-secret', 'fa-user-ninja'],
        bossNames1: ["Grave Lord", "Dread Knight", "Soul Eater", "Chaos Bringer", "Abyssal", "Mad", "Ironclad"],
        bossNames2: ["Zarthus", "Malakor", "Shana", "Harven", "Grolnok", "Vexia", "Mortis"]
    };

    function showScreen(screenName) {
        mainScreen.classList.add('hidden');
        playerUpgradeScreen.classList.add('hidden');
        mapScreen.classList.add('hidden');
        gameContainer.classList.add('hidden');
        explorationContainer.classList.add('hidden');
        playerXpContainer.classList.add('hidden'); // Hide by default
        uiParticles = [];

        if (screenName === 'boot') {
            bootScreen.classList.remove('hidden');
        } else {
            // Show the main UI for all other screens
            playerXpContainer.classList.remove('hidden');
            bootScreen.classList.add('hidden');
        }

        if (screenName === 'main') {
            mainScreen.classList.remove('hidden');
            updateMainQuestTracker(); // NEW: Update quest UI when showing main screen
            createMainScreenParticles();
        } else if (screenName === 'player-upgrade') {
            playerUpgradeScreen.classList.remove('hidden');
            initGame(false, true);
            updatePlayerUpgradeScreenUI();
        } else if (screenName === 'map') {
            mapScreen.classList.remove('hidden');
            initializeMap();
        } else if (screenName === 'battle') {
            gameContainer.classList.remove('hidden');
            initGame();
            changeState('COUNTDOWN');
        } else if (screenName === 'exploration') {
            explorationContainer.classList.remove('hidden');
            initGame(false, true);
            initExplorationMode();
        }
    }

    // NEW: Function to update the main quest tracker UI
    function updateMainQuestTracker() {
        if (!player || !player.mainQuestTargetId) {
            mainQuestNameUI.textContent = "No active quest.";
            mainQuestProgressUI.textContent = "";
            return;
        }

        const questDungeon = player.dungeonMap[player.mainQuestTargetId];
        if (questDungeon) {
            mainQuestNameUI.textContent = `Complete: ${questDungeon.name}`;
            const isCompleted = player.completedMainQuests.includes(questDungeon.id);
            mainQuestProgressUI.textContent = isCompleted ? "Completed!" : "0/1 (In Progress)";
        } else {
            mainQuestNameUI.textContent = "Journey's End (for now)...";
            mainQuestProgressUI.textContent = "More quests to come!";
        }
    }

    function createMainScreenParticles() {
        // Particles can be added here for the new main screen if desired
    }

    function updatePlayerUpgradeScreenUI() {
        if (!player) return;
        document.getElementById('upgrade-gold-total').textContent = `${player.gold}`;
        document.getElementById('upgrade-screen-attack-power-stat').textContent = player.stats.attackPower.current;
        document.getElementById('upgrade-screen-max-health-stat').textContent = player.stats.maxHp.current;
        document.getElementById('upgrade-screen-rage-gain-stat').textContent = player.stats.rageGain.current;
        document.getElementById('upgrade-screen-health-regen-stat').textContent = player.stats.healthRegen.current.toFixed(1);
        document.getElementById('upgrade-screen-attack-cost').textContent = player.costs.attackPower;
        document.getElementById('upgrade-screen-health-cost').textContent = player.costs.maxHp;
        document.getElementById('upgrade-screen-rage-cost').textContent = player.costs.rageGain;
        document.getElementById('upgrade-screen-regen-cost').textContent = player.costs.healthRegen;
        document.getElementById('upgrade-screen-attack-button').classList.toggle('disabled', player.gold < player.costs.attackPower);
        document.getElementById('upgrade-screen-health-button').classList.toggle('disabled', player.gold < player.costs.maxHp);
        document.getElementById('upgrade-screen-rage-button').classList.toggle('disabled', player.gold < player.costs.rageGain);
        document.getElementById('upgrade-screen-regen-button').classList.toggle('disabled', player.gold < player.costs.healthRegen);
    }
    
    function loadProgress() { const saved = localStorage.getItem(DUNGEON_SAVE_KEY); if (saved) playerProgress = JSON.parse(saved); }
    function saveProgress() { localStorage.setItem(DUNGEON_SAVE_KEY, JSON.stringify(playerProgress)); }
    function hideModal() { detailsModal.classList.remove('visible'); lockedModal.classList.remove('visible'); }
    function showDetailsModal(dungeonId) {
        const data = player.dungeonMap[dungeonId];
        document.getElementById('modal-title').textContent = data.name;
        document.getElementById('modal-mode').textContent = data.mode;
        document.getElementById('modal-boss-name').textContent = data.boss.name;
        document.getElementById('modal-boss-level').textContent = data.boss.level;
        document.getElementById('modal-boss-icon').innerHTML = `<i class="fas ${data.boss.icon}"></i>`;
        const rewardsGrid = document.getElementById('modal-rewards');
        rewardsGrid.innerHTML = '';
        data.rewards.forEach(reward => {
            let amountText = reward.amount;
            if(reward.name === 'Gold' || reward.name === 'Rubies') {
                 amountText = (reward.amount > 999) ? `x${(reward.amount/1000).toFixed(1)}k` : `x${reward.amount}`;
            }
            rewardsGrid.innerHTML += `<div class="reward-item"><i class="fas ${reward.icon} reward-icon"></i><span>${amountText}</span></div>`;
        });
        const startButton = document.getElementById('modal-start-button');
        startButton.onclick = () => {
            hideModal();
            setTimeout(() => {
                currentDungeon = data;
                delete currentDungeon.rewardGiven; // Reset flag before starting
                showScreen('battle');
            }, 300);
        };
        detailsModal.classList.add('visible');
    }
    function drawPath() {
        const svg = document.getElementById('path-svg');
        let pathData = '';
        const mapContent = document.getElementById('map-content');
        Object.values(player.dungeonMap).forEach(parentDungeon => {
            if (parentDungeon.unlocks && parentDungeon.unlocks.length > 0) {
                 const startNode = mapContent.querySelector(`#${parentDungeon.id}`);
                 if (startNode) {
                    parentDungeon.unlocks.forEach(childId => {
                        const endNode = mapContent.querySelector(`#${childId}`);
                        if (endNode) {
                            const startX = startNode.offsetLeft + startNode.offsetWidth / 2;
                            const startY = startNode.offsetTop + startNode.offsetHeight / 2;
                            const endX = endNode.offsetLeft + endNode.offsetWidth / 2;
                            const endY = endNode.offsetTop + endNode.offsetHeight / 2;
                            pathData += `M${startX},${startY} L${endX},${endY} `;
                        }
                    });
                }
            }
        });
        svg.innerHTML = `<defs><linearGradient id="line-gradient" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:#6efcff;stop-opacity:0" /><stop offset="50%" style="stop-color:#6efcff;stop-opacity:1" /><stop offset="100%" style="stop-color:#6efcff;stop-opacity:0" /></linearGradient></defs><path d="${pathData}" />`;
    }
    function initializeMap() {
        loadProgress();
        const mapContent = document.getElementById('map-content');
        mapContent.innerHTML = '<svg id="path-svg"></svg>';
        let maxTop = 0;
        Object.values(player.dungeonMap).forEach(data => {
            const node = document.createElement('div');
            node.className = 'dungeon-node'; node.id = data.id; 
            node.style.top = `${data.position.top}px`; 
            node.style.left = `${data.position.left}%`; 
            node.style.transform = `translateX(-50%)`;
            node.innerHTML = `<div class="icon"><i class="fas ${data.icon}"></i></div><div class="name">${data.name}</div>`;
            const dungeonData = player.dungeonMap[data.id];
            const isCompleted = dungeonData && (dungeonData.completionCount || 0) > 0;
            const unlockedByDungeonData = player.dungeonMap[data.unlockedBy];
            const isUnlocked = data.isUnlockedByDefault || (data.unlockedBy && unlockedByDungeonData && (unlockedByDungeonData.completionCount || 0) > 0);
            if (isUnlocked) node.classList.add('active'); 
            else node.classList.add('locked');
            if (isCompleted) node.classList.add('completed');
            node.addEventListener('click', () => { if (isUnlocked) showDetailsModal(data.id); else lockedModal.classList.add('visible'); });
            mapContent.appendChild(node);
            if (data.position.top > maxTop) { maxTop = data.position.top; }
        });
        mapContent.style.height = `${Math.max(800, maxTop + 200)}px`;
        document.getElementById('path-svg').style.height = mapContent.style.height;
        drawPath();
    }
    const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
    const uiCanvas = document.getElementById('ui-canvas'), uiCtx = uiCanvas.getContext('2d');
    const explorationCanvas = document.getElementById('exploration-canvas'), expCtx = explorationCanvas.getContext('2d');
    canvas.width = uiCanvas.width = explorationCanvas.width = 450;
    canvas.height = uiCanvas.height = explorationCanvas.height = 800;
    const dom = { shop:document.getElementById('shop-screen'), gameOver:document.getElementById('game-over-screen'), playerStats:document.getElementById('player-screen'), proceedBtn:document.getElementById('proceed-button'), retryBtn:document.getElementById('retry-button'), statsBtn:document.getElementById('player-stats-button'), backBtn:document.getElementById('player-screen-back-button'), battleBanner:document.getElementById('battle-event-banner'), goldDisplay:document.getElementById('gold-total'), upgradeBtns:{attack:document.getElementById('upgrade-attack-button'),health:document.getElementById('upgrade-health-button'),rage:document.getElementById('upgrade-rage-button'),regen:document.getElementById('upgrade-regen-button')}, ultBtn:document.getElementById('ult-button'), autoBtn:document.getElementById('auto-battle-button') };
    let gameState, currentStage, player, enemies, particles, floatingTexts, projectiles, healthOrbs, shakeDuration, isAutoBattle, endCombatTimer, uiParticles=[], skillVisuals=[], countdownTimer;
    let explorationEnemies = [], explorationProjectiles = [], explorationBackgroundStars = [], explorationDifficulty = 1, explorationSpawnTimer = 0;
    const SKILLS_DATA={orbitalStrike:{name:"Orbital Strike",unlockStage:10,baseCooldown:300,cooldownReductionPerLevel:2,baseDamageMultiplier:.5,damageMultiplierPerLevel:.05,baseTargetXP:10},chainLightning:{name:"Chain Lightning",unlockStage:25,baseCooldown:240,cooldownReductionPerLevel:1.5,baseDamageMultiplier:.3,damageMultiplierPerLevel:.03,baseJumps:2,jumpsPerLevel:5,baseTargetXP:15},meteorShower:{name:"Meteor Shower",unlockStage:50,baseCooldown:400,cooldownReductionPerLevel:3,baseDamageMultiplier:.8,damageMultiplierPerLevel:.1,baseCount:5,countPerLevel:10,baseTargetXP:20}};
    function createStat(c){return{name:c.name,level:c.level||1,current:c.current||0,target:c.target||100,baseGain:c.baseGain||1,displaySuffix:c.displaySuffix||'',isFloat:c.isFloat||!1,color:c.color}}
    function updatePlayerXpBar() {
        if (!player) return;
        playerLevelUI.innerHTML = `Player<br><span class="level-num">Level ${player.level}</span>`;
        const xpPercentage = Math.min(100, (player.xp / player.xpToNextLevel) * 100);
        xpBarFillUI.style.width = `${xpPercentage}%`;
        if (xpTextUI) xpTextUI.textContent = `${player.xp} / ${player.xpToNextLevel} XP`;
        if (playerGoldTotalUI) playerGoldTotalUI.textContent = player.gold.toLocaleString();
        if (playerRubiesTotalUI) playerRubiesTotalUI.textContent = (player.rubies || 0).toLocaleString();
    }
    function levelUp() {
        SOUNDS.levelUp();
        player.level++;
        player.xp -= player.xpToNextLevel;
        player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
        const profileElement = document.getElementById('main-menu-profile');
        if (profileElement) {
            profileElement.style.animation = 'xp-level-up-flash 1s ease';
            setTimeout(() => { profileElement.style.animation = ''; }, 1000);
        }
        if (player.xp >= player.xpToNextLevel) { levelUp(); }
    }
    function gainXP(amount) {
        if (!player) return;
        player.xp += amount;
        while (player.xp >= player.xpToNextLevel) { levelUp(); }
    }
    function generateDungeonName() {
        return `${GEN_DATA.nameParts1[Math.floor(Math.random() * GEN_DATA.nameParts1.length)]} ${GEN_DATA.nameParts2[Math.floor(Math.random() * GEN_DATA.nameParts2.length)]} ${GEN_DATA.nameParts3[Math.floor(Math.random() * GEN_DATA.nameParts3.length)]}`;
    }
    function addNewDungeons(triggeringDungeonId) {
        let endOfChainNode = Object.values(player.dungeonMap).find(d => d.unlocks.length === 0);
        if (!endOfChainNode) {
            console.error("Could not find the end of the dungeon chain. Defaulting to last-created dungeon.");
            endOfChainNode = Object.values(player.dungeonMap).reduce((a, b) => a.position.top > b.position.top ? a : b);
            if (!endOfChainNode) return;
        }
        
        let lastDungeon = endOfChainNode;
        const depth = Object.keys(player.dungeonMap).length;
        
        for (let i = 0; i < 2; i++) {
            const newDungeonId = `dungeon-${Date.now()}-${i}`;
            const bossLevel = 10 + depth + i;
            const newLeftPosition = (lastDungeon.position.left < 50) ? 70 + (Math.random() * 10 - 5) : 30 + (Math.random() * 10 - 5);
            const goldReward = Math.floor((bossLevel * 25) + 200 + Math.random() * 50);
            const rubyReward = Math.floor((bossLevel * 5) + 50 + Math.random() * 25);

            const newDungeon = {
                id: newDungeonId, name: generateDungeonName(), completionCount: 0, evolutionLevel: 0,
                position: { top: lastDungeon.position.top + 160 + (Math.random() * 30), left: newLeftPosition },
                icon: GEN_DATA.icons[Math.floor(Math.random() * GEN_DATA.icons.length)],
                unlockedBy: lastDungeon.id, unlocks: [],
                goldReward: goldReward,
                rubyReward: rubyReward,
                boss: {
                    name: `${GEN_DATA.bossNames1[Math.floor(Math.random() * GEN_DATA.bossNames1.length)]} ${GEN_DATA.bossNames2[Math.floor(Math.random() * GEN_DATA.bossNames2.length)]}`,
                    level: bossLevel, icon: GEN_DATA.bossIcons[Math.floor(Math.random() * GEN_DATA.bossIcons.length)],
                    attack: Math.floor(10 + bossLevel * 2.5), maxHp: Math.floor(500 + bossLevel * 80)
                },
                mode: 'Endless Challenge',
                rewards: [ 
                    { name: 'Gold', amount: goldReward, icon: 'fa-coins icon-gold' }, 
                    { name: 'Rubies', amount: rubyReward, icon: 'fa-gem icon-ruby' } 
                ]
            };
            newDungeon.baseName = newDungeon.name;
            player.dungeonMap[newDungeonId] = newDungeon;
            lastDungeon.unlocks.push(newDungeonId);
            lastDungeon = newDungeon;
        }
    }
    function initGame(fromScratch=false, silent=false){
        if (!silent) gameState='LOADING';
        if (!player || fromScratch) {
            currentStage=1;
            player={hp:100,rage:0,gold:0, rubies:0, level:1,xp:0,xpToNextLevel:100, dungeonCompletions: 0, dungeonMap:{}, mainQuestTargetId: null, completedMainQuests: [], stats:{maxHp:createStat({name:"Max Health",current:100,target:500,baseGain:20,color:'health'}),attackPower:createStat({name:"Attack Power",current:10,target:100,baseGain:2,color:'attack'}),rageGain:createStat({name:"Rage Gain",current:5,target:50,baseGain:1,color:'rage'}),healthRegen:createStat({name:"Health Regen",current:0,target:10,baseGain:.5,isFloat:!0,displaySuffix:'/s',color:'regen'})},costs:{maxHp:10,attackPower:10,rageGain:20,healthRegen:30},skills:{},x:canvas.width/2,y:canvas.height-150,size:40,color:"#61a5c2",isAttacking:!1,attackAnimTimer:0,baseY:canvas.height-150,sword:{angle:0,length:30}};
            Object.keys(SKILLS_DATA).forEach(id=>{player.skills[id]={isUnlocked:!1,cooldownTimer:0,level:1,currentXP:0,targetXP:SKILLS_DATA[id].baseTargetXP}});
            isAutoBattle=!1;
        }
        if(!fromScratch) loadGame();
        if (Object.keys(player.dungeonMap).length === 0) {
            let lastDungeon = null;
            const startingLeftPositions = [50, 30, 70]; 
            for (let i = 0; i < 3; i++) {
                const dungeonId = `starter-${i}`;
                const bossLevel = 5 + i * 2;
                const goldReward = Math.floor((bossLevel * 10) + 50 + Math.random() * 25);
                const dungeon = {
                    id: dungeonId, name: generateDungeonName(), completionCount: 0, evolutionLevel: 0,
                    isUnlockedByDefault: (i === 0), 
                    unlockedBy: lastDungeon ? lastDungeon.id : null, 
                    unlocks: [],
                    goldReward: goldReward, // Store actual gold reward
                    position: { top: 100 + (i * 160), left: startingLeftPositions[i] + (Math.random() * 10 - 5) },
                    icon: GEN_DATA.icons[Math.floor(Math.random() * GEN_DATA.icons.length)],
                    boss: { name: 'Stone Guardian', level: bossLevel, icon: 'fa-ghost', attack: 10, maxHp: 500 },
                    mode: 'Standard',
                    rewards: [{ name: 'Gold', amount: goldReward, icon: 'fa-coins icon-gold' }]
                };
                dungeon.baseName = dungeon.name;
                player.dungeonMap[dungeon.id] = dungeon;
                if (lastDungeon) { lastDungeon.unlocks.push(dungeon.id); }
                lastDungeon = dungeon;
            }
        }
        // NEW: Quest initialization
        if (!player.mainQuestTargetId) {
            player.mainQuestTargetId = 'starter-0';
        }
        if (!player.completedMainQuests) {
            player.completedMainQuests = [];
        }

        if (!silent) {
            endCombatTimer=0;enemies=[];particles=[];floatingTexts=[];projectiles=[];healthOrbs=[];shakeDuration=0;uiParticles=[];skillVisuals=[];
            player.hp=player.stats.maxHp.current;
            if (!window.stars) { window.stars=[]; for(let i=0;i<100;i++)window.stars.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,radius:Math.random()*1.5,speed:.2+Math.random()*.5}); }
        }
    }
    function saveGame(){try{localStorage.setItem(SAVE_KEY,JSON.stringify({player,currentStage,isAutoBattle}))}catch(e){console.error("Could not save game:",e)}}
    function loadGame(){try{const savedData=localStorage.getItem(SAVE_KEY);if(!savedData)return;const loaded=JSON.parse(savedData);if(!loaded.player||typeof loaded.player.stats.maxHp==="number"||!loaded.player.skills.orbitalStrike.level){console.log("Old or invalid save detected, resetting player data.");return}else{player=loaded.player}if(player.level===undefined){player.level=1;player.xp=0;player.xpToNextLevel=100}if(player.rubies===undefined){player.rubies=0}if(!player.dungeonMap){player.dungeonMap={};player.dungeonCompletions=0;}Object.values(player.dungeonMap).forEach(d => { if(d.completionCount === undefined) d.completionCount = 0; if(d.evolutionLevel === undefined) d.evolutionLevel = 0; if(!d.baseName) d.baseName = d.name; });currentStage=loaded.currentStage;isAutoBattle=loaded.isAutoBattle}catch(e){console.error("Could not load save data, starting fresh.",e)}}
    function resetGame(){if(confirm("Are you sure you want to reset all progress? This cannot be undone.")){localStorage.removeItem(SAVE_KEY);localStorage.removeItem(DUNGEON_SAVE_KEY);playerProgress={completed:[]};player=null;location.reload();}}
    const audioCtx=new(window.AudioContext||window.webkitAudioContext);function playSound(f,t,d,v=.5){try{const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.connect(g),g.connect(audioCtx.destination),o.type=t,o.frequency.setValueAtTime(f,audioCtx.currentTime),g.gain.setValueAtTime(v,audioCtx.currentTime),g.gain.exponentialRampToValueAtTime(1e-4,audioCtx.currentTime+d),o.start(),o.stop(audioCtx.currentTime+d)}catch(e){}}
    const SOUNDS={click:()=>playSound(440,"sine",.1,.3),playerAttack:()=>playSound(200,"square",.1,.2),enemyAttack:()=>playSound(150,"sawtooth",.1,.2),hit:()=>playSound(880,"triangle",.15,.5),enemyDeath:()=>playSound(100,"sawtooth",.4,.4),ultimate:()=>playSound(80,"sawtooth",.8,.7),upgrade:()=>playSound(600,"triangle",.2,.4),gameOver:()=>playSound(150,"sawtooth",.8,.5),stageClear:()=>playSound(783,"sine",.5),heal:()=>playSound(523,"triangle",.2,.4),levelUp:()=>playSound(900,"sawtooth",.3,.5)};
    function createExplosion(x,y,c,co,s=3,sp=5){const colors=["#fff","#ffd700","#ff8c00",co];for(let i=0;i<c;i++)particles.push({x,y,vx:(Math.random()-.5)*sp,vy:(Math.random()-.5)*sp,life:Math.random()*30+20,color:colors[Math.floor(Math.random()*colors.length)],size:Math.random()*s+1})}
    function addFloatingText(t,x,y,c){floatingTexts.push({text:t,x,y,life:60,color:c})}
    function triggerScreenShake(d){shakeDuration=d}
    function showBattleBanner(t,ty,d){dom.battleBanner.textContent=t;dom.battleBanner.className=`battle-banner ${ty}`;setTimeout(()=>{dom.battleBanner.className='battle-banner panel-hidden'},d)}
    function changeState(newState){Object.values(dom).forEach(el=>{if(el.classList&&el.classList.contains('ui-panel'))el.classList.add('panel-hidden')});dom.ultBtn.classList.add('panel-hidden');dom.autoBtn.classList.add('panel-hidden');uiParticles=[];gameState=newState;switch(newState){case'COUNTDOWN':if(currentDungeon){setupBossStage(currentDungeon)}else{setupNextStage()}dom.ultBtn.classList.remove('panel-hidden');dom.autoBtn.classList.remove('panel-hidden');countdownTimer=180;playSound(500,"sine",0.1,0.3);break;case'COMBAT':dom.ultBtn.classList.remove('panel-hidden');dom.autoBtn.classList.remove('panel-hidden');break;case'SHOP':if(currentDungeon&&!currentDungeon.rewardGiven){if(currentDungeon.goldReward){player.gold+=currentDungeon.goldReward;addFloatingText(`+${currentDungeon.goldReward}💰`,canvas.width/2,canvas.height/2-50,'#ffd700');}if(currentDungeon.rubyReward){player.rubies=(player.rubies||0)+currentDungeon.rubyReward;addFloatingText(`+${currentDungeon.rubyReward}💎`,canvas.width/2,canvas.height/2-20,'#f94144');}currentDungeon.rewardGiven=!0}saveGame();checkSkillUnlocks();dom.shop.classList.remove('panel-hidden');updateShopUI();setTimeout(createShopParticles,100);break;case'GAME_OVER':dom.gameOver.classList.remove('panel-hidden');updateGameOverUI();break;case'PLAYER_STATS':dom.playerStats.classList.remove('panel-hidden');updatePlayerScreenUI();setTimeout(createStatsScreenParticles,100);break;case'ENDING_COMBAT':player.isAttacking=!1;endCombatTimer=120;showBattleBanner('Victory!','stage-clear-banner',2500);SOUNDS.stageClear();break;}}
    function createShopParticles() { document.querySelectorAll('#shop-screen .button, .gold-display, #shop-screen h1').forEach(el => { if (el.tagName === 'H1' || el.classList.contains('gold-display')) { uiParticles.push({ type: 'sparkleGenerator', attachTo: el, spawnRate: .1 }); } else { for (let i = 0; i < 3; i++) { uiParticles.push({ type: 'orbit', attachTo: el, angle: Math.random() * Math.PI * 2, speed: .01 + Math.random() * .02, radius: 1 + Math.random(), color: '#ffd700' }); } } }); }
    function createStatsScreenParticles() { document.querySelectorAll('#player-screen .progress-bar-fill').forEach(el => { if (el.getBoundingClientRect().width > 0) { uiParticles.push({ type: 'sparkleGenerator', attachTo: el, spawnRate: el.getBoundingClientRect().width / 2000, color: el.classList.contains('health') ? '#e63946' : el.classList.contains('attack') ? '#fca311' : el.classList.contains('rage') ? '#9d4edd' : el.classList.contains('regen') ? '#52b788' : '#00b4d8' }); } }); }
    function setupBossStage(dungeon) {enemies = [];currentStage = dungeon.boss.level;const boss = dungeon.boss;enemies.push({x: canvas.width / 2,y: 150,baseY: 150,hp: boss.maxHp,maxHp: boss.maxHp,attack: boss.attack,radius: 40,color: "#e63946",attackCooldown: 90,attackTimer: 120,isAttacking: false,chargeTimer: 0});}
    function setupNextStage(){enemies=[];const e=Math.min(2+Math.floor(currentStage/2),7),t=1+(currentStage-1)*.25,a=3+Math.floor(currentStage/3),s=Math.max(120-2*currentStage,45);for(let n=0;n<e;n++){const e=100+200*Math.random(),r=Math.floor((20+10*Math.random())*t);enemies.push({x:40+Math.random()*(canvas.width-80),y:e,baseY:e,hp:r,maxHp:r,attack:Math.floor(a+2*Math.random()),radius:20+5*Math.random(),color:"#e63946",attackCooldown:s+60*Math.random(),attackTimer:180*Math.random(),isAttacking:!1,chargeTimer:0})}}
    function updateShopUI() {if (currentDungeon) {document.getElementById('shop-title').textContent = `${currentDungeon.name} Cleared!`;document.getElementById('shop-subtitle').textContent = "You are victorious. Claim your rewards.";dom.proceedBtn.textContent = 'Return to Map';} else {document.getElementById('shop-title').textContent = `Stage ${currentStage} Cleared!`;document.getElementById('shop-subtitle').textContent = 'Spend Gold to grow stronger.';dom.proceedBtn.textContent = 'Next Stage';} dom.goldDisplay.textContent = `${player.gold}`;document.getElementById('attack-power-stat').textContent=player.stats.attackPower.current;document.getElementById('max-health-stat').textContent=player.stats.maxHp.current;document.getElementById('rage-gain-stat').textContent=player.stats.rageGain.current;document.getElementById('health-regen-stat').textContent=player.stats.healthRegen.current.toFixed(1);document.getElementById('attack-cost').textContent=player.costs.attackPower;document.getElementById('health-cost').textContent=player.costs.maxHp;document.getElementById('rage-cost').textContent=player.costs.rageGain;document.getElementById('regen-cost').textContent=player.costs.healthRegen;dom.upgradeBtns.attack.classList.toggle('disabled',player.gold<player.costs.attackPower);dom.upgradeBtns.health.classList.toggle('disabled',player.gold<player.costs.maxHp);dom.upgradeBtns.rage.classList.toggle('disabled',player.gold<player.costs.rageGain);dom.upgradeBtns.regen.classList.toggle('disabled',player.gold<player.costs.healthRegen);}
    function updateGameOverUI() {if (currentDungeon) {document.getElementById('game-over-message').textContent = `Defeated by ${currentDungeon.boss.name}`;dom.retryBtn.textContent = "Return to Map";} else {document.getElementById('game-over-message').innerHTML = `You reached Stage <span id="final-stage-reached">${currentStage}</span>`;dom.retryBtn.textContent = "Try Again";}}
    function updatePlayerScreenUI(){const statsContainer=document.querySelector(".stats-container"),skillsContainer=document.querySelector(".skills-container");statsContainer.innerHTML="";skillsContainer.innerHTML='<h2>Skills</h2>';Object.values(player.stats).forEach(stat=>{const progress=stat.current/stat.target*100,block=document.createElement("div");block.className="stat-block",block.innerHTML=`<div class="stat-header"><h3 id="stat-title-${stat.color}">${stat.name}</h3><span>Level ${stat.level}</span></div><p class="stat-value">${stat.isFloat?stat.current.toFixed(1):stat.current} / ${stat.target}${stat.displaySuffix}</p><div class="progress-bar-container"><div id="progress-${stat.color}" class="progress-bar-fill ${stat.color}" style="width: ${Math.min(progress,100)}%;"></div></div>`,statsContainer.appendChild(block)});Object.keys(SKILLS_DATA).forEach(id=>{const skillData=SKILLS_DATA[id],playerSkill=player.skills[id],block=document.createElement("div");block.className="skill-block";if(playerSkill.isUnlocked){const progress=playerSkill.currentXP/playerSkill.targetXP*100;block.innerHTML=`<div class="skill-header"><h3 id="skill-title-${id}">${skillData.name}</h3><span>Level ${playerSkill.level}</span></div><p>${getSkillDescription(id)}</p><div class="progress-bar-container"><div class="progress-bar-fill skill" style="width: ${Math.min(progress,100)}%;"></div></div>`}else{block.classList.add("locked");block.innerHTML=`<h3>${skillData.name}</h3><p>Unlock by clearing Stage ${skillData.unlockStage}</p>`}skillsContainer.appendChild(block)})}
    function getSkillDescription(id){const skillData=SKILLS_DATA[id],playerSkill=player.skills[id],level=playerSkill.level;const damage=Math.floor(player.stats.attackPower.current*(skillData.baseDamageMultiplier+(level-1)*skillData.damageMultiplierPerLevel));switch(id){case'orbitalStrike':return`Launches an orb dealing ${damage} damage.`;case'chainLightning':const jumps=SKILLS_DATA.chainLightning.baseJumps+Math.floor((level-1)/skillData.jumpsPerLevel);return`Lightning hits ${jumps+1} enemies for ${damage} damage.`;case'meteorShower':const count=SKILLS_DATA.meteorShower.baseCount+Math.floor((level-1)/SKILLS_DATA.countPerLevel);return`Calls down ${count} meteors that deal ${damage} damage.`}}
    function buyUpgrade(type, fromUpgradeScreen = false){if(player.gold<player.costs[type])return;SOUNDS.upgrade();player.gold-=player.costs[type];player.costs[type]=Math.floor(1.15*player.costs[type]+5);const stat=player.stats[type];stat.current+=stat.baseGain;if(stat.current>=stat.target){SOUNDS.levelUp();stat.level++;stat.current-=stat.target;stat.target=Math.floor(1.8*stat.target);stat.baseGain=stat.isFloat?1.4*stat.baseGain:Math.ceil(1.5*stat.baseGain);const titleSelector = fromUpgradeScreen ? `#upgrade-screen-${stat.color}-title` : `#stat-title-${stat.color}`; const title=document.querySelector(titleSelector); title&&(title.classList.add("level-up"),setTimeout(()=>title.classList.remove("level-up"),1e3))}saveGame();if(fromUpgradeScreen){updatePlayerUpgradeScreenUI()}else{updateShopUI();if(gameState==="PLAYER_STATS")updatePlayerScreenUI()}}
    function checkSkillUnlocks() {Object.keys(SKILLS_DATA).forEach(id => {const skillData = SKILLS_DATA[id], playerSkill = player.skills[id];if (!playerSkill.isUnlocked && currentStage > skillData.unlockStage) {playerSkill.isUnlocked = true;showBattleBanner(`${skillData.name} Unlocked!`, "ultimate-banner", 3000)}})}
    document.getElementById('dungeons-button').onclick = () => showScreen('map');
    document.getElementById('station-button').onclick = () => showScreen('player-upgrade');
    document.getElementById('exploration-button').onclick = () => showScreen('exploration');
    document.getElementById('map-back-button').onclick = () => showScreen('main');
    document.getElementById('upgrade-screen-back-button').onclick = () => showScreen('main');
    document.getElementById('exploration-exit-button').onclick = () => { saveGame(); showScreen('main'); };
    document.getElementById('global-reset-button').onclick = resetGame;
    document.getElementById('upgrade-screen-attack-button').onclick = () => buyUpgrade('attackPower', true);
    document.getElementById('upgrade-screen-health-button').onclick = () => buyUpgrade('maxHp', true);
    document.getElementById('upgrade-screen-rage-button').onclick = () => buyUpgrade('rageGain', true);
    document.getElementById('upgrade-screen-regen-button').onclick = () => buyUpgrade('healthRegen', true);
    dom.proceedBtn.onclick = () => {
        if (currentDungeon) {
            const completedDungeonData = player.dungeonMap[currentDungeon.id];
            
            // NEW: Main Quest Completion Logic
            if (currentDungeon.id === player.mainQuestTargetId && !player.completedMainQuests.includes(currentDungeon.id)) {
                showBattleBanner('Quest Complete!', 'ultimate-banner', 3000);
                
                // Give massive rewards
                const questXpReward = 200 + (player.level * 50);
                const questGoldReward = 500 + (player.level * 100);
                const questRubyReward = 25 + (player.level * 5);

                gainXP(questXpReward);
                player.gold += questGoldReward;
                player.rubies += questRubyReward;

                addFloatingText(`+${questXpReward} XP!`, canvas.width / 2, canvas.height / 2 - 60, '#6efcff');
                addFloatingText(`+${questGoldReward}💰`, canvas.width / 2, canvas.height / 2 - 30, '#ffd700');
                addFloatingText(`+${questRubyReward}💎`, canvas.width / 2, canvas.height / 2, '#f94144');

                // Mark quest as done and set the next one
                player.completedMainQuests.push(currentDungeon.id);
                const nextQuestTargetId = completedDungeonData.unlocks.length > 0 ? completedDungeonData.unlocks[0] : null;
                player.mainQuestTargetId = nextQuestTargetId;
            }

            // Original dungeon completion logic
            completedDungeonData.completionCount = (completedDungeonData.completionCount || 0) + 1;
            if (completedDungeonData.completionCount > 0 && completedDungeonData.completionCount % 3 === 0) {
                completedDungeonData.evolutionLevel = (completedDungeonData.evolutionLevel || 0) + 1;
                const evolutionPrefixes = ['Empowered', 'Dread', 'Nightmare', 'Infernal', 'Abyssal'];
                const prefix = evolutionPrefixes[Math.min(completedDungeonData.evolutionLevel - 1, evolutionPrefixes.length - 1)];
                completedDungeonData.name = `${prefix} ${completedDungeonData.baseName}`;
                completedDungeonData.boss.level = Math.floor(completedDungeonData.boss.level * 1.2);
                completedDungeonData.boss.maxHp = Math.floor(completedDungeonData.boss.maxHp * 1.5);
                completedDungeonData.boss.attack = Math.floor(completedDungeonData.boss.attack * 1.3);
            }
            if (player.dungeonCompletions > 0 && player.dungeonCompletions % 3 === 0) {
                addNewDungeons(currentDungeon.id);
            }

            saveGame(); 
            currentDungeon = null;
            showScreen('map');
        } else {
            currentStage++;
            changeState('COUNTDOWN');
        }
    };
    dom.retryBtn.onclick = () => {if(currentDungeon) {currentDungeon = null; showScreen('map');} else {player.hp=player.stats.maxHp.current;changeState('SHOP');}};
    dom.statsBtn.onclick=()=>changeState('PLAYER_STATS');
    dom.backBtn.onclick=()=>changeState('SHOP');
    dom.upgradeBtns.attack.onclick=()=>buyUpgrade('attackPower');dom.upgradeBtns.health.onclick=()=>buyUpgrade('maxHp');dom.upgradeBtns.rage.onclick=()=>buyUpgrade('rageGain');dom.upgradeBtns.regen.onclick=()=>buyUpgrade('healthRegen');
    dom.autoBtn.onclick=()=>{isAutoBattle=!isAutoBattle;dom.autoBtn.classList.toggle('active',isAutoBattle);};dom.ultBtn.onclick=()=>{if(gameState!=='COMBAT'||player.rage<100)return;player.rage=0;SOUNDS.ultimate();showBattleBanner('RAGE BURST!','ultimate-banner',1500);triggerScreenShake(20);enemies.forEach(e=>{const t=5*player.stats.attackPower.current;e.hp-=t;createExplosion(e.x,e.y,40,'#f72585',5,10);addFloatingText(t,e.x,e.y,'#f72585');});};canvas.addEventListener('click',e=>{if(gameState!=='COMBAT')return;const t=canvas.getBoundingClientRect(),a=e.clientX-t.left,s=e.clientY-t.top;let n=null;enemies.forEach(e=>{Math.hypot(a-e.x,s-e.y)<e.radius&&(n=e)});isAutoBattle||playerAttack(n);healthOrbs.forEach((e,t)=>{if(Math.hypot(a-e.x,s-e.y)<e.radius){const a=Math.floor(.1*player.stats.maxHp.current);player.hp=Math.min(player.stats.maxHp.current,player.hp+a);addFloatingText(`+${a}`,player.x,player.y,'#4caf50');SOUNDS.heal();healthOrbs.splice(t,1);}});});
    function playerAttack(target){if(!target||player.isAttacking)return;player.isAttacking=!0;player.attackAnimTimer=20;SOUNDS.playerAttack();projectiles.push({x:player.x,y:player.y,target:target,speed:15,isPlayer:!0,damage:player.stats.attackPower.current+Math.floor(5*Math.random())})}
    function updateSkills(){if(enemies.length===0)return;Object.keys(player.skills).forEach(id=>{const skill=player.skills[id];if(!skill.isUnlocked)return;skill.cooldownTimer++;const skillData=SKILLS_DATA[id];const cooldown=Math.max(30,skillData.baseCooldown-(skill.level-1)*skillData.cooldownReductionPerLevel);if(skill.cooldownTimer>cooldown){skill.cooldownTimer=0;skill.currentXP++;if(skill.currentXP>=skill.targetXP){skill.level++;skill.currentXP-=skill.targetXP;skill.targetXP=Math.floor(skill.targetXP*1.5);SOUNDS.levelUp()}const damage=getSkillDescription(id).match(/\d+/)[0];const randomEnemy=enemies[Math.floor(Math.random()*enemies.length)];if(!randomEnemy)return;switch(id){case'orbitalStrike':skillVisuals.push({type:'orbitalStrike',x:player.x,y:player.y,target:randomEnemy,speed:3,damage,life:300});break;case'chainLightning':const jumps=SKILLS_DATA.chainLightning.baseJumps+Math.floor((level-1)/skillData.jumpsPerLevel);let targets=[randomEnemy];for(let i=0;i<jumps;i++){const lastTarget=targets[targets.length-1],potentialNext=enemies.filter(e=>!targets.includes(e)).sort((a,b)=>Math.hypot(a.x-lastTarget.x,a.y-lastTarget.y)-Math.hypot(b.x-lastTarget.x,b.y-lastTarget.y));if(potentialNext.length>0)targets.push(potentialNext[0])}targets.forEach(e=>e.hp-=damage);skillVisuals.push({type:'chainLightning',targets,life:30});break;case'meteorShower':const count=SKILLS_DATA.meteorShower.baseCount+Math.floor((level-1)/SKILLS_DATA.countPerLevel);for(let i=0;i<count;i++){const targetX=randomEnemy.x-100+200*Math.random();skillVisuals.push({type:'meteor',x:targetX,y:-50,targetY:randomEnemy.y-50+100*Math.random(),speed:8,damage,life:200})}break}}})}
    function updateCountdown() { countdownTimer--; if(countdownTimer % 60 === 0 && countdownTimer > 0) { playSound(500, "sine", 0.1, 0.3); } if (countdownTimer <= 0) { changeState('COMBAT'); playSound(800, "sine", 0.1, 0.4); } }
    function updateCombat(){if(player.isAttacking){player.attackAnimTimer--;if(player.attackAnimTimer<=0)player.isAttacking=!1}if(isAutoBattle&&!player.isAttacking&&enemies.length>0){let e=enemies.reduce((e,t)=>Math.hypot(e.x-player.x,e.y-player.y)<Math.hypot(t.x-player.x,t.y-player.y)?e:t);playerAttack(e)}updateSkills();enemies.forEach(e=>{e.attackTimer++;if(e.attackTimer>=e.attackCooldown&&!e.isAttacking){e.isAttacking=!0;e.chargeTimer=30}if(e.chargeTimer>0){e.chargeTimer--;if(e.chargeTimer<=0){e.attackTimer=0;SOUNDS.enemyAttack();projectiles.push({x:e.x,y:e.y,target:player,speed:10,isPlayer:!1,damage:e.attack})}}else if(e.isAttacking)e.isAttacking=!1;if(e.flash>0)e.flash--});projectiles.forEach((e,t)=>{const a=e.target.x-e.x,s=e.target.y-e.y,n=Math.hypot(a,s);if(n<e.speed){e.target.hp-=e.damage;e.target.flash=5;if(e.isPlayer)player.rage=Math.min(player.rage+player.stats.rageGain.current,100);SOUNDS.hit();triggerScreenShake(e.isPlayer?5:8);createExplosion(e.target.x,e.target.y,20,e.isPlayer?"#fff":"#ff4d4d");addFloatingText(e.damage,e.target.x,e.y,e.isPlayer?"#ffd700":"#ff4d4d");projectiles.splice(t,1)}else{e.x+=a/n*e.speed;e.y+=s/n*e.speed}});if(player.hp<=0)return SOUNDS.gameOver(),void changeState("GAME_OVER");const deadEnemies=enemies.filter(e=>e.hp<=0);deadEnemies.forEach(e=>{createExplosion(e.x,e.y,50,e.color,4,8);SOUNDS.enemyDeath();if(!currentDungeon){player.gold+=Math.floor(1.5*currentStage+5)}const xpGain=Math.floor(5*currentStage+Math.random()*5);gainXP(xpGain);});enemies=enemies.filter(e=>e.hp>0);if(enemies.length===0&&gameState==="COMBAT")changeState("ENDING_COMBAT");if(Math.random()<.005&&healthOrbs.length<3)healthOrbs.push({x:40+Math.random()*(canvas.width-80),y:100+300*Math.random(),radius:12,life:600,pulse:0})}
    function initExplorationMode() {
        explorationEnemies = [];
        projectiles = [];
        particles = [];
        floatingTexts = [];
        explorationDifficulty = 1;
        explorationSpawnTimer = 120;
        if (player) {
            player.hp = player.stats.maxHp.current;
            player.rage = 0;
            player.x = 100;
            player.y = explorationCanvas.height / 2;
            player.isAttacking = false;
        }
        if (explorationBackgroundStars.length === 0) {
            for(let i=0; i<150; i++) {
                explorationBackgroundStars.push({x: Math.random()*explorationCanvas.width, y: Math.random()*explorationCanvas.height, radius: Math.random()*2, speed: 0.5 + Math.random()*1.5});
            }
        }
    }
    function updateExplorationMode() {
        if (!player) return;
        explorationBackgroundStars.forEach(star => { star.x -= star.speed; if (star.x < 0) { star.x = explorationCanvas.width; star.y = Math.random() * explorationCanvas.height; }});
        explorationSpawnTimer--;
        if (explorationSpawnTimer <= 0) {
            const enemyHp = Math.floor(50 * explorationDifficulty);
            const enemyAttack = Math.floor(5 * explorationDifficulty);
            explorationEnemies.push({ x: explorationCanvas.width + 50, y: Math.random() * (explorationCanvas.height - 200) + 100, hp: enemyHp, maxHp: enemyHp, attack: enemyAttack, radius: 25, color: `hsl(${Math.random() * 60 + 200}, 80%, 50%)`, attackCooldown: Math.max(45, 120 - explorationDifficulty), attackTimer: 0, xpValue: Math.floor(10 * explorationDifficulty) });
            explorationSpawnTimer = Math.max(30, 180 - explorationDifficulty * 5);
            explorationDifficulty += 0.1;
        }
        if (!player.isAttacking && explorationEnemies.length > 0) {
            let closestEnemy = explorationEnemies[0];
            if (closestEnemy) {
                player.isAttacking = true;
                player.attackAnimTimer = 20;
                SOUNDS.playerAttack();
                projectiles.push({ x: player.x, y: player.y, target: closestEnemy, speed: 15, isPlayer: true, damage: player.stats.attackPower.current + Math.floor(5 * Math.random()) });
            }
        }
        if (player.isAttacking) { player.attackAnimTimer--; if (player.attackAnimTimer <= 0) player.isAttacking = false; }
        const battleLineX = player.x + 80;
        explorationEnemies.forEach(e => { if (e.x > battleLineX) { e.x -= 2; } });
        projectiles.forEach((p, i) => {
            if (!p.target || p.target.hp <= 0) { projectiles.splice(i, 1); return; }
            const dx = p.target.x - p.x, dy = p.target.y - p.y, dist = Math.hypot(dx, dy);
            if (dist < p.speed) { p.target.hp -= p.damage; SOUNDS.hit(); addFloatingText(p.damage, p.target.x, p.target.y, '#ffd700'); createExplosion(p.target.x, p.target.y, 20, '#fff'); projectiles.splice(i, 1); } else { p.x += dx / dist * p.speed; p.y += dy / dist * p.speed; }
        });
        const dead = explorationEnemies.filter(e => e.hp <= 0);
        dead.forEach(e => { createExplosion(e.x, e.y, 50, e.color, 4, 8); SOUNDS.enemyDeath(); gainXP(e.xpValue); player.gold += Math.floor(e.xpValue / 2); });
        explorationEnemies = explorationEnemies.filter(e => e.hp > 0 && e.x > -50);
        particles=particles.filter(e=>{e.x+=e.vx;e.y+=e.vy;e.life--;return e.life>0});
        floatingTexts=floatingTexts.filter(e=>{e.y-=1;e.life--;return e.life>0});
    }
    function update(){
        updatePlayerXpBar();
        updateUiParticles();
        if (!explorationContainer.classList.contains('hidden')) {
            updateExplorationMode();
        } else if (!gameContainer.classList.contains('hidden')) {
            if(gameState==='COUNTDOWN') updateCountdown(); 
            if(gameState==='COMBAT')updateCombat();
            if(gameState==='ENDING_COMBAT'){endCombatTimer--;if(endCombatTimer<=0){player.hp=Math.min(player.stats.maxHp.current,player.hp+Math.floor(.2*player.stats.maxHp.current));changeState('SHOP')}}
            if(player.hp<player.stats.maxHp.current&&player.stats.healthRegen.current>0&&(gameState==='COMBAT'||gameState==='ENDING_COMBAT'||gameState==='COUNTDOWN'))player.hp=Math.min(player.stats.maxHp.current,player.hp+player.stats.healthRegen.current/60);
            healthOrbs=healthOrbs.filter(e=>{e.life--;e.pulse+=.1;if(isAutoBattle){const t=player.x-e.x,a=player.y-e.y;if(Math.hypot(t,a)<player.size){const t=Math.floor(.1*player.stats.maxHp.current);return player.hp=Math.min(player.stats.maxHp.current,player.hp+t),addFloatingText(`+${t}`,player.x,player.y,"#4caf50"),SOUNDS.heal(),!1}e.x+=.03*t;e.y+=.03*a}return e.life>0});
            skillVisuals.forEach((v,i)=>{v.life--;if(v.life<=0)skillVisuals.splice(i,1);switch(v.type){case'orbitalStrike':const dx=v.target.x-v.x,dy=v.target.y-v.y,dist=Math.hypot(dx,dy);if(dist<v.speed){v.target.hp-=v.damage;createExplosion(v.x,v.y,20,'#9d4edd');v.life=0}else{v.x+=dx/dist*v.speed;v.y+=dy/dist*v.speed}break;case'meteor':v.y+=v.speed;if(v.y>=v.targetY){enemies.forEach(e=>{if(Math.abs(e.x-v.x)<30)e.hp-=v.damage});createExplosion(v.x,v.y,30,'#fca311');v.life=0}break}});
            if(window.stars)window.stars.forEach(e=>{e.y+=e.speed;if(e.y>canvas.height){e.y=0;e.x=Math.random()*canvas.width}});
            particles=particles.filter(e=>{e.x+=e.vx;e.y+=e.vy;e.life--;return e.life>0});
            floatingTexts=floatingTexts.filter(e=>{e.y-=1;e.life--;return e.life>0});
        }
    }
    function updateUiParticles() {
        const newParticles = [];
        const container = !gameContainer.classList.contains('hidden') ? gameContainer : null;
        if (!container) { uiParticles = []; return; }
        const containerRect = container.getBoundingClientRect();
        uiParticles.forEach(p => {
            if (p.type === 'orbit') { p.angle += p.speed;
            } else if (p.type === 'sparkle') { p.life--;
            } else if (p.type === 'sparkleGenerator') {
                if (Math.random() < p.spawnRate) {
                    let spawnX, spawnY, spawnWidth, spawnHeight;
                    if (p.attachTo) {
                        const elRect = p.attachTo.getBoundingClientRect();
                        if (elRect.width <= 0) return;
                        spawnX = elRect.left - containerRect.left;
                        spawnY = elRect.top - containerRect.top;
                        spawnWidth = elRect.width;
                        spawnHeight = elRect.height;
                    } else { spawnX = p.x; spawnY = p.y; spawnWidth = p.width; spawnHeight = p.height; }
                    newParticles.push({ type: 'sparkle', x: spawnX + Math.random() * spawnWidth, y: spawnY + Math.random() * spawnHeight, life: 60, maxLife: 60, radius: Math.random() * 2, color: p.color || `rgba(255,220,150,${.5+Math.random()*.5})` });
                }
            }
        });
        uiParticles = uiParticles.filter(p => !(p.type === 'sparkle' && p.life <= 0));
        uiParticles.push(...newParticles);
    }
    function drawHud(){
        if(gameState!=='COMBAT' && gameState !== 'COUNTDOWN') return;
        ctx.save();
        ctx.font='bold 24px Segoe UI';
        ctx.shadowColor='black';
        ctx.shadowBlur=5;
        ctx.fillStyle='white';
        ctx.textAlign='left';
        let titleText = currentDungeon ? currentDungeon.name : `Stage: ${currentStage}`;
        const maxWidth = canvas.width - 140;
        if (ctx.measureText(titleText).width > maxWidth) {
            let truncatedText = titleText;
            while (ctx.measureText(truncatedText + '...').width > maxWidth && truncatedText.length > 0) {
                truncatedText = truncatedText.slice(0, -1);
            }
            titleText = truncatedText + '...';
        }
        ctx.fillText(titleText, 15, 35);
        ctx.textAlign='right';
        ctx.fillStyle='#ffd700';
        ctx.fillText(`💰 ${player.gold}`,canvas.width-15,35);
        ctx.restore();
    }
    function drawUiParticles() {
        if (gameContainer.classList.contains('hidden')) return;
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        const containerRect = gameContainer.getBoundingClientRect();
        uiParticles.forEach(p => {
            if (p.type === 'orbit' && p.attachTo) {
                const elRect = p.attachTo.getBoundingClientRect();
                if (elRect.bottom < containerRect.top || elRect.top > containerRect.bottom) return;
                const currentX = elRect.left - containerRect.left;
                const currentY = elRect.top - containerRect.top;
                const orbitX = (currentX + elRect.width / 2) + Math.cos(p.angle) * (elRect.width / 2 + 10);
                const orbitY = (currentY + elRect.height / 2) + Math.sin(p.angle) * (elRect.height / 2 + 10);
                uiCtx.beginPath();
                uiCtx.arc(orbitX, orbitY, p.radius, 0, Math.PI * 2);
                uiCtx.fillStyle = p.color;
                uiCtx.globalAlpha = .8;
                uiCtx.fill();
            } else if (p.type === 'sparkle') {
                uiCtx.beginPath();
                uiCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                uiCtx.fillStyle = p.color;
                uiCtx.globalAlpha = p.life / p.maxLife * .8;
                uiCtx.fill();
            }
        });
        uiCtx.globalAlpha = 1;
    }
    function drawBackground(){ctx.fillStyle='#0c0c14';ctx.fillRect(0,0,canvas.width,canvas.height);if(window.stars)window.stars.forEach(s=>{ctx.beginPath();ctx.arc(s.x,s.y,s.radius,0,Math.PI*2);ctx.fillStyle=`rgba(255,255,255,${.5+s.speed})`;ctx.fill()})}
    function drawPlayer(){dom.ultBtn.classList.toggle('is-flashing',player.rage>=100);dom.ultBtn.style.background=player.rage>=100?'#f72585':'#5a1835';dom.autoBtn.classList.toggle('active',isAutoBattle);ctx.save();ctx.translate(player.x,player.y);ctx.shadowColor='rgba(0,0,0,0.5)';ctx.shadowBlur=10;ctx.shadowOffsetY=5;ctx.fillStyle=player.color;ctx.fillRect(-player.size/2,-player.size/2,player.size,player.size);if(player.isAttacking){player.sword.angle+=.5}else{player.sword.angle+=(0-player.sword.angle)*.2}ctx.rotate(player.sword.angle);ctx.fillStyle='#ddd';ctx.fillRect(player.size/2,-3,player.sword.length,6);ctx.restore();const barWidth=100,barX=player.x-barWidth/2;ctx.fillStyle='#333';ctx.fillRect(barX,player.y+player.size/2+5,barWidth,12);ctx.fillStyle='#2a9d8f';ctx.fillRect(barX,player.y+player.size/2+5,barWidth*Math.max(0,player.hp/player.stats.maxHp.current),12);ctx.fillStyle='#554300';ctx.fillRect(barX,player.y+player.size/2+18,barWidth,8);ctx.fillStyle='#ffd700';ctx.fillRect(barX,player.y+player.size/2+18,barWidth*(player.rage/100),8)}
    function drawEnemies(){enemies.forEach(e=>{ctx.save();ctx.translate(e.x,e.y);ctx.shadowColor='rgba(0,0,0,0.5)';ctx.shadowBlur=10;ctx.shadowOffsetY=5;ctx.beginPath();ctx.arc(0,0,e.radius,0,Math.PI*2);ctx.fillStyle=e.chargeTimer>0?'#ff6b6b':e.color;ctx.fill();ctx.restore();if(e.flash>0){ctx.beginPath();ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);ctx.fillStyle=`rgba(255,255,255,${e.flash/5})`}const barWidth=e.radius*2;ctx.fillStyle='#333';ctx.fillRect(e.x-e.radius,e.y-e.radius-15,barWidth,5);ctx.fillStyle='#c1121f';ctx.fillRect(e.x-e.radius,e.y-e.radius-15,barWidth*Math.max(0,e.hp/e.maxHp),5)})}
    function drawHealthOrbs(){healthOrbs.forEach(orb=>{ctx.save();ctx.globalAlpha=.5+Math.sin(orb.pulse)*.3;ctx.beginPath();ctx.arc(orb.x,orb.y,orb.radius,0,Math.PI*2);ctx.fillStyle='#4caf50';ctx.fill();ctx.shadowColor='#abffc0';ctx.shadowBlur=15;ctx.fill();ctx.restore()})}
    function drawSkillVisuals(){skillVisuals.forEach(v=>{ctx.save();ctx.globalAlpha=v.life/30;switch(v.type){case'orbitalStrike':ctx.fillStyle='#9d4edd';ctx.beginPath();ctx.arc(v.x,v.y,8,0,2*Math.PI);ctx.fill();ctx.shadowColor='#fff';ctx.shadowBlur=10;ctx.fill();break;case'chainLightning':ctx.strokeStyle='#00b4d8';ctx.lineWidth=3;ctx.shadowColor='#ade8f4';ctx.shadowBlur=15;ctx.beginPath();ctx.moveTo(v.targets[0].x,v.targets[0].y);for(let i=1;i<v.targets.length;i++)ctx.lineTo(v.targets[i].x,v.targets[i].y);ctx.stroke();break;case'meteor':ctx.fillStyle='#fca311';ctx.beginPath();ctx.rect(v.x-3,v.y-15,6,30);ctx.fill();break}ctx.restore()})}
    function drawEffects(){projectiles.forEach(p=>{ctx.fillStyle=p.isPlayer?'#fff':'#ff4d4d';ctx.beginPath();ctx.arc(p.x,p.y,5,0,2*Math.PI);ctx.fill()});particles.forEach(p=>{ctx.fillStyle=p.color;ctx.globalAlpha=p.life/30;ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,2*Math.PI);ctx.fill()});ctx.globalAlpha=1;floatingTexts.forEach(t=>{ctx.font='bold 28px sans-serif';ctx.fillStyle=t.color;ctx.globalAlpha=t.life/60;ctx.textAlign='center';ctx.shadowColor='black';ctx.shadowBlur=4;ctx.fillText(t.text,t.x,t.y)});ctx.shadowBlur=0;ctx.shadowColor='transparent';ctx.globalAlpha=1}
    function drawCountdown(){let text='';let scale=1+(countdownTimer%60)/30;if(countdownTimer>120){text='3'}else if(countdownTimer>60){text='2'}else if(countdownTimer>0){text='1'}if(text){ctx.save();ctx.font=`bold ${120*scale}px Cinzel`;ctx.fillStyle=`rgba(255,255,255,${1-(countdownTimer%60)/60})`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.shadowColor='rgba(255, 100, 100, 0.7)';ctx.shadowBlur=20;ctx.fillText(text,canvas.width/2,canvas.height/2);ctx.restore()}}
    function drawExplorationMode() {
        const dCtx = expCtx;
        dCtx.fillStyle = '#031018';
        dCtx.fillRect(0, 0, explorationCanvas.width, explorationCanvas.height);
        explorationBackgroundStars.forEach(star => { dCtx.beginPath(); dCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); dCtx.fillStyle = `rgba(255, 255, 255, ${star.speed / 3})`; dCtx.fill(); });
        dCtx.save(); dCtx.translate(player.x, player.y); dCtx.fillStyle = player.color; dCtx.fillRect(-player.size/2, -player.size/2, player.size, player.size); dCtx.restore();
        const barWidth=100, barX=player.x-barWidth/2;
        dCtx.fillStyle='#333'; dCtx.fillRect(barX,player.y+player.size/2+5,barWidth,12);
        dCtx.fillStyle='#2a9d8f'; dCtx.fillRect(barX,player.y+player.size/2+5,barWidth*Math.max(0,player.hp/player.stats.maxHp.current),12);
        explorationEnemies.forEach(e => {
            dCtx.save(); dCtx.translate(e.x, e.y); dCtx.beginPath(); dCtx.arc(0, 0, e.radius, 0, Math.PI * 2); dCtx.fillStyle = e.color; dCtx.fill(); dCtx.restore();
            const eBarWidth=e.radius*2;
            dCtx.fillStyle='#333'; dCtx.fillRect(e.x-e.radius,e.y-e.radius-15,eBarWidth,5);
            dCtx.fillStyle='#c1121f'; dCtx.fillRect(e.x-e.radius,e.y-e.radius-15,eBarWidth*Math.max(0,e.hp/e.maxHp),5);
        });
        projectiles.forEach(p => { dCtx.fillStyle = '#fff'; dCtx.beginPath(); dCtx.arc(p.x, p.y, 5, 0, 2 * Math.PI); dCtx.fill(); });
        particles.forEach(p => { dCtx.fillStyle = p.color; dCtx.globalAlpha = p.life/30; dCtx.beginPath(); dCtx.arc(p.x, p.y, p.size, 0, 2*Math.PI); dCtx.fill(); });
        dCtx.globalAlpha=1;
        floatingTexts.forEach(t => { dCtx.font='bold 28px sans-serif'; dCtx.fillStyle=t.color; dCtx.globalAlpha=t.life/60; dCtx.textAlign='center'; dCtx.shadowColor='black'; dCtx.shadowBlur=4; dCtx.fillText(t.text,t.x,t.y); });
        dCtx.shadowBlur=0; dCtx.globalAlpha=1;
    }
    function draw(){
        if (!mainScreen.classList.contains('hidden')) {
            // The main menu background is now CSS, so no canvas drawing is needed for it.
        }
        if (!explorationContainer.classList.contains('hidden')) {
            drawExplorationMode();
        } else if (!gameContainer.classList.contains('hidden')) {
            drawBackground();
            ctx.save();
            if(shakeDuration>0){ctx.translate(Math.random()*6-3,Math.random()*6-3);shakeDuration--}
            if(gameState==='COMBAT'||gameState==='ENDING_COMBAT'||gameState==='COUNTDOWN'){drawPlayer();drawEnemies();drawHealthOrbs();drawEffects();drawSkillVisuals()}
            if(gameState==='COUNTDOWN'){drawCountdown()}
            ctx.restore();
            drawHud();
            drawUiParticles();
        }
    }
    function gameLoop(){update();draw();requestAnimationFrame(gameLoop)}

    function initializeBootSequence() {
        let progress = 0;
        const loadingTime = 2500; // 2.5 seconds total
        const intervalTime = 25; // update every 25ms
        const progressIncrement = 100 / (loadingTime / intervalTime);

        const bootInterval = setInterval(() => {
            progress += progressIncrement;
            bootProgressBar.style.width = Math.min(progress, 100) + '%';

            if (progress >= 100) {
                clearInterval(bootInterval);
                setTimeout(() => {
                    startGameButton.classList.add('visible');
                }, 300); // Small delay after bar fills
            }
        }, intervalTime);

        startGameButton.addEventListener('click', () => {
            SOUNDS.click();
            bootScreen.classList.add('fade-out');
            bootScreen.addEventListener('transitionend', () => {
                showScreen('main');
            }, { once: true });
        });
    }

    let mapBackgroundCanvas, gl, mapProgram, mapStartTime;
    const mapVertexShaderSource = `attribute vec4 a_position; void main() { gl_Position = a_position; }`;
    const mapFragmentShaderSource = `
        precision mediump float;
        uniform vec2 u_resolution;
        uniform float u_time;
        vec2 hash( vec2 p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return -1.0 + 2.0*fract(sin(p)*43758.5453123); }
        float noise( in vec2 p ) { const float K1 = 0.366025404; const float K2 = 0.211324865; vec2 i = floor( p + (p.x+p.y)*K1 ); vec2 a = p - i + (i.x+i.y)*K2; vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); vec2 b = a - o + K2; vec2 c = a - 1.0 + 2.0*K2; vec2 h = hash( i ); vec2 k = hash( i + o ); vec2 l = hash( i + 1.0 ); return 40.0 * dot( vec4(h.x, k.x, l.x, h.y), vec4(0.0,0.0,0.0,0.0) ); }
        float fbm(vec2 p) { float total = 0.0; float amplitude = 0.5; for(int i = 0; i < 5; i++) { total += noise(p) * amplitude; p *= 2.0; amplitude *= 0.5; } return total; }
        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            vec2 p = uv * 2.0;
            float t = u_time * 0.1;
            float angle = atan(p.y, p.x);
            float dist = length(p);
            p += vec2(cos(angle + t) * 0.1, sin(angle + t) * 0.1);
            float n1 = fbm(p + t * 0.2);
            float n2 = fbm(p * 1.5 - t * 0.1);
            float finalNoise = (n1 + n2) * (1.0 - smoothstep(0.5, 1.2, dist));
            vec3 color1 = vec3(0.05, 0.0, 0.1);
            vec3 color2 = vec3(0.1, 0.2, 0.4);
            vec3 color3 = vec3(0.8, 0.2, 0.5);
            vec3 color = mix(color1, color2, smoothstep(0.0, 0.6, finalNoise));
            color = mix(color, color3, smoothstep(0.5, 0.8, finalNoise));
            gl_FragColor = vec4(vec3(0.01, 0.05, 0.1) + color, 1.0);
        }
    `;
    function initMapBackground() {
        mapBackgroundCanvas = document.getElementById('map-background-canvas');
        gl = mapBackgroundCanvas.getContext('webgl');
        if (!gl) {
            console.error("WebGL not supported, falling back to CSS background.");
            document.getElementById('map-screen').style.backgroundImage = 'radial-gradient(circle at 50% 30%, #1a5c69, #0f343d 50%, #031018 85%)';
            return;
        }
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, mapVertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, mapFragmentShaderSource);
        mapProgram = gl.createProgram();
        gl.attachShader(mapProgram, vertexShader);
        gl.attachShader(mapProgram, fragmentShader);
        gl.linkProgram(mapProgram);
        if (!gl.getProgramParameter(mapProgram, gl.LINK_STATUS)) {
            console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(mapProgram));
            return;
        }
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        mapStartTime = Date.now();
    }
    function renderMapBackground() {
        if (!gl || !mapProgram) return;
        const canvas = gl.canvas;
        const displayWidth  = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }
        gl.useProgram(mapProgram);
        const positionAttributeLocation = gl.getAttribLocation(mapProgram, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        const resolutionUniformLocation = gl.getUniformLocation(mapProgram, 'u_resolution');
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        const timeUniformLocation = gl.getUniformLocation(mapProgram, 'u_time');
        const currentTime = (Date.now() - mapStartTime) * 0.001;
        gl.uniform1f(timeUniformLocation, currentTime);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    const originalDraw = draw;
    draw = function() {
        if (!mapScreen.classList.contains('hidden')) {
            renderMapBackground();
        }
        originalDraw();
    }
    
    // --- Initialize Game ---
    initGame(false, true); // Load saved data or create new game state in the background
    initializeBootSequence(); // Show the boot screen animation
    initMapBackground();
    gameLoop();
    </script>
    <script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js')
                .then(registration => {
                    console.log('Service Worker registered successfully:', registration.scope);
                })
                .catch(error => {
                    console.log('Service Worker registration failed:', error);
                });
        });
    }
</script>
</body>
</html>
