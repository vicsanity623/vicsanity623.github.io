        <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EternalImmortal</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto:wght@300;400;500&display=swap');
        :root {
            --bg-dark: #0d1117;
            --bg-medium: #161b22;
            --border-color: #30363d;
            --border-highlight: #8b949e;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-purple: #a371f7;
            --accent-red: #f85149;
            --accent-gold: #ffc107;
        }

        * {
            box-sizing: border-box;
        }

        body { 
            margin: 0; 
            background-color: var(--bg-dark); 
            color: var(--text-primary); 
            font-family: 'Roboto', sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            overflow: hidden; 
            user-select: none; 
        }

        /* --- BOOT SCREEN STYLES (Corrected) --- */
        #boot-screen {
            background-image: radial-gradient(ellipse at 50% 0%, #3d2c58, #031018 70%);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            transition: opacity 0.7s ease-out;
            z-index: 999;
        }
        #boot-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        .boot-content {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 35px; /* Adjusted gap */
            width: 100%; /* Ensure proper centering */
        }
        #boot-title {
            font-family: 'Cinzel', serif;
            font-size: 44px; /* Reduced font size */
            font-weight: 700;
            color: #fff;
            letter-spacing: 1px; /* Reduced letter spacing */
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5), 
                        0 0 15px #6efcff, 
                        0 0 25px #6efcff, 
                        0 0 40px #6efcff;
            animation: boot-title-glow 2.5s ease-in-out infinite alternate;
            text-align: center; /* Ensure text is centered */
        }
        @keyframes boot-title-glow {
            from {
                text-shadow: 0 0 8px rgba(255, 255, 255, 0.5), 
                            0 0 15px #6efcff, 
                            0 0 25px #6efcff, 
                            0 0 40px #6efcff;
            }
            to {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 
                            0 0 20px #aaffff, 
                            0 0 35px #aaffff, 
                            0 0 55px #aaffff;
            }
        }
        #boot-progress-container {
            width: 300px;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #5a4a78;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(90, 74, 120, 0.5) inset;
        }
        #boot-progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #6efcff, #aaffff);
            box-shadow: 0 0 10px #aaffff, 0 0 20px #aaffff;
            border-radius: 5px;
            transition: width 0.1s linear;
        }
        #start-game-button {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
            transition: opacity 0.5s ease 0.2s, transform 0.5s ease 0.2s;
        }
        #start-game-button.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }
        /* --- END BOOT SCREEN STYLES --- */

        .weapon-stats-list {
            list-style: none;
            padding: 10px;
            margin: 10px 0 0 0;
            text-align: left;
            background-color: rgba(0,0,0,0.2);
            border-radius: 6px;
        }
        .weapon-stats-list li {
            font-size: 14px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        .weapon-stats-list i {
            width: 20px;
            margin-right: 8px;
            color: var(--accent-blue);
        }
        .weapon-stats-list .stat-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        .weapon-stats-list .stat-name {
            color: var(--text-secondary);
            margin-left: auto; /* Pushes the name to the right */
        }

        #loot-summary {
            width: 100%; /* Changed from 85% */
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 15px;
            margin: 0 0 20px 0; /* Changed margin */
            text-align: left;
        }
        #loot-summary h4 {
            margin: 0 0 8px 0;
            text-align: center;
            color: var(--accent-blue);
            font-size: 16px;
            font-weight: 500;
        }
        #loot-summary p {
            text-align: left;
            margin: 5px 0;
            font-size: 16px;
            text-shadow: none;
        }
        #loot-summary i {
            color: var(--accent-gold);
            margin-right: 10px;
            width: 20px; /* Align icons nicely */
            text-align: center;
        }
        #loot-summary .icon-xp { color: var(--accent-purple); }
        #loot-summary .icon-stone { color: #c0c0c0; }

        /* --- NEW TOP BAR UI --- */
        #top-bar-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 95%;
            max-width: 430px;
            justify-content: flex-end; /* Align items to the right side of the main container */
        }

        #player-info-bar {
            display: flex;
            align-items: center;
            background-color: #1a1f2c;
            border: 1px solid #4a5468;
            border-radius: 20px;
            height: 40px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            flex-grow: 1;
            margin-right: auto; /* Pushes itself to the left */
        }

        #player-avatar {
            width: 40px;
            height: 40px;
            flex-shrink: 0;
            background-color: #0d1117;
            border-right: 1px solid #4a5468;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #player-avatar .fa-user-shield {
            font-size: 24px;
            color: #a0b8c8;
        }

        #player-level-badge {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background-color: #3d4a66;
            color: #e0e0e0;
            font-size: 10px;
            font-weight: bold;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #4a5468;
            line-height: 1;
        }

        #xp-bar-wrapper {
            flex-grow: 1;
            height: 100%;
            position: relative;
            background-color: #333; /* Background for the empty part of the bar */
        }

        #xp-bar-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 0%; /* Controlled by JS */
            background: linear-gradient(90deg, #6a3093, #a044ff);
            transition: width 0.3s ease;
        }

        #xp-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: 500;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        #player-resources-group {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .resource-item {
            display: flex;
            align-items: center;
            gap: 6px;
            background-color: #1a1f2c;
            border: 1px solid #4a5468;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: bold;
            color: #e0e0e0;
            height: 30px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            min-width: 50px; /* Ensure a minimum width */
            justify-content: center;
        }

        .resource-item i {
            font-size: 16px;
        }

        @keyframes xp-level-up-flash { 
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(0,0,0,0.5); 
            } 50% { 
                transform: scale(1.03); 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.7); 
            } 
        }
        /* --- END NEW TOP BAR UI --- */
        #inventory-button {
        bottom: 20px;
        right: 20px;
        width: 120px; /* Smaller button */
        height: 120px;
        }
        #inventory-button .icon { font-size: 50px; color: #b5838d; }

        .inventory-tabs {
            display: flex;
            border-bottom: 2px solid #4a6a7c;
            margin-bottom: 20px;
        }
        .inventory-tab-btn {
            flex-grow: 1;
            padding: 15px;
            font-size: 16px;
            font-family: 'Cinzel', serif;
            background: none;
            border: none;
            color: #a0b8c8;
            cursor: pointer;
            transition: all 0.2s ease;
            border-bottom: 3px solid transparent;
        }
        .inventory-tab-btn.active {
            color: #6efcff;
            border-bottom-color: #6efcff;
        }
        .inventory-tab-btn:hover {
            background-color: rgba(110, 252, 255, 0.1);
        }

        .inventory-panel {
            display: none; /* Hide all panels by default */
            text-align: center;
            padding: 10px;
        }
        .inventory-panel.active {
            display: block; /* Show only the active one */
        }
        #stones-grid {
            max-height: 300px;
            overflow-y: auto;
        }

        .screen-container { 
            position: absolute; /* Changed to absolute for fade transitions */
            width: 450px; 
            height: 800px; 
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.7); 
            overflow: hidden; 
            background-color: var(--bg-medium);
            border: 1px solid var(--border-color);
            transition: opacity 0.4s ease-in-out;
        }
        .screen-container.is-fading-out {
            opacity: 0;
            pointer-events: none;
        }
        .hidden { 
            display: none !important; 
        }
        #main-screen { background-image: radial-gradient(ellipse at 50% 100%, #3d2c58, #0f0c14 60%); border-color: #5a4a78; }
        .world-button { position: absolute; cursor: pointer; border-radius: 15px; background-color: rgba(0,0,0,0.3); border: 2px solid rgba(138, 156, 226, 0.3); display: flex; flex-direction: column; justify-content: center; align-items: center; transition: all 0.3s ease; backdrop-filter: blur(2px); }
        .world-button:hover { background-color: rgba(0,0,0,0.5); border-color: rgba(138, 156, 226, 0.7); transform: scale(1.05); }
        .world-button .icon { font-size: 70px; text-shadow: 0 0 15px; margin-bottom: 10px; }
        .world-button .label { font-family: 'Cinzel', serif; font-size: 24px; font-weight: bold; color: #fff; text-shadow: 1px 1px 3px #000; }
        #dungeons-button { top: 18%; left: 50%; transform: translateX(-50%); width: 180px; height: 180px; }
        #dungeons-button .icon { color: #6efcff; }
        #exploration-button { top: 48%; left: 50%; transform: translateX(-50%); width: 180px; height: 180px; }
        #exploration-button .icon { color: #90be6d; }
        #station-button { top: 78%; left: 50%; transform: translateX(-50%); width: 160px; height: 160px; }
        #station-button .icon { color: #f9c74f; }
        #map-screen { border: 1px solid var(--border-color); }
        #map-background-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #map-scroll-area { position: relative; z-index: 2; width: 100%; height: 100%; overflow-y: auto; overflow-x: hidden; }
        #map-scroll-area::-webkit-scrollbar { width: 6px; }
        #map-scroll-area::-webkit-scrollbar-track { background: transparent; }
        #map-scroll-area::-webkit-scrollbar-thumb { background-color: rgba(110, 252, 255, 0.3); border-radius: 10px; border: 1px solid rgba(0, 0, 0, 0.2); }
        #map-scroll-area::-webkit-scrollbar-thumb:hover { background-color: rgba(110, 252, 255, 0.5); }
        #map-button-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 10px; }
        #map-content { position: relative; width: 100%; height: 100%; }
        .dungeon-node { position: absolute; width: 80px; height: 80px; cursor: pointer; transition: transform 0.3s ease, filter 0.3s ease; display: flex; justify-content: center; align-items: center; flex-direction: column; }
        .dungeon-node:hover { transform: scale(1.1); }
        .dungeon-node .icon { font-size: 50px; color: #c5dce8; text-shadow: 0 0 10px #6efcff; }
        .dungeon-node .name { font-family: 'Cinzel', serif; font-size: 14px; font-weight: bold; color: #fff; background-color: rgba(0,0,0,0.5); padding: 2px 6px; border-radius: 4px; margin-top: 5px; white-space: nowrap; }
        .dungeon-node.locked { filter: grayscale(1) brightness(0.6); cursor: not-allowed; }
        .dungeon-node.locked .icon { color: #6a7f8c; text-shadow: none; }
        .dungeon-node.completed .icon { color: #a0b8c8; text-shadow: 0 0 5px #3a4850; }
        .dungeon-node.active .icon { animation: pulse 2s infinite; }
        .dungeon-node .completion-counter {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: var(--accent-green);
            color: white;
            font-size: 11px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.5);
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
            z-index: 5;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .dungeon-node .completion-counter i {
            font-size: 10px;
        }
        @keyframes pulse { 0% { transform: scale(1); text-shadow: 0 0 10px #6efcff; } 50% { transform: scale(1.1); text-shadow: 0 0 20px #aaffff; } 100% { transform: scale(1); text-shadow: 0 0 10px #6efcff; } }
        #path-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #path-svg path { fill: none; stroke: url(#line-gradient); stroke-width: 4; stroke-linecap: round; stroke-dasharray: 10 10; animation: dash 1s linear infinite; }
        @keyframes dash { to { stroke-dashoffset: -20; } }
        .modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(10, 26, 34, 0.8); backdrop-filter: blur(4px); display: flex; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 100; }
        .modal-overlay.visible { opacity: 1; pointer-events: all; }
        .modal-content { background: #10212a; border: 2px solid #4a6a7c; border-radius: 10px; padding: 20px; width: 90%; max-width: 380px; box-shadow: 0 5px 25px rgba(0,0,0,0.5); position: relative; }
        .modal-content .close-button { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: #a0b8c8; }
        .modal-content .close-button:hover { color: #fff; }
        .dungeon-title { font-family: 'Cinzel', serif; font-size: 24px; text-align: center; color: #6efcff; margin: 0 0 5px 0; }
        .dungeon-mode { text-align: center; font-style: italic; color: #a0b8c8; margin-bottom: 20px; }
        .boss-section { display: flex; align-items: center; gap: 15px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 20px; }
        .boss-portrait { font-size: 60px; width: 70px; height: 70px; display: flex; justify-content: center; align-items: center; background: #234758; border-radius: 5px; color: #e63946; }
        .boss-info h4 { margin: 0 0 5px; font-size: 18px; }
        .boss-info p { margin: 0; color: #a0b8c8; }
        .rewards-section h4 { text-align: center; margin-bottom: 10px; }
        .rewards-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; justify-items: center; }
        .reward-item { display: flex; flex-direction: column; align-items: center; font-size: 12px; background-color: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; width: 60px; }
        .reward-icon { font-size: 30px; margin-bottom: 5px; }
        .icon-ruby { color: #f94144; } .icon-shard { color: #f3722c; } .icon-potion { color: #90be6d; } .icon-gold { color: #f9c74f; } .icon-chest { color: #577590; }
        .start-button { display: block; width: 100%; padding: 15px; margin-top: 25px; font-size: 20px; font-weight: bold; font-family: 'Cinzel', serif; color: #e0e0e0; background: linear-gradient(45deg, #4CAF50, #2E7D32); border: 2px solid #81C784; border-radius: 8px; cursor: pointer; text-align: center; transition: all 0.2s ease; }
        .start-button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4); }
        #locked-modal .modal-content { text-align: center; font-size: 18px; }
        #game-container { background: #0c0c14; border: 1px solid var(--border-color); }
        #exploration-container { background: #031018; border: 1px solid var(--border-color); }
        #exploration-exit-button { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 10; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-canvas { z-index: 15; pointer-events: none; }

        .ui-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-image: radial-gradient(circle at 50% 0%, #1c2330, var(--bg-medium) 80%);
            backdrop-filter: blur(3px);
            transition: opacity 0.4s ease;
            z-index: 10;
            padding: 80px 20px 20px 20px;
            box-sizing: border-box;
            opacity: 1;
        }
        .panel-hidden {
            opacity: 0 !important;
            pointer-events: none;
        }
        .scrollable-panel { justify-content: flex-start; overflow-y: auto; padding-bottom: 50px; }
        .scrollable-panel::-webkit-scrollbar { display: none; }
        .scrollable-panel { -ms-overflow-style: none; scrollbar-width: none; }

        .button {
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            font-family: 'Cinzel', serif;
            color: var(--text-primary);
            background: linear-gradient(180deg, #2a3038, #161b22);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.05);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin: 10px;
        }
        .button:not(.disabled):hover {
            transform: translateY(-2px);
            background: linear-gradient(180deg, #323842, #1f242c);
            border-color: var(--border-highlight);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .button:not(.disabled):active {
            transform: translateY(1px);
            background: linear-gradient(180deg, #161b22, #2a3038);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .button.disabled {
            background: #21262d;
            border-color: var(--border-color);
            color: var(--text-secondary);
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .button.primary {
            background: linear-gradient(180deg, #238636, #165c26);
            border-color: #3fb950;
            color: white;
        }
        .button.primary:not(.disabled):hover { background: linear-gradient(180deg, #2ea043, #1a6829); }
        .button.danger {
            background: linear-gradient(180deg, #da3633, #a12421);
            border-color: var(--accent-red);
            color: white;
        }
        .button.danger:not(.disabled):hover { background: linear-gradient(180deg, #e44f4d, #b1312e); }
        .button.small { padding: 8px 16px; font-size: 14px; }

        h1, h2, p { text-align: center; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); }
        h1 { font-size: 48px; margin-bottom: 20px; }
        h2 { font-size: 32px; color: var(--accent-blue); }
        p.subtitle { font-size: 16px; color: var(--text-secondary); margin-top: -20px; margin-bottom: 25px; }

        /* --- NEW SHOP SCREEN STYLES --- */
        .shop-content-wrapper {
            width: 100%;
            height: calc(100% - 80px); /* Full height minus footer */
            overflow-y: auto;
            padding: 0 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .shop-content-wrapper::-webkit-scrollbar { display: none; }
        .shop-content-wrapper { -ms-overflow-style: none; scrollbar-width: none; }

        #shop-screen h1 {
            font-family: 'Cinzel', serif;
            font-size: 36px;
            color: white;
            text-shadow: 0 0 15px var(--accent-blue);
        }

        .upgrade-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            max-width: 380px; /* Constrain width for a cleaner look */
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
        }
        .shop-item-info { text-align: left; }
        .shop-item-info h3 { margin: 0; font-size: 18px; font-weight: 500; }
        .shop-item-info p { margin: 4px 0 0; font-size: 14px; color: var(--text-secondary); text-align: left; text-shadow: none; }

        .cost-text { color: var(--accent-gold); }

        .gold-display {
            position: absolute;
            top: 25px;
            right: 25px;
            font-size: 20px;
            font-weight: bold;
            color: var(--accent-gold);
            background: rgba(0,0,0,0.5);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid var(--border-color);
        }

        .shop-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            background: linear-gradient(180deg, transparent, rgba(13,17,23,0.8) 50%);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* --- END SHOP STYLES --- */

        #game-over-screen h2 { color: var(--accent-red); }
        .stats-container, .skills-container { width: 85%; }
        .skills-container h2 { font-size: 24px; margin-top: 10px; margin-bottom: 10px; }
        .stat-block, .skill-block { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; margin-bottom: 10px; }
        .stat-header, .skill-header { display: flex; justify-content: space-between; align-items: baseline; }
        .stat-header h3, .skill-header h3 { margin: 0; font-size: 18px; color: var(--accent-blue); }
        .stat-header span, .skill-header span { font-size: 14px; color: var(--text-secondary); }
        .stat-value { font-size: 22px; color: var(--text-primary); margin: 5px 0; }
        .progress-bar-container { width: 100%; height: 8px; background-color: #333; border-radius: 4px; overflow: hidden; margin-top: 8px; }
        .progress-bar-fill { height: 100%; border-radius: 4px; transition: width 0.3s ease; }
        .progress-bar-fill.health { background-color: var(--accent-red); } 
        .progress-bar-fill.attack { background-color: #f77f00; } 
        .progress-bar-fill.rage { background-color: var(--accent-purple); } 
        .progress-bar-fill.regen { background-color: var(--accent-green); } 
        .progress-bar-fill.skill { background-color: var(--accent-blue); }
        .skill-block p { font-size: 14px; color: var(--text-secondary); text-align: left; margin: 5px 0 0; }
        .skill-block.locked { opacity: 0.5; } .skill-block.locked h3 { color: #aaa; }
        #player-screen h3.level-up, #player-upgrade-screen h3.level-up { animation: level-up-flash 1s ease; }
        @keyframes level-up-flash { 0%, 100% { color: var(--accent-blue); transform: scale(1); } 50% { color: var(--accent-gold); transform: scale(1.1); } }
        .battle-banner { position: absolute; top: 40%; left: 50%; transform: translateX(-50%); font-size: 48px; font-weight: bold; color: #fff; padding: 10px 30px; border-radius: 10px; z-index: 20; pointer-events: none; opacity: 0; }
        .stage-clear-banner { background: linear-gradient(90deg, #4CAF50, #2E7D32); text-shadow: 0 0 10px #fff; animation: ultimate-flash 2.5s ease-out forwards; }
        .ultimate-banner { background: linear-gradient(90deg, #f72585, #7209b7); text-shadow: 0 0 10px #fff; animation: ultimate-flash 1.5s ease-out forwards; }
        @keyframes ultimate-flash { 0% { transform: translateX(-50%) scale(0.5); opacity: 0; } 50% { transform: translateX(-50%) scale(1.1); opacity: 1; } 80% { transform: translateX(-50%) scale(1); opacity: 1; } 100% { transform: translateX(-50%) scale(1); opacity: 0; } }

        .combat-button {
            position: absolute;
            padding: 10px;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            line-height: 1;
            font-size: 20px;
            z-index: 5;
        }
        #ult-button { left: 10px; bottom: 10px; background: #5a1835; border-color: #f72585; }
        #auto-battle-button { right: 10px; bottom: 10px; background: #555; border-color: #888; }
        #auto-battle-button.active { background: linear-gradient(45deg, #4CAF50, #2E7D32); border-color: #81C784; }
        #ult-button.is-flashing { animation: flash-effect 0.8s infinite; border: 2px solid #ffd700; }
        @keyframes flash-effect { 0%, 100% { filter: brightness(1); box-shadow: 0 4px 15px rgba(247, 37, 133, 0.4); } 50% { filter: brightness(1.8); box-shadow: 0 6px 30px rgba(247, 37, 133, 0.9); } }
   
        /* --- OFFLINE REWARDS START --- */
        #offline-rewards-list {
            list-style: none;
            padding: 0;
            margin: 15px 0 25px 0;
            text-align: left;
            font-size: 18px;
        }
        #offline-rewards-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        #offline-rewards-list i {
            width: 25px;
            margin-right: 12px;
            text-align: center;
            color: var(--accent-blue);
        }
        #offline-rewards-list .icon-gold { color: var(--accent-gold); }
        #offline-rewards-list .icon-xp { color: var(--accent-purple); }
        #offline-rewards-list .icon-stone { color: #c0c0c0; }
        #offline-rewards-list small {
            font-size: 14px;
            color: var(--text-secondary);
            margin-left: 8px;
        }
        /* --- OFFLINE REWARDS END --- */

    </style>
</head>
<body>
    <audio id="bg-music" loop>
    <source src="music.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <div id="boot-screen" class="screen-container">
        <div class="boot-content">
            <h1 id="boot-title">EternalImmortal</h1>
            <div id="boot-progress-container">
                <div id="boot-progress-bar"></div>
            </div>
            <button id="start-game-button" class="button">Start Game</button>
        </div>
    </div>

    <!-- NEW TOP BAR UI STRUCTURE -->
    <div id="top-bar-container" class="hidden">
        <!-- Player Info (Avatar, Level, XP) -->
        <div id="player-info-bar">
            <div id="player-avatar">
                <i class="fas fa-user-shield"></i>
                <div id="player-level-badge">1</div>
            </div>
            <div id="xp-bar-wrapper">
                 <div id="xp-bar-fill"></div>
                 <div id="xp-text">0 / 100 XP</div>
            </div>
        </div>

        <!-- Resources Group -->
        <div id="player-resources-group">
            <div class="resource-item" id="player-gold-display">
                <i class="fas fa-coins" style="color: #f9c74f;"></i>
                <span id="player-gold-total">0</span>
            </div>
            <div class="resource-item" id="player-rubies-display">
                <i class="fas fa-gem icon-ruby"></i>
                <span id="player-rubies-total">0</span>
            </div>
            <div class="resource-item" id="player-energy-display">
                <i class="fas fa-bolt" style="color: #6efcff;"></i>
                <span id="player-energy-total">85/85</span>
            </div>
        </div>
    </div>
    <!-- END OF NEW UI STRUCTURE -->

    <div id="main-screen" class="screen-container hidden">
        <div id="dungeons-button" class="world-button">
            <div class="icon"><i class="fas fa-dungeon"></i></div>
            <div class="label">Dungeons</div>
        </div>
        <div id="exploration-button" class="world-button">
            <div class="icon"><i class="fas fa-compass"></i></div>
            <div class="label">Exploration</div>
        </div>
        <div id="station-button" class="world-button">
            <div class="icon"><i class="fas fa-hammer"></i></div>
            <div class="label">Player Station</div>
        </div>
        <div id="inventory-button" class="world-button">
            <div class="icon"><i class="fas fa-briefcase"></i></div>
            <div class="label">Inventory</div>
        </div>
    </div>
    <div id="player-upgrade-screen" class="ui-panel scrollable-panel hidden">
         <h1>Player Station</h1>
         <p class="subtitle">Hone your skills and forge your power.</p>
         <div class="gold-display">ðŸ’° <span id="upgrade-gold-total">0</span></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-attack-title">Attack Power</h3><p>Current: <span id="upgrade-screen-attack-power-stat">10</span></p></div><div class="button" id="upgrade-screen-attack-button">Upgrade (<span class="cost-text" id="upgrade-screen-attack-cost">10</span>)</div></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-health-title">Max Health</h3><p>Current: <span id="upgrade-screen-max-health-stat">100</span></p></div><div class="button" id="upgrade-screen-health-button">Upgrade (<span class="cost-text" id="upgrade-screen-health-cost">10</span>)</div></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-rage-title">Rage Gain</h3><p>Current: <span id="upgrade-screen-rage-gain-stat">5</span></p></div><div class="button" id="upgrade-screen-rage-button">Upgrade (<span class="cost-text" id="upgrade-screen-rage-cost">20</span>)</div></div>
         <div class="shop-item"><div class="shop-item-info"><h3 id="upgrade-screen-regen-title">Health Regen</h3><p>Current: <span id="upgrade-screen-health-regen-stat">0</span>/s</p></div><div class="button" id="upgrade-screen-regen-button">Upgrade (<span class="cost-text" id="upgrade-screen-regen-cost">30</span>)</div></div>
         <div id="upgrade-screen-back-button" class="button small" style="margin-top: 30px;">Back to World</div>
    </div>
    <div id="map-screen" class="screen-container hidden">
        <canvas id="map-background-canvas"></canvas>
        <div id="map-scroll-area">
            <div id="map-content">
                <svg id="path-svg"></svg>
            </div>
        </div>
        <div id="map-button-container">
            <button id="map-back-button" class="button small">Back to World</button>
            <button id="global-reset-button" class="button small danger">Reset</button>
        </div>
    </div>
    <div id="details-modal" class="modal-overlay">
        <div class="modal-content"><i class="fas fa-times close-button" onclick="hideModal()"></i><h3 class="dungeon-title" id="modal-title">Dungeon Name</h3><p class="dungeon-mode" id="modal-mode">Challenge Mode</p><div class="boss-section"><div class="boss-portrait" id="modal-boss-icon"></div><div class="boss-info"><h4 id="modal-boss-name">Boss Name</h4><p>Level <span id="modal-boss-level">10</span></p></div></div><div class="rewards-section"><h4>Potential Rewards</h4><div class="rewards-grid" id="modal-rewards"></div></div><div id="modal-start-button" class="start-button">Start</div></div>
    </div>
    <div id="locked-modal" class="modal-overlay">
        <div class="modal-content"><i class="fas fa-times close-button" onclick="hideModal()"></i><p>This dungeon is LOCKED. Unlock it by completing previous dungeons first!</p></div>
    </div>
    <div id="game-container" class="screen-container hidden">
        <canvas id="game-canvas"></canvas>
        <canvas id="ui-canvas"></canvas>
        <div id="shop-screen" class="ui-panel panel-hidden">
            <div class="shop-content-wrapper">
                <h1 id="shop-title">Stage Cleared!</h1>
                <p class="subtitle" id="shop-subtitle">You are victorious. Claim your rewards.</p>
                
                <div id="loot-summary" class="hidden"></div>
                
                <div class="upgrade-list">
                    <div class="shop-item">
                        <div class="shop-item-info">
                            <h3>Attack Power</h3>
                            <p>Current: <span id="attack-power-stat">10</span></p>
                        </div>
                        <div class="button" id="upgrade-attack-button">Upgrade (<span class="cost-text" id="attack-cost">10</span>)</div>
                    </div>
                    <div class="shop-item">
                        <div class="shop-item-info">
                            <h3>Max Health</h3>
                            <p>Current: <span id="max-health-stat">100</span></p>
                        </div>
                        <div class="button" id="upgrade-health-button">Upgrade (<span class="cost-text" id="health-cost">10</span>)</div>
                    </div>
                    <div class="shop-item">
                        <div class="shop-item-info">
                            <h3>Rage Gain</h3>
                            <p>Current: <span id="rage-gain-stat">5</span></p>
                        </div>
                        <div class="button" id="upgrade-rage-button">Upgrade (<span class="cost-text" id="rage-cost">20</span>)</div>
                    </div>
                    <div class="shop-item">
                        <div class="shop-item-info">
                            <h3>Health Regen</h3>
                            <p>Current: <span id="health-regen-stat">0</span>/s</p>
                        </div>
                        <div class="button" id="upgrade-regen-button">Upgrade (<span class="cost-text" id="regen-cost">30</span>)</div>
                    </div>
                </div>
            </div>
            <div class="shop-footer">
                <div id="player-stats-button" class="button small">Player Stats</div>
                <div id="proceed-button" class="button primary">Next Stage</div>
            </div>
            <div class="gold-display">ðŸ’° <span id="gold-total">0</span></div>
        </div>
        <div id="game-over-screen" class="ui-panel panel-hidden"><h1>Defeated!</h1><h2 id="game-over-message">You reached Stage <span id="final-stage-reached">1</span></h2><div id="retry-button" class="button">Try Again</div></div>
        <div id="player-screen" class="ui-panel scrollable-panel panel-hidden"><h1>SoulCraft</h1><div class="stats-container"></div><div class="skills-container"></div><div id="player-screen-back-button" class="button small">Back to Shop</div></div>
        <div id="battle-event-banner" class="battle-banner"></div>
        <div id="ult-button" class="button combat-button panel-hidden">RAGE</div>
        <div id="auto-battle-button" class="button combat-button panel-hidden">AUTO</div>
    </div>
    <div id="exploration-container" class="screen-container hidden">
        <canvas id="exploration-canvas"></canvas>
        <div id="exploration-exit-button" class="button small danger">Exit</div>
    </div>
    <div id="inventory-modal" class="modal-overlay">
        <div class="modal-content" style="width: 95%; max-width: 420px; height: 80%;">
            <i class="fas fa-times close-button" id="inventory-close-button"></i>
            
            <div class="inventory-tabs">
                <button id="weapons-tab-btn" class="inventory-tab-btn active">Weapons</button>
                <button id="stones-tab-btn" class="inventory-tab-btn">Stones</button>
                <button id="souls-tab-btn" class="inventory-tab-btn">Souls</button>
            </div>

            <div class="inventory-panels">
                <!-- WEAPONS PANEL -->
                <div id="weapons-panel" class="inventory-panel active">
                    <h3>Equipped Weapon</h3>
                    <div id="equipped-weapon-card" class="shop-item" style="flex-direction: column; align-items: stretch;">
                        <!-- Content will be generated by JS -->
                    </div>
                </div>

                <!-- STONES PANEL -->
                <div id="stones-panel" class="inventory-panel">
                    <div id="stones-grid" style="max-height: 400px; overflow-y: auto; padding: 5px;">
                        <!-- Stones will be grouped and added here by JS -->
                    </div>
                </div>

                <!-- SOULS PANEL -->
                <div id="souls-panel" class="inventory-panel">
                    <h3>Soul Core</h3>
                    <p>Absorb souls to empower your essence, boosting all stats permanently.</p>
                    <p>Level: <span id="soul-level">1</span></p>
                    <div class="progress-bar-container"><div id="soul-progress-bar" class="progress-bar-fill rage"></div></div>
                    <p><span id="soul-current">0</span> / <span id="soul-target">500</span> Souls</p>
                    <p>Current Boost: +<span id="soul-boost">0</span>% to all stats.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- --- OFFLINE REWARDS START --- -->
    <div id="offline-rewards-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="dungeon-title">Welcome Back!</h3>
            <p class="dungeon-mode" id="offline-time-info">You were away for a while...</p>
            <ul id="offline-rewards-list">
                <!-- Rewards will be populated by JS -->
            </ul>
            <div id="claim-offline-rewards-button" class="start-button">Claim Rewards</div>
        </div>
    </div>
    <!-- --- OFFLINE REWARDS END --- -->

<script>
    const inventoryModal = document.getElementById('inventory-modal');
    const inventoryButton = document.getElementById('inventory-button');
    const inventoryCloseButton = document.getElementById('inventory-close-button');
    const tabButtons = {
        weapons: document.getElementById('weapons-tab-btn'),
        stones: document.getElementById('stones-tab-btn'),
        souls: document.getElementById('souls-tab-btn')
    };
    const panels = {
        weapons: document.getElementById('weapons-panel'),
        stones: document.getElementById('stones-panel'),
        souls: document.getElementById('souls-panel')
    };
    const bootScreen = document.getElementById('boot-screen');
    const bootProgressBar = document.getElementById('boot-progress-bar');
    const startGameButton = document.getElementById('start-game-button');
    const mainScreen = document.getElementById('main-screen');
    const playerUpgradeScreen = document.getElementById('player-upgrade-screen');
    const mapScreen = document.getElementById('map-screen');
    const gameContainer = document.getElementById('game-container');
    const explorationContainer = document.getElementById('exploration-container');
    const detailsModal = document.getElementById('details-modal');
    const lockedModal = document.getElementById('locked-modal');
    
    const topBarContainer = document.getElementById('top-bar-container');
    const playerInfoBar = document.getElementById('player-info-bar');
    const playerLevelBadgeUI = document.getElementById('player-level-badge');
    const xpBarFillUI = document.getElementById('xp-bar-fill');
    const xpTextUI = document.getElementById('xp-text');
    const playerGoldTotalUI = document.getElementById('player-gold-total');
    const playerRubiesTotalUI = document.getElementById('player-rubies-total');
    const playerEnergyTotalUI = document.getElementById('player-energy-total');
    
    const SAVE_KEY = 'endlessShapesSaveData';
    const DUNGEON_SAVE_KEY = 'endlessShapesDungeonProgress';
    let currentDungeon = null;
    let playerProgress = { completed: [] };
    const GEN_DATA = {
        nameParts1: ["Tomb", "Crypt", "Cave", "Den", "Lair", "Dungeon", "Fortress", "Catacomb", "Hall", "Spire", "Pits"],
        nameParts2: ["of the", "of", "beneath the", "in the"],
        nameParts3: ["Sorrow", "Lost King", "Fallen", "Dread", "Screaming", "Whispering", "Ancient", "Forgotten", "Gloom", "Abyss"],
        icons: ['fa-chess-rook', 'fa-cross', 'fa-fort-awesome', 'fa-skull', 'fa-spider', 'fa-dragon', 'fa-mountain', 'fa-tree', 'fa-ankh'],
        bossIcons: ['fa-ghost', 'fa-skull-crossbones', 'fa-robot', 'fa-hat-wizard', 'fa-pastafarianism', 'fa-user-secret', 'fa-user-ninja'],
        bossNames1: ["Grave Lord", "Dread Knight", "Soul Eater", "Chaos Bringer", "Abyssal", "Mad", "Ironclad"],
        bossNames2: ["Zarthus", "Malakor", "Shana", "Harven", "Grolnok", "Vexia", "Mortis"]
    };

    function showScreen(screenName) {
        const screens = {
            'boot': bootScreen,
            'main': mainScreen,
            'player-upgrade': playerUpgradeScreen,
            'map': mapScreen,
            'battle': gameContainer,
            'exploration': explorationContainer
        };

        const nextScreen = screens[screenName];
        if (!nextScreen) {
            console.error("Screen not found:", screenName);
            return;
        }

        let currentScreen = Object.values(screens).find(s => !s.classList.contains('hidden'));

        if (currentScreen && currentScreen !== nextScreen) {
            currentScreen.classList.add('hidden');
        }
        
        topBarContainer.classList.toggle('hidden', screenName === 'boot');
        uiParticles = [];

        if (screenName === 'main') {
            createMainScreenParticles();
        } else if (screenName === 'player-upgrade') {
            initGame(false, true);
            updatePlayerUpgradeScreenUI();
        } else if (screenName === 'map') {
            initializeMap();
        } else if (screenName === 'battle') {
            initGame();
            changeState('COUNTDOWN');
        } else if (screenName === 'exploration') {
            initGame(false, true);
            initExplorationMode();
        }

        if (nextScreen.classList.contains('hidden')) {
            nextScreen.classList.remove('hidden');
        }
    }

    function createMainScreenParticles() {
        const dungeonsButton = document.getElementById('dungeons-button');
        if (!dungeonsButton) return;
        const rect = dungeonsButton.getBoundingClientRect();
        const containerRect = mainScreen.getBoundingClientRect();
        uiParticles.push({ type: 'sparkleGenerator', x: rect.left - containerRect.left, y: rect.top - containerRect.top, width: rect.width, height: rect.height, spawnRate: 0.2, color: 'rgba(110, 252, 255, 0.7)' });
    }

    function updatePlayerUpgradeScreenUI() {
        if (!player) return;
        document.getElementById('upgrade-gold-total').textContent = `${player.gold}`;
        const weaponDmg = player.inventory.weapon.power;
        const statDmg = player.stats.attackPower.current;
        const totalDmg = weaponDmg + statDmg;
        document.getElementById('upgrade-screen-attack-title').textContent = 'Base Damage';
        document.getElementById('upgrade-screen-attack-power-stat').innerHTML = `${totalDmg} <small 
        style="color:#ccc;">(Wpn: ${weaponDmg} + Stat: ${statDmg})</small>`;
        document.getElementById('upgrade-screen-max-health-stat').textContent = player.stats.maxHp.current;
        document.getElementById('upgrade-screen-rage-gain-stat').textContent = player.stats.rageGain.current;
        document.getElementById('upgrade-screen-health-regen-stat').textContent = player.stats.healthRegen.current.toFixed(1);
        document.getElementById('upgrade-screen-attack-cost').textContent = player.costs.attackPower;
        document.getElementById('upgrade-screen-health-cost').textContent = player.costs.maxHp;
        document.getElementById('upgrade-screen-rage-cost').textContent = player.costs.rageGain;
        document.getElementById('upgrade-screen-regen-cost').textContent = player.costs.healthRegen;
        document.getElementById('upgrade-screen-attack-button').classList.toggle('disabled', player.gold < player.costs.attackPower);
        document.getElementById('upgrade-screen-health-button').classList.toggle('disabled', player.gold < player.costs.maxHp);
        document.getElementById('upgrade-screen-rage-button').classList.toggle('disabled', player.gold < player.costs.rageGain);
        document.getElementById('upgrade-screen-regen-button').classList.toggle('disabled', player.gold < player.costs.healthRegen);
    }
    
    function loadProgress() { const saved = localStorage.getItem(DUNGEON_SAVE_KEY); if (saved) playerProgress = JSON.parse(saved); }
    function saveProgress() { localStorage.setItem(DUNGEON_SAVE_KEY, JSON.stringify(playerProgress)); }
    function hideModal() { detailsModal.classList.remove('visible'); lockedModal.classList.remove('visible'); }
    function showDetailsModal(dungeonId) {
        const data = player.dungeonMap[dungeonId];
        document.getElementById('modal-title').textContent = data.name;
        document.getElementById('modal-mode').textContent = data.mode;
        document.getElementById('modal-boss-name').textContent = data.boss.name;
        document.getElementById('modal-boss-level').textContent = data.boss.level;
        document.getElementById('modal-boss-icon').innerHTML = `<i class="fas ${data.boss.icon}"></i>`;
        const rewardsGrid = document.getElementById('modal-rewards');
        rewardsGrid.innerHTML = '';
        data.rewards.forEach(reward => {
            let amountText = reward.amount;
            if(reward.name === 'Gold' || reward.name === 'Rubies') {
                 amountText = (reward.amount > 999) ? `x${(reward.amount/1000).toFixed(1)}k` : `x${reward.amount}`;
            }
            rewardsGrid.innerHTML += `<div class="reward-item"><i class="fas ${reward.icon} reward-icon"></i><span>${amountText}</span></div>`;
        });
        const startButton = document.getElementById('modal-start-button');
        startButton.onclick = () => {
            if (player.energy < 1) {
                alert("Not enough energy to start the dungeon!");
                return;
            }

            player.energy--;
            player.lastEnergyUpdateTime = Date.now();
            updatePlayerXpBar();
            saveGame();
            
            hideModal();
            setTimeout(() => {
                currentDungeon = data;
                delete currentDungeon.rewardGiven;
                showScreen('battle');
            }, 300);
        };
        detailsModal.classList.add('visible');
    }
    function drawPath() {
        const svg = document.getElementById('path-svg');
        let pathData = '';
        const mapContent = document.getElementById('map-content');
        Object.values(player.dungeonMap).forEach(parentDungeon => {
            if (parentDungeon.unlocks && parentDungeon.unlocks.length > 0) {
                 const startNode = mapContent.querySelector(`#${parentDungeon.id}`);
                 if (startNode) {
                    parentDungeon.unlocks.forEach(childId => {
                        const endNode = mapContent.querySelector(`#${childId}`);
                        if (endNode) {
                            const startX = startNode.offsetLeft + startNode.offsetWidth / 2;
                            const startY = startNode.offsetTop + startNode.offsetHeight / 2;
                            const endX = endNode.offsetLeft + endNode.offsetWidth / 2;
                            const endY = endNode.offsetTop + endNode.offsetHeight / 2;
                            pathData += `M${startX},${startY} L${endX},${endY} `;
                        }
                    });
                }
            }
        });
        svg.innerHTML = `<defs><linearGradient id="line-gradient" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:#6efcff;stop-opacity:0" /><stop offset="50%" style="stop-color:#6efcff;stop-opacity:1" /><stop offset="100%" style="stop-color:#6efcff;stop-opacity:0" /></linearGradient></defs><path d="${pathData}" />`;
    }
    function initializeMap() {
        loadProgress();
        const mapContent = document.getElementById('map-content');
        mapContent.innerHTML = '<svg id="path-svg"></svg>';
        let maxTop = 0;

        Object.values(player.dungeonMap).forEach(data => {
            const node = document.createElement('div');
            node.className = 'dungeon-node';
            node.id = data.id;
            node.style.top = `${data.position.top}px`;
            node.style.left = `${data.position.left}%`;
            node.style.transform = `translateX(-50%)`;
            
            node.innerHTML = `<div class="icon"><i class="fas ${data.icon}"></i></div><div class="name">${data.name}</div>`;

            const completionCount = data.completionCount || 0;
            const isCompleted = completionCount > 0;
            
            const unlockedByDungeon = player.dungeonMap[data.unlockedBy];
            const isUnlocked = data.isUnlockedByDefault || (data.unlockedBy && unlockedByDungeon && (unlockedByDungeon.completionCount || 0) > 0);

            if (isUnlocked) {
                node.classList.add('active');
            } else {
                node.classList.add('locked');
            }
            
            if (isCompleted) {
                node.classList.add('completed');
                const counterDiv = document.createElement('div');
                counterDiv.className = 'completion-counter';
                counterDiv.innerHTML = `<i class="fas fa-check"></i> ${completionCount}`;
                node.appendChild(counterDiv);
            }

            node.addEventListener('click', () => {
                if (isUnlocked) {
                    showDetailsModal(data.id);
                } else {
                    lockedModal.classList.add('visible');
                }
            });

            mapContent.appendChild(node);
            if (data.position.top > maxTop) {
                maxTop = data.position.top;
            }
        });

        mapContent.style.height = `${Math.max(800, maxTop + 200)}px`;
        document.getElementById('path-svg').style.height = mapContent.style.height;
        drawPath();
    }
    const canvas = document.getElementById('game-canvas');
    let ctx = canvas.getContext('2d');
    const uiCanvas = document.getElementById('ui-canvas'), uiCtx = uiCanvas.getContext('2d');
    const explorationCanvas = document.getElementById('exploration-canvas'), expCtx = explorationCanvas.getContext('2d');
    canvas.width = uiCanvas.width = explorationCanvas.width = 450;
    canvas.height = uiCanvas.height = explorationCanvas.height = 800;
    const dom = { shop:document.getElementById('shop-screen'), gameOver:document.getElementById('game-over-screen'), playerStats:document.getElementById('player-screen'), proceedBtn:document.getElementById('proceed-button'), retryBtn:document.getElementById('retry-button'), statsBtn:document.getElementById('player-stats-button'), backBtn:document.getElementById('player-screen-back-button'), battleBanner:document.getElementById('battle-event-banner'), goldDisplay:document.getElementById('gold-total'), upgradeBtns:{attack:document.getElementById('upgrade-attack-button'),health:document.getElementById('upgrade-health-button'),rage:document.getElementById('upgrade-rage-button'),regen:document.getElementById('upgrade-regen-button')}, ultBtn:document.getElementById('ult-button'), autoBtn:document.getElementById('auto-battle-button') };
    let gameState, currentStage, player, enemies, particles, floatingTexts, projectiles, healthOrbs, shakeDuration, isAutoBattle, endCombatTimer, uiParticles=[], skillVisuals=[], countdownTimer;
    let lastRunLoot = { gold: 0, xp: 0, stones: [] };
    let explorationEnemies = [], explorationProjectiles = [], explorationBackgroundStars = [], explorationDifficulty = 1, explorationSpawnTimer = 0;
    const SKILLS_DATA={orbitalStrike:{name:"Orbital Strike",unlockStage:10,baseCooldown:300,cooldownReductionPerLevel:2,baseDamageMultiplier:.5,damageMultiplierPerLevel:.05,baseTargetXP:10},chainLightning:{name:"Chain Lightning",unlockStage:25,baseCooldown:240,cooldownReductionPerLevel:1.5,baseDamageMultiplier:.3,damageMultiplierPerLevel:.03,baseJumps:2,jumpsPerLevel:5,baseTargetXP:15},meteorShower:{name:"Meteor Shower",unlockStage:50,baseCooldown:400,cooldownReductionPerLevel:3,baseDamageMultiplier:.8,damageMultiplierPerLevel:.1,baseCount:5,countPerLevel:10,baseTargetXP:20}};
    function createStat(c){return{name:c.name,level:c.level||1,current:c.current||0,target:c.target||100,baseGain:c.baseGain||1,displaySuffix:c.displaySuffix||'',isFloat:c.isFloat||!1,color:c.color}}
    
    function updatePlayerXpBar() {
        if (!player) return;
        if (player.energy === undefined) player.energy = 85;
        if (player.maxEnergy === undefined) player.maxEnergy = 85;
        playerLevelBadgeUI.textContent = player.level;
        const xpPercentage = Math.min(100, (player.xp / player.xpToNextLevel) * 100);
        xpBarFillUI.style.width = `${xpPercentage}%`;
        xpTextUI.textContent = `${player.xp} / ${player.xpToNextLevel} XP`;
        playerGoldTotalUI.textContent = player.gold || 0;
        playerRubiesTotalUI.textContent = player.rubies || 0;
        playerEnergyTotalUI.textContent = `${player.energy}/${player.maxEnergy}`;
    }

    function levelUp() {
        SOUNDS.levelUp();
        player.level++;
        player.xp -= player.xpToNextLevel;
        player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
        playerInfoBar.style.animation = 'xp-level-up-flash 1s ease';
        setTimeout(() => { playerInfoBar.style.animation = ''; }, 1000);
        if (player.xp >= player.xpToNextLevel) { levelUp(); }
    }

    function gainXP(amount) {
        if (!player) return;
        const xpBonus = 1 + (player.inventory.weapon.xpBonus || 0);
        const finalAmount = Math.floor(amount * xpBonus);
        player.xp += finalAmount;
        lastRunLoot.xp += finalAmount;
        while (player.xp >= player.xpToNextLevel) { levelUp(); }
    }
    
    function generateDungeonName(usedNames = []) {
        const availableNameParts3 = GEN_DATA.nameParts3.filter(name => !usedNames.includes(name));
        const finalNameParts3 = availableNameParts3.length > 0 ? availableNameParts3 : GEN_DATA.nameParts3;
        const part1 = GEN_DATA.nameParts1[Math.floor(Math.random() * GEN_DATA.nameParts1.length)];
        const part2 = GEN_DATA.nameParts2[Math.floor(Math.random() * GEN_DATA.nameParts2.length)];
        const part3 = finalNameParts3[Math.floor(Math.random() * finalNameParts3.length)];
        return {
            name: `${part1} ${part2} ${part3}`,
            bossNamePart: part3
        };
    }
    function addNewDungeons(triggeringDungeonId) {
        let endOfChainNode = Object.values(player.dungeonMap).find(d => d.unlocks.length === 0);
        if (!endOfChainNode) {
            console.error("Could not find the end of the dungeon chain.");
            endOfChainNode = Object.values(player.dungeonMap).reduce((a, b) => a.position.top > b.position.top ? a : b);
            if (!endOfChainNode) return;
        }
        let lastDungeon = endOfChainNode;
        const depth = Object.keys(player.dungeonMap).length;

        let usedBossNames = Object.values(player.dungeonMap).map(d => {
            for (const part of GEN_DATA.nameParts3) {
                if (d.name.includes(part)) {
                    return part;
                }
            }
            return null;
        }).filter(name => name !== null);

        for (let i = 0; i < 2; i++) {
            const newDungeonId = `dungeon-${Date.now()}-${i}`;
            const bossLevel = 10 + depth + i;
            const newLeftPosition = (lastDungeon.position.left < 50) ? 70 + (Math.random() * 10 - 5) : 30 + (Math.random() * 10 - 5);
            const goldReward = Math.floor((bossLevel * 25) + 200 + Math.random() * 50);
            const rubyReward = Math.floor((bossLevel * 5) + 50 + Math.random() * 25);

            const generatedName = generateDungeonName(usedBossNames);
            usedBossNames.push(generatedName.bossNamePart);

            const newDungeon = {
                id: newDungeonId,
                name: generatedName.name,
                completionCount: 0,
                evolutionLevel: 0,
                position: { top: lastDungeon.position.top + 160 + (Math.random() * 30), left: newLeftPosition },
                icon: GEN_DATA.icons[Math.floor(Math.random() * GEN_DATA.icons.length)],
                unlockedBy: lastDungeon.id,
                unlocks: [],
                goldReward: goldReward,
                rubyReward: rubyReward,
                boss: {
                    name: `${GEN_DATA.bossNames1[Math.floor(Math.random() * GEN_DATA.bossNames1.length)]} ${GEN_DATA.bossNames2[Math.floor(Math.random() * GEN_DATA.bossNames2.length)]}`,
                    level: bossLevel,
                    icon: GEN_DATA.bossIcons[Math.floor(Math.random() * GEN_DATA.bossIcons.length)],
                    attack: Math.floor(10 + bossLevel * 2.5),
                    maxHp: Math.floor(500 + bossLevel * 80)
                },
                mode: 'Endless Challenge',
                rewards: [
                    { name: 'Gold', amount: goldReward, icon: 'fa-coins icon-gold' },
                    { name: 'Rubies', amount: rubyReward, icon: 'fa-gem icon-ruby' }
                ]
            };
            newDungeon.baseName = newDungeon.name;
            player.dungeonMap[newDungeonId] = newDungeon;
            lastDungeon.unlocks.push(newDungeonId);
            lastDungeon = newDungeon;
        }
    }

    let playerSprite = new Image();
    let playerSpriteLoaded = false;
    playerSprite.onload = () => {
        playerSpriteLoaded = true;
    };
    playerSprite.src = 'icon-192x192.PNG';

    function initGame(fromScratch=false, silent=false){
        if (!silent) gameState='LOADING';
        if (!player || fromScratch) {
            currentStage=1;
            player = {
                hp: 100,
                rage: 0,
                gold: 0,
                rubies: 0,
                energy: 85,
                maxEnergy: 85,
                lastEnergyUpdateTime: Date.now(),
                level: 1,
                xp: 0,
                xpToNextLevel: 100,
                dungeonCompletions: 0,
                dungeonMap: {},
                lastSaveTime: Date.now(),
                stats: {
                    maxHp: createStat({ name: "Max Health", current: 100, target: 500, baseGain: 20, color: 'health' }),
                    attackPower: createStat({ name: "Attack Power", current: 10, target: 100, baseGain: 2, color: 'attack' }),
                    rageGain: createStat({ name: "Rage Gain", current: 5, target: 50, baseGain: 1, color: 'rage' }),
                    healthRegen: createStat({ name: "Health Regen", current: 0, target: 10, baseGain: .5, isFloat: !0, displaySuffix: '/s', color: 'regen' }),
                    defense: createStat({ name: "Defense", current: 0, target: 100, baseGain: 1, color: 'skill' })
                },
                costs: { maxHp: 10, attackPower: 10, rageGain: 20, healthRegen: 30 },
                skills: {},
                x: canvas.width / 2,
                y: canvas.height - 150,
                baseY: canvas.height - 150,
                size: 60,
                weaponVisual: { angle: 0, animState: 'idle', animTimer: 0, target: null },
                flash: 0,
                inventory: {
                    weapon: { 
                        id: 'starter_bow', type: 'bow', tier: 0, name: 'Worn Bow', power: 5,
                        attackSpeedBonus: 0, critChance: 0, critDamage: 1.5, lifesteal: 0, statusEffect: null,
                        goldBonus: 0, xpBonus: 0, stoneFindBonus: 0, defense: 0
                    },
                    stones: [] 
                },
                souls: { level: 1, current: 0, toNextLevel: 500 }
            };
            Object.keys(SKILLS_DATA).forEach(id=>{player.skills[id]={isUnlocked:!1,cooldownTimer:0,level:1,currentXP:0,targetXP:SKILLS_DATA[id].baseTargetXP}});
            isAutoBattle=!1;
        }
        if(!fromScratch) loadGame();
        if (Object.keys(player.dungeonMap).length === 0) {
            let lastDungeon = null;
            const startingLeftPositions = [50, 30, 70];
            let usedBossNames = [];

            for (let i = 0; i < 3; i++) {
                const dungeonId = `starter-${i}`;
                const bossLevel = 5 + i * 2;
                const goldReward = Math.floor((bossLevel * 10) + 50 + Math.random() * 25);
                const generatedName = generateDungeonName(usedBossNames);
                usedBossNames.push(generatedName.bossNamePart);
                const dungeon = {
                    id: dungeonId,
                    name: generatedName.name,
                    completionCount: 0, evolutionLevel: 0,
                    isUnlockedByDefault: (i === 0),
                    unlockedBy: lastDungeon ? lastDungeon.id : null,
                    unlocks: [],
                    goldReward: goldReward,
                    position: { top: 100 + (i * 160), left: startingLeftPositions[i] + (Math.random() * 10 - 5) },
                    icon: GEN_DATA.icons[Math.floor(Math.random() * GEN_DATA.icons.length)],
                    boss: { name: 'Stone Guardian', level: bossLevel, icon: 'fa-ghost', attack: 10, maxHp: 500 },
                    mode: 'Standard',
                    rewards: [{ name: 'Gold', amount: goldReward, icon: 'fa-coins icon-gold' }]
                };
                dungeon.baseName = dungeon.name;
                player.dungeonMap[dungeon.id] = dungeon;
                if (lastDungeon) { lastDungeon.unlocks.push(dungeon.id); }
                lastDungeon = dungeon;
            }
        }
        if (!silent) {
            endCombatTimer=0;enemies=[];particles=[];floatingTexts=[];projectiles=[];healthOrbs=[];shakeDuration=0;uiParticles=[];skillVisuals=[];
            player.hp=player.stats.maxHp.current;
            if (!window.stars) { window.stars=[]; for(let i=0;i<100;i++)window.stars.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,radius:Math.random()*1.5,speed:.2+Math.random()*.5}); }
        }
    }
    
    function saveGame() {
        try {
            if(player) {
                player.lastSaveTime = Date.now();
                localStorage.setItem(SAVE_KEY, JSON.stringify({ player, currentStage, isAutoBattle }));
            }
        } catch (e) {
            console.error("Could not save game:", e)
        }
    }

    function loadGame() {
        try {
            const savedData = localStorage.getItem(SAVE_KEY);
            if (!savedData) return;
            const loaded = JSON.parse(savedData);
            if (!loaded.player || typeof loaded.player.stats.maxHp === "number" || !loaded.player.skills.orbitalStrike.level) {
                console.log("Old or invalid save detected, resetting player data.");
                return
            } else {
                player = loaded.player
            }
            
            if (player.flash === undefined) player.flash = 0;
            if (player.level === undefined) { player.level = 1; player.xp = 0; player.xpToNextLevel = 100 }
            if (player.rubies === undefined) player.rubies = 0;
            if (player.energy === undefined) { player.energy = 85; player.maxEnergy = 85; }
            if (player.lastEnergyUpdateTime === undefined) { player.lastEnergyUpdateTime = Date.now(); }
            if (player.lastSaveTime === undefined) { player.lastSaveTime = Date.now(); }
            if (player.inventory === undefined || !player.inventory.weapon) {
                player.inventory = {
                    weapon: { 
                        id: 'starter_bow', type: 'bow', tier: 0, name: 'Worn Bow', power: 5,
                        attackSpeedBonus: 0, critChance: 0, critDamage: 1.5, lifesteal: 0, statusEffect: null,
                        goldBonus: 0, xpBonus: 0, stoneFindBonus: 0, defense: 0
                    },
                    stones: []
                };
            }
             if (!player.inventory.weapon.critChance) { // Check if new stats are missing
                player.inventory.weapon = { ...player.inventory.weapon, attackSpeedBonus: 0, critChance: 0, critDamage: 1.5, lifesteal: 0, statusEffect: null, goldBonus: 0, xpBonus: 0, stoneFindBonus: 0, defense: 0 };
            }
            if (player.souls === undefined) {
                player.souls = { level: 1, current: 0, toNextLevel: 500 };
            }
            if (player.stats.defense === undefined) {
                player.stats.defense = createStat({ name: "Defense", current: 0, target: 100, baseGain: 1, color: 'skill' });
            }
            if (player.size === undefined) { player.size = 60; }
            if (player.weaponVisual === undefined || player.sword) {
                delete player.sword;
                player.weaponVisual = { angle: 0, animState: 'idle', animTimer: 0, target: null };
            }
            
            Object.values(player.dungeonMap).forEach(d => {
                if (d.completionCount === undefined) d.completionCount = 0;
                if (d.evolutionLevel === undefined) d.evolutionLevel = 0;
                if (!d.baseName) d.baseName = d.name;
            });

            currentStage = loaded.currentStage;
            isAutoBattle = loaded.isAutoBattle;

            updateEnergyReplenishment();
            calculateOfflineRewards();

        } catch (e) {
            console.error("Could not load save data, starting fresh.", e)
        }
    }
    function resetGame(){if(confirm("Are you sure you want to reset all progress? This cannot be undone.")){localStorage.removeItem(SAVE_KEY);localStorage.removeItem(DUNGEON_SAVE_KEY);playerProgress={completed:[]};player=null;location.reload();}}
    const audioCtx=new(window.AudioContext||window.webkitAudioContext);function playSound(f,t,d,v=.5){try{const o=audioCtx.createOscillator(),g=audioCtx.createGain();o.connect(g),g.connect(audioCtx.destination),o.type=t,o.frequency.setValueAtTime(f,audioCtx.currentTime),g.gain.setValueAtTime(v,audioCtx.currentTime),g.gain.exponentialRampToValueAtTime(1e-4,audioCtx.currentTime+d),o.start(),o.stop(audioCtx.currentTime+d)}catch(e){}}
    const SOUNDS={click:()=>playSound(440,"sine",.1,.3),playerAttack:()=>playSound(200,"square",.1,.2),enemyAttack:()=>playSound(150,"sawtooth",.1,.2),hit:()=>playSound(880,"triangle",.15,.5),enemyDeath:()=>playSound(100,"sawtooth",.4,.4),ultimate:()=>playSound(80,"sawtooth",.8,.7),upgrade:()=>playSound(600,"triangle",.2,.4),gameOver:()=>playSound(150,"sawtooth",.8,.5),stageClear:()=>playSound(783,"sine",.5),heal:()=>playSound(523,"triangle",.2,.4),levelUp:()=>playSound(900,"sawtooth",.3,.5)};
    function createExplosion(x,y,c,co,s=3,sp=5){const colors=["#fff","#ffd700","#ff8c00",co];for(let i=0;i<c;i++)particles.push({x,y,vx:(Math.random()-.5)*sp,vy:(Math.random()-.5)*sp,life:Math.random()*30+20,color:colors[Math.floor(Math.random()*colors.length)],size:Math.random()*s+1})}
    function addFloatingText(t,x,y,c){floatingTexts.push({text:t,x,y,life:60,color:c})}
    function triggerScreenShake(d){shakeDuration=d}
    function showBattleBanner(t,ty,d){dom.battleBanner.textContent=t;dom.battleBanner.className=`battle-banner ${ty}`;setTimeout(()=>{dom.battleBanner.className='battle-banner panel-hidden'},d)}
    
    function changeState(newState){
        Object.values(dom).forEach(el=>{if(el.classList&&el.classList.contains('ui-panel'))el.classList.add('panel-hidden')});
        dom.ultBtn.classList.add('panel-hidden');
        dom.autoBtn.classList.add('panel-hidden');
        uiParticles=[];
        gameState=newState;
        
        switch(newState){
            case'COUNTDOWN':
                lastRunLoot = { gold: 0, xp: 0, stones: [] };
                if(currentDungeon){
                    setupBossStage(currentDungeon);
                } else {
                    setupNextStage();
                }
                dom.ultBtn.classList.remove('panel-hidden');
                dom.autoBtn.classList.remove('panel-hidden');
                countdownTimer=180;
                playSound(500,"sine",0.1,0.3);
                break;
                
            case'COMBAT':
                dom.ultBtn.classList.remove('panel-hidden');
                dom.autoBtn.classList.remove('panel-hidden');
                break;

            case 'SHOP':
                const weapon = player.inventory.weapon;
                if (currentDungeon) {
                    if (!currentDungeon.rewardGiven) {
                        const goldBonus = 1 + (weapon.goldBonus || 0);
                        if (currentDungeon.goldReward) {
                            const goldGained = Math.floor(currentDungeon.goldReward * goldBonus);
                            player.gold += goldGained;
                            lastRunLoot.gold += goldGained;
                        }
                        if (currentDungeon.rubyReward) player.rubies += currentDungeon.rubyReward;
                        currentDungeon.rewardGiven = true;
                    }

                    const completedDungeon = player.dungeonMap[currentDungeon.id];
                    player.dungeonCompletions = (player.dungeonCompletions || 0) + 1;
                    completedDungeon.completionCount = (completedDungeon.completionCount || 0) + 1;
                    
                    const stoneFindChance = 1 + (weapon.stoneFindBonus || 0);
                    if (completedDungeon.completionCount > 0 && Math.random() < (1/5) * stoneFindChance) {
                        gainNewStone(completedDungeon); 
                    }

                    if (completedDungeon.completionCount > 0 && completedDungeon.completionCount % 3 === 0) {
                        completedDungeon.evolutionLevel = (completedDungeon.evolutionLevel || 0) + 1;
                        const evolutionPrefixes = ['Empowered', 'Dread', 'Nightmare', 'Infernal', 'Abyssal'];
                        const prefix = evolutionPrefixes[Math.min(completedDungeon.evolutionLevel - 1, evolutionPrefixes.length - 1)];
                        completedDungeon.name = `${prefix} ${completedDungeon.baseName}`;
                        completedDungeon.boss.level = Math.floor(completedDungeon.boss.level * 1.2);
                        completedDungeon.boss.maxHp = Math.floor(completedDungeon.boss.maxHp * 1.5);
                        completedDungeon.boss.attack = Math.floor(completedDungeon.boss.attack * 1.3);
                        completedDungeon.goldReward = Math.floor(completedDungeon.goldReward * 1.5);
                        if(completedDungeon.rubyReward) completedDungeon.rubyReward = Math.floor(completedDungeon.rubyReward * 1.4);
                        const goldRewardUI = completedDungeon.rewards.find(r => r.name === 'Gold');
                        if(goldRewardUI) goldRewardUI.amount = completedDungeon.goldReward;
                        const rubyRewardUI = completedDungeon.rewards.find(r => r.name === 'Rubies');
                        if(rubyRewardUI) rubyRewardUI.amount = completedDungeon.rubyReward;
                    }

                    if (player.dungeonCompletions > 0 && player.dungeonCompletions % 3 === 0) {
                        addNewDungeons(currentDungeon.id);
                    }
                }
                
                saveGame();
                checkSkillUnlocks();
                dom.shop.classList.remove('panel-hidden');
                updateShopUI();
                setTimeout(createShopParticles, 100);
                break;

            case'GAME_OVER':
                dom.gameOver.classList.remove('panel-hidden');
                updateGameOverUI();
                break;
                
            case'PLAYER_STATS':
                dom.playerStats.classList.remove('panel-hidden');
                updatePlayerScreenUI();
                setTimeout(createStatsScreenParticles,100);
                break;
                
            case'ENDING_COMBAT':
                player.isAttacking=!1;
                endCombatTimer=120;
                showBattleBanner('Victory!','stage-clear-banner',2500);
                SOUNDS.stageClear();
                break;
        }
    }
    function createShopParticles() { document.querySelectorAll('#shop-screen .button, .gold-display, #shop-screen h1').forEach(el => { if (el.tagName === 'H1' || el.classList.contains('gold-display')) { uiParticles.push({ type: 'sparkleGenerator', attachTo: el, spawnRate: .1 }); } else { for (let i = 0; i < 3; i++) { uiParticles.push({ type: 'orbit', attachTo: el, angle: Math.random() * Math.PI * 2, speed: .01 + Math.random() * .02, radius: 1 + Math.random(), color: '#ffd700' }); } } }); }
    function createStatsScreenParticles() { document.querySelectorAll('#player-screen .progress-bar-fill').forEach(el => { if (el.getBoundingClientRect().width > 0) { uiParticles.push({ type: 'sparkleGenerator', attachTo: el, spawnRate: el.getBoundingClientRect().width / 2000, color: el.classList.contains('health') ? '#e63946' : el.classList.contains('attack') ? '#fca311' : el.classList.contains('rage') ? '#9d4edd' : el.classList.contains('regen') ? '#52b788' : '#00b4d8' }); } }); }
    
    function setupBossStage(dungeon) {
        enemies = [];
        currentStage = dungeon.boss.level;
        const boss = dungeon.boss;
        enemies.push({
            x: canvas.width / 2,
            y: 150,
            baseY: 150,
            hp: boss.maxHp,
            maxHp: boss.maxHp,
            attack: boss.attack,
            radius: 50,
            color: "#e63946",
            attackCooldown: 90,
            attackTimer: 120,
            isAttacking: false,
            chargeTimer: 0,
            icon: boss.icon,
            statusEffects: []
        });
    }
    
    function setupNextStage(){
        enemies=[];
        const e=Math.min(2+Math.floor(currentStage/2),7),t=1+(currentStage-1)*.25,a=3+Math.floor(currentStage/3),s=Math.max(120-2*currentStage,45);
        for(let n=0;n<e;n++){
            const e=100+200*Math.random(),r=Math.floor((20+10*Math.random())*t);
            enemies.push({
                x:40+Math.random()*(canvas.width-80),y:e,baseY:e,hp:r,maxHp:r,attack:Math.floor(a+2*Math.random()),radius:20+5*Math.random(),color:"#e63946",attackCooldown:s+60*Math.random(),attackTimer:180*Math.random(),isAttacking:!1,chargeTimer:0, statusEffects: []
            })
        }
    }
    
    function updateShopUI() {
        if (currentDungeon) {
            document.getElementById('shop-title').textContent = `${currentDungeon.name} Cleared!`;
            document.getElementById('shop-subtitle').textContent = "You are victorious. Claim your rewards.";
            dom.proceedBtn.textContent = 'Return to Map';
        } else {
            document.getElementById('shop-title').textContent = `Stage ${currentStage} Cleared!`;
            document.getElementById('shop-subtitle').textContent = 'Spend Gold to grow stronger.';
            dom.proceedBtn.textContent = 'Next Stage';
        } 

        const lootSummaryDiv = document.getElementById('loot-summary');
        const summaryLines = [];
        if (lastRunLoot.gold > 0) {
            summaryLines.push(`<p><i class="fas fa-coins"></i>+${lastRunLoot.gold} Gold</p>`);
        }
        if (lastRunLoot.xp > 0) {
            summaryLines.push(`<p><i class="fas fa-star icon-xp"></i>+${lastRunLoot.xp} XP</p>`);
        }
        if (lastRunLoot.stones.length > 0) {
            lastRunLoot.stones.forEach(stone => {
                summaryLines.push(`<p><i class="fas fa-gem icon-stone"></i>Found 1x ${stone.name}</p>`);
            });
        }

        if(summaryLines.length > 0) {
            lootSummaryDiv.innerHTML = `<h4>Loot Found:</h4>${summaryLines.join('')}`;
            lootSummaryDiv.classList.remove('hidden');
        } else {
            lootSummaryDiv.classList.add('hidden');
        }

        dom.goldDisplay.textContent = `${player.gold}`;
        const weaponDmg = player.inventory.weapon.power;
        const statDmg = player.stats.attackPower.current;
        const totalDmg = weaponDmg + statDmg;
        document.getElementById('attack-power-stat').innerHTML = `${totalDmg} <small style="color:#ccc;">(Wpn: ${weaponDmg} + Stat: ${statDmg})</small>`;
        document.getElementById('max-health-stat').textContent=player.stats.maxHp.current;
        document.getElementById('rage-gain-stat').textContent=player.stats.rageGain.current;
        document.getElementById('health-regen-stat').textContent=player.stats.healthRegen.current.toFixed(1);
        document.getElementById('attack-cost').textContent=player.costs.attackPower;
        document.getElementById('health-cost').textContent=player.costs.maxHp;
        document.getElementById('rage-cost').textContent=player.costs.rageGain;
        document.getElementById('regen-cost').textContent=player.costs.healthRegen;
        dom.upgradeBtns.attack.classList.toggle('disabled',player.gold<player.costs.attackPower);
        dom.upgradeBtns.health.classList.toggle('disabled',player.gold<player.costs.maxHp);
        dom.upgradeBtns.rage.classList.toggle('disabled',player.gold<player.costs.rageGain);
        dom.upgradeBtns.regen.classList.toggle('disabled',player.gold<player.costs.healthRegen);
    }
    function updateGameOverUI() {if (currentDungeon) {document.getElementById('game-over-message').textContent = `Defeated by ${currentDungeon.boss.name}`;dom.retryBtn.textContent = "Return to Map";} else {document.getElementById('game-over-message').innerHTML = `You reached Stage <span id="final-stage-reached">${currentStage}</span>`;dom.retryBtn.textContent = "Try Again";}}
    function updatePlayerScreenUI(){const statsContainer=document.querySelector(".stats-container"),skillsContainer=document.querySelector(".skills-container");statsContainer.innerHTML="";skillsContainer.innerHTML='<h2>Skills</h2>';Object.values(player.stats).forEach(stat=>{const progress=stat.current/stat.target*100,block=document.createElement("div");block.className="stat-block",block.innerHTML=`<div class="stat-header"><h3 id="stat-title-${stat.color}">${stat.name}</h3><span>Level ${stat.level}</span></div><p class="stat-value">${stat.isFloat?stat.current.toFixed(1):stat.current} / ${stat.target}${stat.displaySuffix}</p><div class="progress-bar-container"><div id="progress-${stat.color}" class="progress-bar-fill ${stat.color}" style="width: ${Math.min(progress,100)}%;"></div></div>`,statsContainer.appendChild(block)});Object.keys(SKILLS_DATA).forEach(id=>{const skillData=SKILLS_DATA[id],playerSkill=player.skills[id],block=document.createElement("div");block.className="skill-block";if(playerSkill.isUnlocked){const progress=playerSkill.currentXP/playerSkill.targetXP*100;block.innerHTML=`<div class="skill-header"><h3 id="skill-title-${id}">${skillData.name}</h3><span>Level ${playerSkill.level}</span></div><p>${getSkillDescription(id)}</p><div class="progress-bar-container"><div class="progress-bar-fill skill" style="width: ${Math.min(progress,100)}%;"></div></div>`}else{block.classList.add("locked");block.innerHTML=`<h3>${skillData.name}</h3><p>Unlock by clearing Stage ${skillData.unlockStage}</p>`}skillsContainer.appendChild(block)})}
    
    function getSkillDescription(id) {
        const skillData = SKILLS_DATA[id],
            playerSkill = player.skills[id],
            level = playerSkill.level;
        
        const damage = Math.floor(
            (player.inventory.weapon.power + player.stats.attackPower.current) * 
            (skillData.baseDamageMultiplier + (level - 1) * skillData.damageMultiplierPerLevel)
        );

        switch (id) {
            case 'orbitalStrike':
                return `Launches an orb dealing ${damage} damage.`;
            case 'chainLightning':
                const jumps = SKILLS_DATA.chainLightning.baseJumps + Math.floor((level - 1) / skillData.jumpsPerLevel);
                return `Lightning hits ${jumps + 1} enemies for ${damage} damage.`;
            case 'meteorShower':
                const count = SKILLS_DATA.meteorShower.baseCount + Math.floor((level - 1) / SKILLS_DATA.meteorShower.countPerLevel);
                return `Calls down ${count} meteors that deal ${damage} damage.`
        }
        return "";
    }
    
    function updateEnergyReplenishment() {
        if (!player || player.energy >= player.maxEnergy) return;
        const REPLENISH_INTERVAL_MS = 2 * 60 * 1000;
        const now = Date.now();
        const elapsedMs = now - player.lastEnergyUpdateTime;
        if (elapsedMs >= REPLENISH_INTERVAL_MS) {
            const energyGained = Math.floor(elapsedMs / REPLENISH_INTERVAL_MS);
            if (energyGained > 0) {
                player.energy = Math.min(player.maxEnergy, player.energy + energyGained);
                player.lastEnergyUpdateTime += energyGained * REPLENISH_INTERVAL_MS;
                updatePlayerXpBar();
                saveGame();
            }
        }
    }
    
    function buyUpgrade(type, fromUpgradeScreen = false){
        if(player.gold < player.costs[type]) return;
        SOUNDS.upgrade();
        player.gold -= player.costs[type];
        player.costs[type] = Math.floor(1.15 * player.costs[type] + 5);
        const stat = player.stats[type];
        const oldCurrentStatValue = stat.current;
        stat.current += stat.baseGain;
        if (type === 'maxHp') {
            const hpGainedFromUpgrade = stat.current - oldCurrentStatValue;
            player.hp = Math.min(player.hp + hpGainedFromUpgrade, player.stats.maxHp.current);
        }
        if(stat.current >= stat.target){
            SOUNDS.levelUp();
            stat.level++;
            stat.target = Math.floor(1.8 * stat.target);
            stat.baseGain = stat.isFloat ? 1.4 * stat.baseGain : Math.ceil(1.5 * stat.baseGain);
            if (type === 'maxHp') {
                player.hp = Math.min(player.hp, player.stats.maxHp.current);
            }
            const titleSelector = fromUpgradeScreen ? `#upgrade-screen-${stat.color}-title` : `#stat-title-${stat.color}`;
            const title = document.querySelector(titleSelector);
            title && (title.classList.add("level-up"),setTimeout(() => title.classList.remove("level-up"), 1e3));
        }
        saveGame();
        if(fromUpgradeScreen){
            updatePlayerUpgradeScreenUI();
        }else{
            updateShopUI();
            if(gameState==="PLAYER_STATS")updatePlayerScreenUI();
        }
    }

    function showInventory() { updateInventoryUI(); inventoryModal.classList.add('visible'); }
    function hideInventory() { inventoryModal.classList.remove('visible'); }
    function switchInventoryTab(tabName) {
        Object.values(tabButtons).forEach(btn => btn.classList.remove('active'));
        Object.values(panels).forEach(panel => panel.classList.remove('active'));
        tabButtons[tabName].classList.add('active');
        panels[tabName].classList.add('active');
    }

    function updateInventoryUI() {
        const weapon = player.inventory.weapon;
        const weaponCard = document.getElementById('equipped-weapon-card');
        
        let statsHTML = `<ul class="weapon-stats-list">`;
        statsHTML += `<li><i class="fas fa-fist-raised" style="color:#f77f00;"></i><span class="stat-value">${weapon.power}</span><span class="stat-name">Power</span></li>`;
        if (weapon.defense > 0) statsHTML += `<li><i class="fas fa-shield-alt" style="color:#a0b8c8;"></i><span class="stat-value">${weapon.defense}</span><span class="stat-name">Defense</span></li>`;
        if (weapon.attackSpeedBonus > 0) statsHTML += `<li><i class="fas fa-bolt" style="color:#6efcff;"></i><span class="stat-value">+${(weapon.attackSpeedBonus * 100).toFixed(1)}%</span><span class="stat-name">Attack Speed</span></li>`;
        if (weapon.critChance > 0) statsHTML += `<li><i class="fas fa-crosshairs" style="color:#e63946;"></i><span class="stat-value">${(weapon.critChance * 100).toFixed(1)}%</span><span class="stat-name">Crit Chance</span></li>`;
        if (weapon.critDamage > 1.5) statsHTML += `<li><i class="fas fa-skull-crossbones" style="color:#e63946;"></i><span class="stat-value">${(weapon.critDamage * 100).toFixed(0)}%</span><span class="stat-name">Crit Damage</span></li>`;
        if (weapon.lifesteal > 0) statsHTML += `<li><i class="fas fa-heart" style="color:#ff4d6d;"></i><span class="stat-value">${(weapon.lifesteal * 100).toFixed(1)}%</span><span class="stat-name">Lifesteal</span></li>`;
        if (weapon.statusEffect) statsHTML += `<li><i class="fas ${weapon.statusEffect.type === 'poison' ? 'fa-skull' : 'fa-fire'}" style="color:#90be6d;"></i><span class="stat-value">${(weapon.statusEffect.chance * 100).toFixed(0)}%</span><span class="stat-name">${weapon.statusEffect.type.charAt(0).toUpperCase() + weapon.statusEffect.type.slice(1)}</span></li>`;
        if (weapon.goldBonus > 0) statsHTML += `<li><i class="fas fa-coins" style="color:#f9c74f;"></i><span class="stat-value">+${(weapon.goldBonus * 100).toFixed(0)}%</span><span class="stat-name">Gold Find</span></li>`;
        if (weapon.xpBonus > 0) statsHTML += `<li><i class="fas fa-star" style="color:#a371f7;"></i><span class="stat-value">+${(weapon.xpBonus * 100).toFixed(0)}%</span><span class="stat-name">XP Gain</span></li>`;
        if (weapon.stoneFindBonus > 0) statsHTML += `<li><i class="fas fa-gem" style="color:#c0c0c0;"></i><span class="stat-value">+${(weapon.stoneFindBonus * 100).toFixed(1)}%</span><span class="stat-name">Stone Find</span></li>`;
        statsHTML += `</ul>`;

        weaponCard.innerHTML = `
            <h4 id="weapon-name" style="margin-bottom: 5px;">${weapon.name}</h4>
            <p style="margin: 0; color: var(--text-secondary);">Type: <span id="weapon-type">${weapon.type.charAt(0).toUpperCase() + weapon.type.slice(1)}</span>, Tier: <span id="weapon-tier">${weapon.tier}</span></p>
            ${statsHTML}
        `;

        const stonesGrid = document.getElementById('stones-grid');
        stonesGrid.innerHTML = '';
        if (player.inventory.stones.length === 0) {
            stonesGrid.innerHTML = '<p>No stones collected. Clear dungeons to find some!</p>';
        } else {
            const groupedStones = {};
            player.inventory.stones.forEach(stone => {
                const key = `${stone.type}_${stone.tier}`;
                if (!groupedStones[key]) groupedStones[key] = { ...stone, count: 0 };
                groupedStones[key].count++;
            });

            Object.values(groupedStones).sort((a,b) => a.tier - b.tier || a.type.localeCompare(b.type)).forEach(group => {
                const itemEl = document.createElement('div');
                itemEl.className = 'shop-item';
                const canForgeStones = group.count >= 3 && group.tier < 50;
                const canForgeWeapon = group.tier >= 10;
                const forgeWeaponTooltipText = !canForgeWeapon ? "Requires a Tier 10+ stone to forge a weapon." : "";
                itemEl.innerHTML = `
                    <div class="shop-item-info"><h3>${group.name} (x${group.count})</h3></div>
                    <div>
                        <button class="button small forge-stone-btn" ${!canForgeStones ? 'disabled' : ''} data-type="${group.type}" data-tier="${group.tier}">Forge T${group.tier+1}</button>
                        <button class="button small forge-weapon-btn" ${!canForgeWeapon ? 'disabled' : ''} data-type="${group.type}" data-tier="${group.tier}" title="${forgeWeaponTooltipText}">Forge Weapon</button>
                    </div>`;
                stonesGrid.appendChild(itemEl);
            });
        }

        document.getElementById('soul-level').textContent = player.souls.level;
        document.getElementById('soul-current').textContent = player.souls.current;
        document.getElementById('soul-target').textContent = player.souls.toNextLevel;
        const soulProgress = Math.min(100, (player.souls.current / player.souls.toNextLevel) * 100);
        document.getElementById('soul-progress-bar').style.width = `${soulProgress}%`;
        document.getElementById('soul-boost').textContent = ((player.souls.level - 1) * 2).toFixed(0);
    }

    function forgeStones(type, tier) {
        tier = parseInt(tier);
        if (tier >= 50) { alert("This stone is at its maximum tier!"); return; }

        let removedCount = 0;
        for (let i = player.inventory.stones.length - 1; i >= 0; i--) {
            const stone = player.inventory.stones[i];
            if (stone.type === type && stone.tier === tier) {
                player.inventory.stones.splice(i, 1);
                removedCount++;
                if (removedCount === 3) break;
            }
        }

        const typeNames = { iron: 'IronStone', obsidian: 'ObsidianStone', jade: 'JadeStone' };
        const newStone = {
            id: `stone_${Date.now()}`, type: type, tier: tier + 1,
            name: `${typeNames[type]} T${tier + 1}`
        };
        player.inventory.stones.push(newStone);
        SOUNDS.upgrade();
        updateInventoryUI();
        saveGame();
    }

    function forgeNewWeapon(type, tier) {
        tier = parseInt(tier);
        const stoneIndex = player.inventory.stones.findIndex(s => s.type === type && s.tier === tier);
        if (stoneIndex === -1) return;
        player.inventory.stones.splice(stoneIndex, 1);

        const newWeapon = {
            id: `${type}_${Date.now()}`, tier: tier, power: 5 + (tier * 4),
            attackSpeedBonus: 0, critChance: 0, critDamage: 1.5, lifesteal: 0, statusEffect: null,
            goldBonus: 0, xpBonus: 0, stoneFindBonus: 0, defense: 0
        };

        switch(type) {
            case 'iron':
                newWeapon.type = 'sword'; newWeapon.name = `Iron Blade T${tier}`;
                newWeapon.power += tier * 2;
                newWeapon.critChance = 0.05 + (tier * 0.005);
                newWeapon.critDamage = 1.5 + (tier * 0.05);
                newWeapon.lifesteal = 0.01 + (tier * 0.002);
                break;
            case 'jade':
                newWeapon.type = 'bow'; newWeapon.name = `Jade Bow T${tier}`;
                newWeapon.attackSpeedBonus = 0.05 + (tier * 0.01);
                newWeapon.critChance = 0.02 + (tier * 0.003);
                newWeapon.statusEffect = { type: 'poison', chance: 0.10 + (tier * 0.01), damage: 2 + tier, duration: 3 };
                break;
            case 'obsidian':
                newWeapon.type = 'shield'; newWeapon.name = `Aegis T${tier}`;
                newWeapon.power = Math.floor(newWeapon.power * 0.5);
                newWeapon.defense = 5 + (tier * 2);
                newWeapon.goldBonus = 0.10 + (tier * 0.01);
                newWeapon.xpBonus = 0.10 + (tier * 0.01);
                newWeapon.stoneFindBonus = 0.01 + (tier * 0.005);
                break;
        }

        player.inventory.weapon = newWeapon;
        SOUNDS.stageClear();
        showBattleBanner(`Forged ${newWeapon.name}!`, 'ultimate-banner', 3000);
        updateInventoryUI();
        saveGame();
    }

    function checkSoulLevelUp() {
        while (player.souls.current >= player.souls.toNextLevel) {
            player.souls.current -= player.souls.toNextLevel;
            player.souls.level++;
            player.souls.toNextLevel = Math.floor(player.souls.toNextLevel * 1.8);
            Object.values(player.stats).forEach(stat => {
                stat.current = stat.isFloat ? parseFloat((stat.current * 1.05).toFixed(1)) : Math.floor(stat.current * 1.05);
            });
            player.hp = player.stats.maxHp.current;
            SOUNDS.levelUp();
            showBattleBanner('SOUL CORE EMPOWERED!', 'ultimate-banner', 2500);
        }
    }

    function gainNewStone(dungeon) {
        const stoneTypes = ['iron', 'obsidian', 'jade'];
        const typeNames = { iron: 'IronStone', obsidian: 'ObsidianStone', jade: 'JadeStone' };
        const tier = Math.max(1, Math.floor(dungeon.boss.level / 4));
        const type = stoneTypes[Math.floor(Math.random() * stoneTypes.length)];
        const newStone = { id: `stone_${Date.now()}`, type: type, tier: tier, name: `${typeNames[type]} T${tier}` };
        player.inventory.stones.push(newStone);
        lastRunLoot.stones.push(newStone);
        showBattleBanner(`Found ${newStone.name}!`, 'stage-clear-banner', 3000);
        saveGame();
    }

    function generateRandomStone() {
        const stoneTypes = ['iron', 'obsidian', 'jade'];
        const typeNames = { iron: 'IronStone', obsidian: 'ObsidianStone', jade: 'JadeStone' };
        const tier = Math.max(1, Math.floor(player.level / 5 + Math.random() * 2));
        const type = stoneTypes[Math.floor(Math.random() * stoneTypes.length)];
        return {
            id: `stone_offline_${Date.now()}_${Math.random()}`,
            type: type, tier: tier, name: `${typeNames[type]} T${tier}`
        };
    }
    
    function calculateOfflineRewards() {
        if (!player || !player.lastSaveTime) return;
        const MIN_OFFLINE_SECONDS = 30;
        const MAX_OFFLINE_SECONDS = 24 * 60 * 60;
        const KILLS_PER_SECOND = 1 / 5;
        const STONE_CHANCE_PER_KILL = 0.0006;
        const now = Date.now();
        let offlineSeconds = (now - player.lastSaveTime) / 1000;
        if (offlineSeconds < MIN_OFFLINE_SECONDS) return;
        const clampedSeconds = Math.min(offlineSeconds, MAX_OFFLINE_SECONDS);
        const totalKills = Math.floor(clampedSeconds * KILLS_PER_SECOND);
        if (totalKills <= 0) return;
        const rewards = { gold: 0, xp: 0, stones: [], timeFormatted: formatTime(clampedSeconds) };
        const xpPerKill = Math.max(1, player.level * 2);
        const goldPerKill = Math.max(1, player.level);
        for(let i = 0; i < totalKills; i++) {
            rewards.gold += goldPerKill;
            rewards.xp += xpPerKill;
            if(Math.random() < STONE_CHANCE_PER_KILL) rewards.stones.push(generateRandomStone());
        }
        showOfflineRewardsModal(rewards);
    }

    function showOfflineRewardsModal(rewards) {
        const modal = document.getElementById('offline-rewards-modal');
        const list = document.getElementById('offline-rewards-list');
        const timeInfo = document.getElementById('offline-time-info');
        const claimButton = document.getElementById('claim-offline-rewards-button');
        timeInfo.textContent = `While you were away for ${rewards.timeFormatted}, your hero explored the wilds:`;
        list.innerHTML = '';
        if (rewards.gold > 0) list.innerHTML += `<li><i class="fas fa-coins icon-gold"></i>+${rewards.gold.toLocaleString()} Gold</li>`;
        if (rewards.xp > 0) list.innerHTML += `<li><i class="fas fa-star icon-xp"></i>+${rewards.xp.toLocaleString()} XP</li>`;
        if (rewards.stones.length > 0) {
            const groupedStones = {};
            rewards.stones.forEach(stone => {
                if (!groupedStones[stone.name]) groupedStones[stone.name] = 0;
                groupedStones[stone.name]++;
            });
            for(const stoneName in groupedStones) list.innerHTML += `<li><i class="fas fa-gem icon-stone"></i>Found ${groupedStones[stoneName]}x ${stoneName}</li>`;
        }
        claimButton.onclick = () => {
            SOUNDS.stageClear();
            player.gold += rewards.gold;
            gainXP(rewards.xp);
            player.inventory.stones.push(...rewards.stones);
            updatePlayerXpBar();
            saveGame();
            modal.classList.remove('visible');
        };
        modal.classList.add('visible');
    }

    function formatTime(totalSeconds) {
        totalSeconds = Math.floor(totalSeconds);
        const hours = Math.floor(totalSeconds / 3600);
        totalSeconds %= 3600;
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        let result = "";
        if (hours > 0) result += `${hours}h `;
        if (minutes > 0) result += `${minutes}m `;
        if (hours === 0 && minutes < 30) result += `${seconds}s`;
        return result.trim();
    }
    
    function checkSkillUnlocks() {Object.keys(SKILLS_DATA).forEach(id => {const skillData = SKILLS_DATA[id], playerSkill = player.skills[id];if (!playerSkill.isUnlocked && currentStage > skillData.unlockStage) {playerSkill.isUnlocked = true;showBattleBanner(`${skillData.name} Unlocked!`, "ultimate-banner", 3000)}})}
    
    document.getElementById('dungeons-button').onclick = () => showScreen('map');
    document.getElementById('station-button').onclick = () => showScreen('player-upgrade');
    document.getElementById('exploration-button').onclick = () => showScreen('exploration');
    document.getElementById('map-back-button').onclick = () => showScreen('main');
    document.getElementById('upgrade-screen-back-button').onclick = () => showScreen('main');
    document.getElementById('exploration-exit-button').onclick = () => { saveGame(); showScreen('main'); };
    document.getElementById('global-reset-button').onclick = resetGame;
    document.getElementById('upgrade-screen-attack-button').onclick = () => buyUpgrade('attackPower', true);
    document.getElementById('upgrade-screen-health-button').onclick = () => buyUpgrade('maxHp', true);
    document.getElementById('upgrade-screen-rage-button').onclick = () => buyUpgrade('rageGain', true);
    document.getElementById('upgrade-screen-regen-button').onclick = () => buyUpgrade('healthRegen', true);
    dom.proceedBtn.onclick = () => { if (currentDungeon) { currentDungeon = null; showScreen('map'); } else { currentStage++; changeState('COUNTDOWN'); } };
    dom.retryBtn.onclick = () => {if(currentDungeon) {currentDungeon = null; showScreen('map');} else {player.hp=player.stats.maxHp.current;changeState('SHOP');}};
    dom.statsBtn.onclick=()=>changeState('PLAYER_STATS');
    dom.backBtn.onclick=()=>changeState('SHOP');
    dom.upgradeBtns.attack.onclick=()=>buyUpgrade('attackPower');dom.upgradeBtns.health.onclick=()=>buyUpgrade('maxHp');dom.upgradeBtns.rage.onclick=()=>buyUpgrade('rageGain');dom.upgradeBtns.regen.onclick=()=>buyUpgrade('healthRegen');
    dom.autoBtn.onclick=()=>{isAutoBattle=!isAutoBattle;dom.autoBtn.classList.toggle('active',isAutoBattle);};
    dom.ultBtn.onclick=()=>{
        if(gameState!=='COMBAT'||player.rage<100)return;
        player.rage=0;SOUNDS.ultimate();showBattleBanner('RAGE BURST!','ultimate-banner',1500);
        triggerScreenShake(20);
        enemies.forEach(e=>{
            const t = 5 * (player.inventory.weapon.power + player.stats.attackPower.current);
            e.hp-=t; createExplosion(e.x,e.y,40,'#f72585',5,10); addFloatingText(t,e.x,e.y,'#f72585');
        });
    };
    canvas.addEventListener('click',e=>{if(gameState!=='COMBAT')return;const t=canvas.getBoundingClientRect(),a=e.clientX-t.left,s=e.clientY-t.top;let n=null;enemies.forEach(e=>{Math.hypot(a-e.x,s-e.y)<e.radius&&(n=e)});isAutoBattle||playerAttack(n);healthOrbs.forEach((e,t)=>{if(Math.hypot(a-e.x,s-e.y)<e.radius){const a=Math.floor(.1*player.stats.maxHp.current);player.hp=Math.min(player.stats.maxHp.current,player.hp+a);addFloatingText(`+${a}`,player.x,player.y,'#4caf50');SOUNDS.heal();healthOrbs.splice(t,1);}});});
    inventoryButton.onclick = showInventory;
    inventoryCloseButton.onclick = hideInventory;
    tabButtons.weapons.onclick = () => switchInventoryTab('weapons');
    tabButtons.stones.onclick = () => switchInventoryTab('stones');
    tabButtons.souls.onclick = () => switchInventoryTab('souls');
    inventoryModal.addEventListener('click', function(event) {
        const target = event.target;
        if (target.classList.contains('forge-stone-btn')) forgeStones(target.dataset.type, target.dataset.tier);
        if (target.classList.contains('forge-weapon-btn')) if (confirm(`Forge a new T${target.dataset.tier} weapon? This will consume the stone.`)) forgeNewWeapon(target.dataset.type, target.dataset.tier);
    });

    function playerAttack(target) {
        if (!target || player.weaponVisual.animState !== 'idle') return;
        player.isAttacking = true;
        player.weaponVisual.animState = 'drawing';
        const speedMultiplier = 1 / (1 + (player.inventory.weapon.attackSpeedBonus || 0));
        player.weaponVisual.animTimer = 30 * speedMultiplier;
        player.weaponVisual.target = target;
        SOUNDS.playerAttack();
    }

    function updateSkills() {
        if (enemies.length === 0) return;
        Object.keys(player.skills).forEach(id => {
            const skill = player.skills[id];
            if (!skill.isUnlocked) return;
            skill.cooldownTimer++;
            const skillData = SKILLS_DATA[id];
            const cooldown = Math.max(30, skillData.baseCooldown - (skill.level - 1) * skillData.cooldownReductionPerLevel);
            if (skill.cooldownTimer > cooldown) {
                skill.cooldownTimer = 0; skill.currentXP++;
                if (skill.currentXP >= skill.targetXP) { skill.level++; skill.currentXP -= skill.targetXP; skill.targetXP = Math.floor(skill.targetXP * 1.5); SOUNDS.levelUp() }
                const damage = parseInt(getSkillDescription(id).match(/\d+/)[0]);
                const randomEnemy = enemies[Math.floor(Math.random() * enemies.length)];
                if (!randomEnemy) return;
                switch (id) {
                    case 'orbitalStrike':
                        skillVisuals.push({ type: 'orbitalStrike', x: player.x, y: player.y, target: randomEnemy, speed: 3, damage: damage, life: 300, maxLife: 300 });
                        break;
                    case 'chainLightning':
                        const jumps = SKILLS_DATA.chainLightning.baseJumps + Math.floor((skill.level - 1) / skillData.jumpsPerLevel);
                        let targets = [randomEnemy];
                        for (let i = 0; i < jumps; i++) {
                            const lastTarget = targets[targets.length - 1];
                            const potentialNext = enemies.filter(e => !targets.includes(e)).sort((a, b) => Math.hypot(a.x - lastTarget.x, a.y - lastTarget.y) - Math.hypot(b.x - lastTarget.x, b.y - lastTarget.y));
                            if (potentialNext.length > 0) targets.push(potentialNext[0])
                        }
                        targets.forEach(e => { e.hp -= damage; addFloatingText(damage, e.x, e.y, '#6efcff'); });
                        skillVisuals.push({ type: 'chainLightning', targets: targets, life: 60, maxLife: 60, damage: damage });
                        break;
                    case 'meteorShower':
                        const count = SKILLS_DATA.meteorShower.baseCount + Math.floor((skill.level - 1) / SKILLS_DATA.meteorShower.countPerLevel);
                        for (let i = 0; i < count; i++) skillVisuals.push({ type: 'meteor', x: Math.random() * canvas.width, y: -50 - (Math.random() * 200), targetY: 100 + Math.random() * (canvas.height / 2), speed: 8 + Math.random() * 4, damage: damage, life: 200, maxLife: 200 });
                        break
                }
            }
        })
    }
    
    function updateCountdown() { countdownTimer--; if(countdownTimer % 60 === 0 && countdownTimer > 0) { playSound(500, "sine", 0.1, 0.3); } if (countdownTimer <= 0) { changeState('COMBAT'); playSound(800, "sine", 0.1, 0.4); } }
    
    function updateCombat() {
        const barHeight = 18; const bottomPadding = 5;
        const ultButtonRect = dom.ultBtn.getBoundingClientRect();
        const containerRect = gameContainer.getBoundingClientRect();
        const buttonTopInCanvas = ultButtonRect.top - containerRect.top;
        const rageBarY = buttonTopInCanvas - barHeight - bottomPadding;
        const hpBarY = rageBarY - barHeight;
        const newPlayerY = hpBarY - (player.size / 2);
        player.y = newPlayerY; player.baseY = newPlayerY;

        updateWeaponAnimation();

        if (player.flash > 0) player.flash--;

        if (isAutoBattle && player.weaponVisual.animState === 'idle' && enemies.length > 0) {
            let e = enemies.reduce((e, t) => Math.hypot(e.x - player.x, e.y - player.y) < Math.hypot(t.x - player.x, t.y - player.y) ? e : t);
            playerAttack(e);
        }
        
        updateSkills();
        
        enemies.forEach(e => {
            e.attackTimer++;
            if (e.attackTimer >= e.attackCooldown && !e.isAttacking) { e.isAttacking = !0; e.chargeTimer = 30; }
            if (e.chargeTimer > 0) {
                e.chargeTimer--;
                if (e.chargeTimer <= 0) {
                    e.attackTimer = 0; SOUNDS.enemyAttack();
                    projectiles.push({ x: e.x, y: e.y, target: player, speed: 10, isPlayer: !1, damage: e.attack });
                }
            } else if (e.isAttacking) e.isAttacking = !1;
            if (e.flash > 0) e.flash--;
            if (e.statusEffects && e.statusEffects.length > 0) {
                e.statusEffects.forEach((status, index) => {
                    if (status.duration % 60 === 0) { e.hp -= status.damage; addFloatingText(status.damage, e.x, e.y + 20, '#90be6d'); }
                    status.duration--;
                    if (status.duration <= 0) e.statusEffects.splice(index, 1);
                });
            }
        });

        projectiles.forEach((e, t) => {
            if (!e.target || e.target.hp <= 0) { projectiles.splice(t, 1); return; }
            const a = e.target.x - e.x, s = e.target.y - e.y, n = Math.hypot(a, s);
            if (n < e.speed) {
                let finalDamage = e.damage;
                if (!e.isPlayer && e.target === player) {
                    const defensePower = player.inventory.weapon.defense || 0;
                    finalDamage = Math.max(1, e.damage - (player.stats.defense.current + defensePower));
                    player.flash = 5;
                }
                e.target.hp -= finalDamage;
                e.target.flash = 5;
                if(e.isPlayer) {
                    player.rage = Math.min(player.rage + player.stats.rageGain.current, 100);
                    if(e.lifestealAmount > 0) {
                        const healedAmount = Math.ceil(e.lifestealAmount);
                        player.hp = Math.min(player.stats.maxHp.current, player.hp + healedAmount);
                        addFloatingText(`+${healedAmount}`, player.x, player.y - 30, '#4caf50');
                    }
                }
                SOUNDS.hit();
                triggerScreenShake(e.isPlayer ? 5 : 8);
                createExplosion(e.target.x, e.target.y, 20, e.isPlayer ? "#fff" : "#ff4d4d");
                addFloatingText(finalDamage, e.target.x, e.y, e.isCrit ? "#ff4d4d" : "#ffd700");
                projectiles.splice(t, 1);
            } else { e.x += a / n * e.speed; e.y += s / n * e.speed; }
        });

        if (player.hp <= 0) return SOUNDS.gameOver(), void changeState("GAME_OVER");

        const deadEnemies = enemies.filter(e => e.hp <= 0);
        deadEnemies.forEach(e => {
            createExplosion(e.x, e.y, 50, e.color, 4, 8);
            SOUNDS.enemyDeath();
            if (!currentDungeon) {
                const goldBonus = 1 + (player.inventory.weapon.goldBonus || 0);
                const goldGained = Math.floor((1.5 * currentStage + 5) * goldBonus);
                player.gold += goldGained;
                lastRunLoot.gold += goldGained;
            }
            gainXP(5 * currentStage + Math.random() * 5);
            player.souls.current++;
            checkSoulLevelUp();
        });

        enemies = enemies.filter(e => e.hp > 0);
        if (enemies.length === 0 && gameState === "COMBAT") changeState("ENDING_COMBAT");
        if (Math.random() < .005 && healthOrbs.length < 3) healthOrbs.push({ x: 40 + Math.random() * (canvas.width - 80), y: 100 + 300 * Math.random(), radius: 12, life: 600, pulse: 0 });
    }
    
    function initExplorationMode() {
        explorationEnemies = []; projectiles = []; particles = []; floatingTexts = [];
        explorationDifficulty = 1; explorationSpawnTimer = 120;
        if (player) {
            player.hp = player.stats.maxHp.current; player.rage = 0;
            player.x = 100; player.y = explorationCanvas.height / 2;
            player.isAttacking = false;
        }
        if (explorationBackgroundStars.length === 0) for(let i=0; i<150; i++) explorationBackgroundStars.push({x: Math.random()*explorationCanvas.width, y: Math.random()*explorationCanvas.height, radius: Math.random()*2, speed: 0.5 + Math.random()*1.5});
    }
    
    function updateExplorationMode() {
        if (!player) return;
        
        updateWeaponAnimation();
        
        enemies = explorationEnemies;
        updateSkills();
        explorationEnemies = enemies;

        if (player.weaponVisual.animState === 'idle' && explorationEnemies.length > 0) {
            let target = explorationEnemies[0];
            if (target) playerAttack(target);
        }

        explorationBackgroundStars.forEach(star => { star.x -= star.speed; if (star.x < 0) { star.x = explorationCanvas.width; star.y = Math.random() * explorationCanvas.height; } });

        explorationSpawnTimer--;
        if (explorationSpawnTimer <= 0) {
            const enemyHp = Math.floor(50 * explorationDifficulty);
            const enemyAttack = Math.floor(5 * explorationDifficulty);
            explorationEnemies.push({
                x: explorationCanvas.width + 50, y: Math.random() * (explorationCanvas.height - 200) + 100,
                hp: enemyHp, maxHp: enemyHp, attack: enemyAttack, radius: 25,
                color: `hsl(${Math.random()*60+200}, 80%, 50%)`,
                attackCooldown: Math.max(45, 120 - explorationDifficulty), attackTimer: 0,
                xpValue: Math.floor(10 * explorationDifficulty)
            });
            explorationSpawnTimer = Math.max(30, 180 - explorationDifficulty * 5);
            explorationDifficulty += 0.1;
        }
        
        const battleLineX = player.x + 80;
        explorationEnemies.forEach(e => { if (e.x > battleLineX) e.x -= 2; });

        projectiles.forEach((p, i) => {
            if (!p.target || p.target.hp <= 0) { projectiles.splice(i, 1); return; }
            const dx = p.target.x - p.x, dy = p.target.y - p.y, dist = Math.hypot(dx, dy);
            if (dist < p.speed) {
                p.target.hp -= p.damage;
                SOUNDS.hit();
                addFloatingText(p.damage, p.target.x, p.target.y, p.isCrit ? "#ff4d4d" : "#ffd700");
                createExplosion(p.target.x, p.target.y, 20, '#fff');
                projectiles.splice(i, 1);
            } else { p.x += dx / dist * p.speed; p.y += dy / dist * p.speed; }
        });

        const dead = explorationEnemies.filter(e => e.hp <= 0);
        dead.forEach(e => {
            createExplosion(e.x, e.y, 50, e.color, 4, 8);
            SOUNDS.enemyDeath();
            gainXP(e.xpValue);
            const goldBonus = 1 + (player.inventory.weapon.goldBonus || 0);
            player.gold += Math.floor((e.xpValue / 2) * goldBonus);
            player.souls.current++;
            checkSoulLevelUp();
        });

        explorationEnemies = explorationEnemies.filter(e => e.hp > 0 && e.x > -50);
        particles = particles.filter(e => { e.x += e.vx; e.y += e.vy; e.life--; return e.life > 0 });
        floatingTexts = floatingTexts.filter(e => { e.y -= 1; e.life--; return e.life > 0 });
        skillVisuals = skillVisuals.filter(v => { v.life--; return v.life > 0; });
    }
    
    function update(){
        updatePlayerXpBar();
        updateUiParticles();
        if (!explorationContainer.classList.contains('hidden')) {
            updateExplorationMode();
        } else if (!gameContainer.classList.contains('hidden')) {
            if(gameState==='COUNTDOWN') updateCountdown(); 
            if(gameState==='COMBAT')updateCombat();
            if(gameState==='ENDING_COMBAT'){endCombatTimer--;if(endCombatTimer<=0){player.hp=Math.min(player.stats.maxHp.current,player.hp+Math.floor(.2*player.stats.maxHp.current));changeState('SHOP')}}
            if(player.hp<player.stats.maxHp.current&&player.stats.healthRegen.current>0&&(gameState==='COMBAT'||gameState==='ENDING_COMBAT'||gameState==='COUNTDOWN'))player.hp=Math.min(player.stats.maxHp.current,player.hp+player.stats.healthRegen.current/60);
            healthOrbs=healthOrbs.filter(e=>{e.life--;e.pulse+=.1;if(isAutoBattle){const t=player.x-e.x,a=player.y-e.y;if(Math.hypot(t,a)<player.size){const t=Math.floor(.1*player.stats.maxHp.current);return player.hp=Math.min(player.stats.maxHp.current,player.hp+t),addFloatingText(`+${t}`,player.x,player.y,"#4caf50"),SOUNDS.heal(),!1}e.x+=.03*t;e.y+=.03*a}return e.life>0});
            skillVisuals = skillVisuals.filter(v => { v.life--; return v.life > 0; });
            if(window.stars)window.stars.forEach(e=>{e.y+=e.speed;if(e.y>canvas.height){e.y=0;e.x=Math.random()*canvas.width}});
            particles=particles.filter(e=>{e.x+=e.vx;e.y+=e.vy;e.life--;return e.life>0});
            floatingTexts=floatingTexts.filter(e=>{e.y-=1;e.life--;return e.life>0});
        }
    }
    
    function updateUiParticles() {
        const newParticles = [];
        const container = !gameContainer.classList.contains('hidden') ? gameContainer : null;
        if (!container) { uiParticles = []; return; }
        const containerRect = container.getBoundingClientRect();
        uiParticles.forEach(p => {
            if (p.type === 'orbit') p.angle += p.speed;
            else if (p.type === 'sparkle') p.life--;
            else if (p.type === 'sparkleGenerator') {
                if (Math.random() < p.spawnRate) {
                    let spawnX, spawnY, spawnWidth, spawnHeight;
                    if (p.attachTo) {
                        const elRect = p.attachTo.getBoundingClientRect();
                        if (elRect.width <= 0) return;
                        spawnX = elRect.left - containerRect.left; spawnY = elRect.top - containerRect.top;
                        spawnWidth = elRect.width; spawnHeight = elRect.height;
                    } else { spawnX = p.x; spawnY = p.y; spawnWidth = p.width; spawnHeight = p.height; }
                    newParticles.push({ type: 'sparkle', x: spawnX + Math.random() * spawnWidth, y: spawnY + Math.random() * spawnHeight, life: 60, maxLife: 60, radius: Math.random() * 2, color: p.color || `rgba(255,220,150,${.5+Math.random()*.5})` });
                }
            }
        });
        uiParticles = uiParticles.filter(p => !(p.type === 'sparkle' && p.life <= 0));
        uiParticles.push(...newParticles);
    }

    function drawBossHealthBar() {
        if (enemies.length === 0) return;
        const totalCurrentHp = enemies.reduce((sum, enemy) => sum + Math.max(0, enemy.hp), 0);
        const totalMaxHp = enemies.reduce((sum, enemy) => sum + enemy.maxHp, 0);
        if (totalMaxHp === 0) return;
        const barWidth = canvas.width; const barHeight = 25; const barY = 50;
        ctx.fillStyle = 'rgba(50, 50, 50, 0.7)'; ctx.fillRect(0, barY, barWidth, barHeight);
        const healthPercentage = totalCurrentHp / totalMaxHp;
        ctx.fillStyle = '#c1121f'; ctx.fillRect(0, barY, barWidth * healthPercentage, barHeight);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)'; ctx.lineWidth = 2; ctx.strokeRect(0, barY, barWidth, barHeight);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 16px Cinzel'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
        ctx.fillText(`${Math.ceil(totalCurrentHp)} / ${totalMaxHp}`, barWidth / 2, barY + barHeight / 2);
        ctx.shadowBlur = 0;
    }

    function drawPlayerHudBars() {
        if (!player || dom.ultBtn.classList.contains('panel-hidden')) return;
        const barWidth = canvas.width; const barHeight = 18; const bottomPadding = 5;
        const ultButtonRect = dom.ultBtn.getBoundingClientRect();
        const containerRect = gameContainer.getBoundingClientRect();
        const buttonTopInCanvas = ultButtonRect.top - containerRect.top;
        const rageBarY = buttonTopInCanvas - barHeight - bottomPadding;
        const hpBarY = rageBarY - barHeight;
        ctx.fillStyle = '#333'; ctx.fillRect(0, hpBarY, barWidth, barHeight);
        const hpPercent = Math.max(0, player.hp / player.stats.maxHp.current);
        ctx.fillStyle = '#2a9d8f'; ctx.fillRect(0, hpBarY, barWidth * hpPercent, barHeight);
        ctx.fillStyle = '#554300'; ctx.fillRect(0, rageBarY, barWidth, barHeight);
        const ragePercent = player.rage / 100;
        ctx.fillStyle = '#ffd700'; ctx.fillRect(0, rageBarY, barWidth * ragePercent, barHeight);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 12px Roboto'; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
        ctx.shadowColor = 'black'; ctx.shadowBlur = 3;
        ctx.fillText(`HP: ${Math.ceil(player.hp)} / ${player.stats.maxHp.current}`, 10, hpBarY + barHeight / 2);
        ctx.fillText(`RAGE: ${player.rage} / 100`, 10, rageBarY + barHeight / 2);
        ctx.shadowBlur = 0;
    }

    function drawHud(){
        if(gameState!=='COMBAT' && gameState !== 'COUNTDOWN') return;
        ctx.save(); ctx.font='bold 24px Segoe UI'; ctx.shadowColor='black'; ctx.shadowBlur=5; ctx.fillStyle='white'; ctx.textAlign='left';
        let titleText = currentDungeon ? currentDungeon.name : `Stage: ${currentStage}`;
        const maxWidth = canvas.width - 140;
        if (ctx.measureText(titleText).width > maxWidth) {
            let truncatedText = titleText;
            while (ctx.measureText(truncatedText + '...').width > maxWidth && truncatedText.length > 0) truncatedText = truncatedText.slice(0, -1);
            titleText = truncatedText + '...';
        }
        ctx.fillText(titleText, 15, 35);
        ctx.textAlign='right'; ctx.fillStyle='#ffd700';
        ctx.fillText(`ðŸ’° ${player.gold}`,canvas.width-15,35);
        ctx.restore();
    }
    
    function drawUiParticles() {
        if (gameContainer.classList.contains('hidden') && mainScreen.classList.contains('hidden')) return;
        const activeContainer = gameContainer.classList.contains('hidden') ? mainScreen : gameContainer;
        uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
        const containerRect = activeContainer.getBoundingClientRect();
        uiParticles.forEach(p => {
            if (p.type === 'orbit' && p.attachTo) {
                const elRect = p.attachTo.getBoundingClientRect();
                if (elRect.bottom < containerRect.top || elRect.top > containerRect.bottom) return;
                const currentX = elRect.left - containerRect.left; const currentY = elRect.top - containerRect.top;
                const orbitX = (currentX + elRect.width / 2) + Math.cos(p.angle) * (elRect.width / 2 + 10);
                const orbitY = (currentY + elRect.height / 2) + Math.sin(p.angle) * (elRect.height / 2 + 10);
                uiCtx.beginPath(); uiCtx.arc(orbitX, orbitY, p.radius, 0, Math.PI * 2);
                uiCtx.fillStyle = p.color; uiCtx.globalAlpha = .8; uiCtx.fill();
            } else if (p.type === 'sparkle') {
                uiCtx.beginPath(); uiCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                uiCtx.fillStyle = p.color; uiCtx.globalAlpha = p.life / p.maxLife * .8; uiCtx.fill();
            }
        });
        uiCtx.globalAlpha = 1;
    }
    function drawBackground(){ctx.fillStyle='#0c0c14';ctx.fillRect(0,0,canvas.width,canvas.height);if(window.stars)window.stars.forEach(s=>{ctx.beginPath();ctx.arc(s.x,s.y,s.radius,0,Math.PI*2);ctx.fillStyle=`rgba(255,255,255,${.5+s.speed})`;ctx.fill()})}
    
    function drawPlayer() {
        dom.ultBtn.classList.toggle('is-flashing', player.rage >= 100);
        dom.ultBtn.style.background = player.rage >= 100 ? '#f72585' : '#5a1835';
        dom.autoBtn.classList.toggle('active', isAutoBattle);
        ctx.save();
        ctx.translate(player.x, player.y);
        const drawSize = player.size;
        const halfDrawSize = drawSize / 2;
        ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 15; ctx.shadowOffsetY = 8; ctx.shadowOffsetX = 0;
        if (player.rage >= 100) {
            ctx.beginPath(); ctx.arc(0, 0, halfDrawSize * 0.9, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(247, 37, 133, ${0.4 + Math.sin(Date.now() * 0.005) * 0.2})`;
            ctx.shadowColor = '#f72585'; ctx.shadowBlur = 40; ctx.fill(); ctx.shadowBlur = 0;
        }
        if (playerSpriteLoaded) {
            let originalAlpha = ctx.globalAlpha, originalFilter = ctx.filter;
            if (player.flash > 0) {
                const flashAlpha = 0.8 * (player.flash / 5);
                ctx.globalAlpha = flashAlpha; ctx.filter = 'brightness(2) saturate(2) hue-rotate(0deg)';
            } else if (player.rage >= 100) {
                const hueShift = Math.sin(Date.now() * 0.005) * 10;
                const brightness = 1.1 + Math.sin(Date.now() * 0.003) * 0.1;
                ctx.filter = `brightness(${brightness}) saturate(1.2) hue-rotate(${hueShift}deg)`;
            }
            ctx.drawImage(playerSprite, -halfDrawSize, -halfDrawSize, drawSize, drawSize);
            ctx.filter = originalFilter; ctx.globalAlpha = originalAlpha;
        } else {
            ctx.fillStyle = player.color; ctx.fillRect(-halfDrawSize, -halfDrawSize, drawSize, drawSize);
        }
        ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;
        ctx.restore();
        ctx.save();
        ctx.translate(player.x, player.y);
        drawWeapon(ctx);
        ctx.restore();
        if (!explorationContainer.classList.contains('hidden')) {
            const barWidth = 100, barX = player.x - barWidth / 2, halfDrawSize = player.size / 2;
            ctx.fillStyle = '#333'; ctx.fillRect(barX, player.y + halfDrawSize + 5, barWidth, 12);
            ctx.fillStyle = '#2a9d8f'; ctx.fillRect(barX, player.y + halfDrawSize + 5, barWidth * Math.max(0, player.hp / player.stats.maxHp.current), 12);
            ctx.fillStyle = '#554300'; ctx.fillRect(barX, player.y + halfDrawSize + 18, barWidth, 8);
            ctx.fillStyle = '#ffd700'; ctx.fillRect(barX, player.y + halfDrawSize + 18, barWidth * (player.rage / 100), 8);
        }
    }

    function drawWeapon(ctx) {
        const weapon = player.inventory.weapon; const v = player.weaponVisual; const tier = weapon.tier;
        if (v.target) v.angle = Math.atan2(v.target.y - player.y, v.target.x - player.x);
        ctx.rotate(v.angle);
        switch (weapon.type) {
            case 'bow': drawAnimatedBow(ctx, v, tier); break;
            case 'sword': drawAnimatedSword(ctx, v, tier); break;
            case 'shield': drawAnimatedShield(ctx, v, tier); break;
        }
    }

    function drawAnimatedBow(ctx, v, tier) {
        let bowColor = '#8c5e3c', stringColor = '#fff', glowColor = null, particleColor = '#ffecb3';
        if (tier >= 10 && tier < 25) { bowColor = '#7b8cde'; stringColor = '#aaffff'; glowColor = 'rgba(170, 255, 255, 0.5)'; } 
        else if (tier >= 25) { bowColor = '#ffd700'; stringColor = '#fff'; glowColor = 'rgba(255, 220, 150, 0.7)'; particleColor = '#fff'; }
        let drawRatio = 0;
        if (v.animState === 'drawing') drawRatio = 1 - (v.animTimer / (30 * (1/(1+player.inventory.weapon.attackSpeedBonus))));
        else if (v.animState === 'firing') drawRatio = v.animTimer / 15;
        const bowWidth = 50, bowThickness = 5 + Math.floor(tier / 10), stringPullback = 20 * drawRatio;
        if (glowColor) { ctx.shadowColor = glowColor; ctx.shadowBlur = 15; }
        ctx.beginPath(); ctx.moveTo(0, -bowWidth / 2); ctx.quadraticCurveTo(15 + stringPullback, 0, 0, bowWidth / 2);
        ctx.lineWidth = bowThickness; ctx.strokeStyle = bowColor; ctx.stroke(); ctx.shadowBlur = 0;
        ctx.beginPath(); ctx.moveTo(0, -bowWidth / 2); ctx.lineTo(-stringPullback, 0); ctx.lineTo(0, bowWidth / 2);
        ctx.lineWidth = 2; ctx.strokeStyle = stringColor; ctx.stroke();
        if (drawRatio > 0.1) {
            ctx.beginPath(); ctx.arc(-stringPullback, 0, 3 + tier / 10, 0, Math.PI * 2);
            ctx.fillStyle = particleColor; ctx.shadowColor = particleColor; ctx.shadowBlur = 10; ctx.fill(); ctx.shadowBlur = 0;
        }
    }

    function drawAnimatedSword(ctx, v, tier) {
        const length = 50 + tier, width = 8 + Math.floor(tier / 10);
        ctx.fillStyle = '#c0c0c0'; if (tier >= 10) ctx.fillStyle = '#6495ed'; if (tier >= 25) ctx.fillStyle = '#ff4500';
        ctx.fillRect(20, -width/2, length, width);
    }

    function drawAnimatedShield(ctx, v, tier) {
        const size = 30 + tier;
        ctx.fillStyle = '#a0522d'; if (tier >= 10) ctx.fillStyle = '#4682b4'; if (tier >= 25) ctx.fillStyle = '#4b0082';
        ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = 'black'; ctx.lineWidth = 3; ctx.stroke();
    }
    
    function drawEnemies() {
        enemies.forEach(e => {
            if (e.icon) {
                ctx.save(); ctx.font = `900 ${e.radius * 2}px "Font Awesome 6 Free"`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = e.chargeTimer > 0 ? '#ff6b6b' : e.color;
                if (e.flash > 0) { ctx.shadowColor = 'white'; ctx.shadowBlur = 20; } 
                else { ctx.shadowColor = 'rgba(0,0,0,0.7)'; ctx.shadowBlur = 15; ctx.shadowOffsetY = 8; }
                const iconMap = { 'fa-ghost': '\uf6e2', 'fa-skull-crossbones': '\uf714', 'fa-robot': '\uf544', 'fa-hat-wizard': '\uf6e8', 'fa-pastafarianism': '\uf67b', 'fa-user-secret': '\uf21b', 'fa-user-ninja': '\uf504' };
                const iconChar = iconMap[e.icon] || '?';
                ctx.fillText(iconChar, e.x, e.y); ctx.restore();
            } else {
                ctx.save(); ctx.translate(e.x, e.y); ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 10; ctx.shadowOffsetY = 5;
                ctx.beginPath(); ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
                ctx.fillStyle = e.chargeTimer > 0 ? '#ff6b6b' : e.color; ctx.fill();
                ctx.restore();
                if (e.flash > 0) { ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(255,255,255,${e.flash/5})`; ctx.fill(); }
            }
            if (!explorationContainer.classList.contains('hidden')) {
                const barWidth = e.radius * 2;
                ctx.fillStyle = '#333'; ctx.fillRect(e.x - e.radius, e.y - e.radius - 15, barWidth, 5);
                ctx.fillStyle = '#c1121f'; ctx.fillRect(e.x - e.radius, e.y - e.radius - 15, barWidth * Math.max(0, e.hp / e.maxHp), 5);
            }
        })
    }
    function drawHealthOrbs(){healthOrbs.forEach(orb=>{ctx.save();ctx.globalAlpha=.5+Math.sin(orb.pulse)*.3;ctx.beginPath();ctx.arc(orb.x,orb.y,orb.radius,0,Math.PI*2);ctx.fillStyle='#4caf50';ctx.fill();ctx.shadowColor='#abffc0';ctx.shadowBlur=15;ctx.fill();ctx.restore()})}
    function drawSkillVisuals() {
        skillVisuals.forEach(v => {
            ctx.save(); ctx.globalAlpha = Math.min(1, v.life / v.maxLife);
            switch (v.type) {
                case 'orbitalStrike':
                    const dx = v.target.x - v.x; const dy = v.target.y - v.y; const dist = Math.hypot(dx, dy);
                    ctx.beginPath(); ctx.arc(v.x, v.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#9d4edd'; ctx.shadowColor = '#d3a0ff'; ctx.shadowBlur = 20; ctx.fill();
                    if (dist < v.speed) {
                        v.target.hp -= v.damage; addFloatingText(v.damage, v.target.x, v.target.y, '#d3a0ff');
                        createExplosion(v.x, v.y, 20, '#9d4edd'); v.life = 0;
                    } else { v.x += dx / dist * v.speed; v.y += dy / dist * v.speed; }
                    break;
                case 'chainLightning':
                    if (v.targets.length > 1) {
                        ctx.beginPath(); ctx.moveTo(v.targets[0].x, v.targets[0].y);
                        for (let i = 1; i < v.targets.length; i++) {
                            const start = v.targets[i - 1]; const end = v.targets[i];
                            const midX = (start.x + end.x) / 2 + (Math.random() - 0.5) * 40;
                            const midY = (start.y + end.y) / 2 + (Math.random() - 0.5) * 40;
                            ctx.quadraticCurveTo(midX, midY, end.x, end.y);
                        }
                        ctx.strokeStyle = '#6efcff'; ctx.lineWidth = 3; ctx.shadowColor = '#aaffff'; ctx.shadowBlur = 15; ctx.stroke();
                    }
                    v.targets.forEach(target => {
                        ctx.beginPath(); ctx.arc(target.x, target.y, 10, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(170, 255, 255, 0.5)'; ctx.fill();
                    });
                    break;
                case 'meteor':
                    ctx.beginPath(); ctx.moveTo(v.x, v.y - 20); ctx.lineTo(v.x + 3, v.y); ctx.lineTo(v.x - 3, v.y);
                    ctx.closePath(); ctx.fillStyle = '#fca311'; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 15; ctx.fill();
                    v.y += v.speed;
                    if (v.y >= v.targetY) {
                        enemies.forEach(e => {
                            if (Math.abs(e.x - v.x) < 40 && Math.abs(e.y - v.y) < 60) { e.hp -= v.damage; addFloatingText(v.damage, e.x, e.y, '#fca311'); }
                        });
                        createExplosion(v.x, v.y, 30, '#fca311', 4, 6); v.life = 0;
                    }
                    break;
            }
            ctx.restore();
        });
    }
    function drawEffects(){projectiles.forEach(p=>{ctx.fillStyle=p.isPlayer?'#fff':'#ff4d4d';ctx.beginPath();ctx.arc(p.x,p.y,5,0,2*Math.PI);ctx.fill()});particles.forEach(p=>{ctx.fillStyle=p.color;ctx.globalAlpha=p.life/30;ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,2*Math.PI);ctx.fill()});ctx.globalAlpha=1;floatingTexts.forEach(t=>{ctx.font='bold 28px sans-serif';ctx.fillStyle=t.color;ctx.globalAlpha=t.life/60;ctx.textAlign='center';ctx.shadowColor='black';ctx.shadowBlur=4;ctx.fillText(t.text,t.x,t.y)});ctx.shadowBlur=0;ctx.shadowColor='transparent';ctx.globalAlpha=1}
    function drawCountdown(){let text='',scale=1+(countdownTimer%60)/30;if(countdownTimer>120)text='3';else if(countdownTimer>60)text='2';else if(countdownTimer>0)text='1';if(text){ctx.save();ctx.font=`bold ${120*scale}px Cinzel`;ctx.fillStyle=`rgba(255,255,255,${1-(countdownTimer%60)/60})`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.shadowColor='rgba(255, 100, 100, 0.7)';ctx.shadowBlur=20;ctx.fillText(text,canvas.width/2,canvas.height/2);ctx.restore()}}
    
    function updateWeaponAnimation() {
        if (player.weaponVisual.animState !== 'idle') {
            const speedMultiplier = 1 / (1 + (player.inventory.weapon.attackSpeedBonus || 0));
            player.weaponVisual.animTimer -= 1;
            
            if (player.weaponVisual.animTimer <= 0) { 
                if (player.weaponVisual.animState === 'drawing') {
                    player.weaponVisual.animState = 'firing';
                    player.weaponVisual.animTimer = 15;
                    const weapon = player.inventory.weapon;
                    let finalDamage = weapon.power + player.stats.attackPower.current;
                    let isCrit = false;
                    if (Math.random() < (weapon.critChance || 0)) {
                        finalDamage = Math.floor(finalDamage * (weapon.critDamage || 1.5));
                        isCrit = true;
                    }
                    
                    projectiles.push({
                        x: player.x, y: player.y, target: player.weaponVisual.target,
                        speed: 15, isPlayer: true, damage: finalDamage, isCrit: isCrit,
                        lifestealAmount: finalDamage * (weapon.lifesteal || 0)
                    });

                    if (weapon.statusEffect && Math.random() < weapon.statusEffect.chance) {
                        const target = player.weaponVisual.target;
                        if (!target.statusEffects) target.statusEffects = [];
                        target.statusEffects.push({ ...weapon.statusEffect, duration: weapon.statusEffect.duration * 60 });
                    }
                    createExplosion(player.x, player.y, 20, '#fff', 2, 4);

                } else if (player.weaponVisual.animState === 'firing') {
                    player.weaponVisual.animState = 'idle';
                    player.isAttacking = false;
                    player.weaponVisual.target = null;
                }
            }
        }
    }
    
    function drawExplorationMode() {
        ctx = expCtx;
        ctx.clearRect(0, 0, explorationCanvas.width, explorationCanvas.height);
        explorationBackgroundStars.forEach(star => { 
            ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); 
            ctx.fillStyle = `rgba(255, 255, 255, ${star.speed / 3})`; ctx.fill(); 
        });
        drawPlayer();
        drawEnemies();
        drawEffects();
        drawSkillVisuals();
        ctx = document.getElementById('game-canvas').getContext('2d'); 
    }
    
    function draw() {
        if (!explorationContainer.classList.contains('hidden')) {
            drawExplorationMode();
        } else if (!gameContainer.classList.contains('hidden')) {
            drawBackground();
            ctx.save();
            if (shakeDuration > 0) { ctx.translate(Math.random() * 6 - 3, Math.random() * 6 - 3); shakeDuration-- }
            if (gameState === 'COMBAT' || gameState === 'ENDING_COMBAT' || gameState === 'COUNTDOWN') {
                drawPlayer(); drawEnemies(); drawHealthOrbs(); drawEffects(); drawSkillVisuals();
            }
            if (gameState === 'COUNTDOWN') drawCountdown();
            ctx.restore();
            drawHud();
            if (gameState === 'COMBAT' || gameState === 'ENDING_COMBAT' || gameState === 'COUNTDOWN') {
                drawBossHealthBar(); drawPlayerHudBars();
            }
            drawUiParticles();
        }
    }
    function gameLoop(){update();draw();requestAnimationFrame(gameLoop)}

    function initializeBootSequence() {
        let progress = 0;
        const loadingTime = 2500;
        const intervalTime = 25;
        const progressIncrement = 100 / (loadingTime / intervalTime);
        const bootInterval = setInterval(() => {
            progress += progressIncrement;
            bootProgressBar.style.width = Math.min(progress, 100) + '%';
            if (progress >= 100) {
                clearInterval(bootInterval);
                setTimeout(() => startGameButton.classList.add('visible'), 300);
            }
        }, intervalTime);
        startGameButton.addEventListener('click', () => {
            SOUNDS.click();
            const backgroundMusic = document.getElementById('bg-music');
            if (backgroundMusic) { backgroundMusic.volume = 0.3; backgroundMusic.play().catch(error => console.log("Music play failed:", error)); }
            bootScreen.classList.add('fade-out');
            setTimeout(() => showScreen('main'), 700);
        });
    }

    let mapBackgroundCanvas, gl, mapProgram, mapStartTime;
    const mapVertexShaderSource = `attribute vec4 a_position; void main() { gl_Position = a_position; }`;
    const mapFragmentShaderSource = `precision mediump float; uniform vec2 u_resolution; uniform float u_time; void main() { vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y; float t = u_time * 0.1; vec2 p = uv * 3.0 + vec2(t, t); float noise = 0.5 + 0.5 * sin(p.x * 10.0 + sin(p.y * 10.0 + t)); vec3 color1 = vec3(0.05, 0.1, 0.2); vec3 color2 = vec3(0.1, 0.2, 0.4); vec3 finalColor = mix(color1, color2, noise); gl_FragColor = vec4(finalColor, 1.0); }`;
    
    function initMapBackground() {
        mapBackgroundCanvas = document.getElementById('map-background-canvas');
        gl = mapBackgroundCanvas.getContext('webgl');
        if (!gl) {
            console.error("WebGL not supported, falling back to CSS background.");
            document.getElementById('map-screen').style.backgroundImage = 'radial-gradient(circle at 50% 30%, #1a5c69, #0f343d 50%, #031018 85%)';
            return;
        }
        function createShader(gl, type, source) {
            const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader)); gl.deleteShader(shader); return null; }
            return shader;
        }
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, mapVertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, mapFragmentShaderSource);
        mapProgram = gl.createProgram();
        gl.attachShader(mapProgram, vertexShader); gl.attachShader(mapProgram, fragmentShader); gl.linkProgram(mapProgram);
        if (!gl.getProgramParameter(mapProgram, gl.LINK_STATUS)) { console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(mapProgram)); return; }
        const positionBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        mapStartTime = Date.now();
    }
    
    function renderMapBackground() {
        if (!gl || !mapProgram) return;
        const canvas = gl.canvas;
        const displayWidth  = canvas.clientWidth; const displayHeight = canvas.clientHeight;
        if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
            canvas.width  = displayWidth; canvas.height = displayHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }
        gl.useProgram(mapProgram);
        const positionAttributeLocation = gl.getAttribLocation(mapProgram, 'a_position');
        gl.enableVertexAttribArray(positionAttributeLocation); gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        const resolutionUniformLocation = gl.getUniformLocation(mapProgram, 'u_resolution');
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        const timeUniformLocation = gl.getUniformLocation(mapProgram, 'u_time');
        const currentTime = (Date.now() - mapStartTime) * 0.001;
        gl.uniform1f(timeUniformLocation, currentTime);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
    
    const originalDraw = draw;
    draw = function() {
        if (!mapScreen.classList.contains('hidden')) renderMapBackground();
        originalDraw();
    }
    
    initGame(false, true);
    initializeBootSequence();
    initMapBackground();
    setInterval(updateEnergyReplenishment, 1000);
    window.addEventListener('beforeunload', saveGame);
    gameLoop();

    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js')
                .then(registration => console.log('ServiceWorker registration successful'))
                .catch(error => console.log('ServiceWorker registration failed: ', error));
        });
    }
</script>
</body>
</html>
