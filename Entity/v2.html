<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Mini-RPG: The 2D Adventure</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Icon Enhancement Styles -->
    <style>
        /* General flair for all icons in slots */
        .action-slot i, .inventory-slot i {
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            transition: transform 0.2s ease-out, text-shadow 0.2s ease-out;
            will-change: transform;
        }

        /* Make icons feel interactive on hover */
        .action-slot:hover i, .inventory-slot:hover i {
            transform: scale(1.15);
        }
        
        /* --- Quality-Based Glows --- */
        .quality-magic {
            text-shadow: 0 0 7px var(--color-text-magic), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
        }
        .quality-rare {
            text-shadow: 0 0 10px var(--color-text-rare), 0 0 3px var(--color-text-rare), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
        }
        .quality-epic {
            text-shadow: 0 0 12px var(--color-text-epic), 0 0 5px var(--color-text-epic), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
            animation: epic-glow 2s infinite alternate ease-in-out;
        }
        
        @keyframes epic-glow {
            from { text-shadow: 0 0 12px var(--color-text-epic), 0 0 5px var(--color-text-epic), 1px 1px 3px rgba(0, 0, 0, 0.8); }
            to   { text-shadow: 0 0 20px var(--color-text-epic), 0 0 8px #fff, 1px 1px 3px rgba(0, 0, 0, 0.8); }
        }

        /* --- Thematic Icon Coloring & Styling --- */
        .fa-burst, .fa-hand-fist { color: #ffffa0; }
        .fa-fire-flame-curved { color: #ff8c00; }
        .fa-gavel { color: #c39c6d; }
        .fa-book-skull { color: #8b008b; }
        .fa-leaf { color: #228b22; }
        .fa-person-digging { color: #cd7f32; }
        .fa-hammer { color: #a9a9a9; }
        .fa-ghost { color: #a0c4ff; }
        .fa-dove { color: #ffd700; }
        .fa-shop { color: #c0c0c0; }
        .fa-chair { color: #8b4513; }
        .fa-sword { color: #A9A9A9; }
        .fa-scythe { color: #E0E0E0; }
        .fa-vest-patches { color: #8B4513; }
        .fa-jedi { color: #f0f0f0; }
        .fa-flask-vial { color: #2E8B57; }
        .fa-network-wired { color: #F5F5F5; }
        .fa-tooth { color: #FFFAF0; }
        .fa-tree { color: #66827a; } /* Treant */
        .fa-paw-claws { color: #d3a483; } /* Bear */
        .fa-dagger { color: #9acd32; } /* Goblin Stalker */

    </style>

    <style>
        :root {
            --color-health: #28a745;
            --color-mana: #007bff;
            --color-xp: #9370db;
            --color-xp-rested: #00bfff;
            --color-enemy-health: #dc3545;
            --color-bg-dark: #1a1a1a;
            --color-bg-medium: #2a2a2e;
            --color-bg-light: #3a3a40;
            --color-border: #4f4f58;
            --color-text: #f0f0f0;
            --color-text-muted: #888;
            --color-text-quest: #ffd700;
            --color-text-magic: #87ceeb;
            --color-text-rare: #0070dd;
            --color-text-epic: #a335ee;
            --color-cooldown: rgba(0, 0, 0, 0.75);
            --font-main: 'Verdana', sans-serif;
            --color-gold: #ffd700;
            --color-silver: #c0c0c0;
            --color-copper: #b87333;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--color-bg-dark);
            font-family: var(--font-main); color: var(--color-text);
            user-select: none; -webkit-user-select: none;
        }
        #game-container { position: relative; width: 100%; height: 100%; display: none; }
        #game-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            filter: saturate(1.1) contrast(1.05);
        }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .fullscreen-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: var(--color-bg-dark);
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="none"/><path d="M 10 0 L 10 100 M 20 0 L 20 100 M 30 0 L 30 100 M 40 0 L 40 100 M 50 0 L 50 100 M 60 0 L 60 100 M 70 0 L 70 100 M 80 0 L 80 100 M 90 0 L 90 100 M 0 10 L 100 10 M 0 20 L 100 20 M 0 30 L 100 30 M 0 40 L 100 40 M 0 50 L 100 50 M 0 60 L 100 60 M 0 70 L 100 70 M 0 80 L 100 80 M 0 90 L 100 90" stroke="rgba(42,42,46,0.4)" stroke-width="1"/></svg>');
            display: flex; justify-content: center; align-items: center;
            z-index: 50000;
        }

        .menu-box {
            background-color: var(--color-bg-medium);
            padding: 30px 40px;
            border-radius: 10px; border: 2px solid var(--color-border);
            box-shadow: 0 0 25px rgba(0,0,0,0.7);
            text-align: center;
        }
        .menu-box h1 { font-size: 3em; margin-bottom: 20px; color: var(--color-text-quest); }
        .menu-button {
            display: block; width: 250px; padding: 15px; margin: 15px auto;
            font-size: 1.2em; background-color: var(--color-bg-light);
            border: 1px solid var(--color-border); color: var(--color-text);
            cursor: pointer; transition: background-color 0.2s;
        }
        .menu-button:hover { background-color: var(--color-bg-dark); border-color: #fff; }
        .menu-button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        #character-creation-screen input[type="text"] {
            width: 90%; padding: 10px; margin-bottom: 20px;
            background: var(--color-bg-dark); border: 1px solid var(--color-border);
            color: var(--color-text); font-size: 1.1em;
        }
        .race-selection { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
        .race-option {
            padding: 15px; border: 2px solid var(--color-border);
            cursor: pointer; transition: all 0.2s;
        }
        .race-option.selected { border-color: gold; background: var(--color-bg-light); }
        .race-option h3 { margin: 0 0 5px 0; }
        .race-option p { font-size: 0.8em; color: var(--color-text-muted); margin: 0; }


        .unit-frame { position: absolute; top: 20px; width: 250px; background-color: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; padding: 5px; display: flex; gap: 10px; align-items: center; pointer-events: all; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #player-frame { left: 20px; }
        #target-frame { left: 290px; display: none; }
        .portrait { width: 50px; height: 50px; background: var(--color-bg-dark); border: 2px solid var(--color-border); border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 30px; }
        .unit-info { flex-grow: 1; }
        .name-level { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .resource-bar { width: 100%; height: 15px; background-color: var(--color-bg-dark); border-radius: 3px; overflow: hidden; margin-top: 2px; position: relative; }
        .resource-bar .bar-fill { height: 100%; transition: width 0.2s ease-out; }
        .resource-bar .bar-text { position: absolute; width: 100%; text-align: center; font-size: 10px; line-height: 15px; color: white; text-shadow: 1px 1px 1px black; }
        #player-health-fill { background-color: var(--color-health); }
        #player-mana-fill { background-color: var(--color-mana); }
        #target-health-fill { background-color: var(--color-enemy-health); }

        .buff-container { display: flex; gap: 3px; margin-top: 4px; height: 24px; }
        .buff-icon { width: 22px; height: 22px; background-color: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 14px; position: relative; }
        .buff-icon.debuff { border-color: var(--color-enemy-health); }
        .buff-duration { position: absolute; bottom: -1px; right: -1px; font-size: 10px; background: rgba(0,0,0,0.8); padding: 0 2px; border-radius: 2px; color: white; }
        .buff-icon .fa-skull { color: #ff4500; }
        .buff-icon .fa-heart-crack { color: #dc143c; }
        .buff-icon .fa-vine { color: #228b22; }

        #bottom-ui-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column-reverse; align-items: center; gap: 2px; }
        #action-bar { position: relative; bottom: 0; left: 0; transform: none; display: flex; background-color: var(--color-bg-medium); padding: 5px; border-radius: 5px; border: 1px solid var(--color-border); pointer-events: all; }
        .action-slot { width: 50px; height: 50px; background-color: var(--color-bg-dark); border: 1px solid var(--color-border); margin: 2px; position: relative; display: flex; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; }
        .action-slot:hover { border-color: #fff; }
        .action-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        .action-slot i { pointer-events: none; }
        .action-keybind { position: absolute; top: 2px; left: 2px; font-size: 10px; color: var(--color-text-muted); }
        .hotbar-item-count { position: absolute; bottom: 2px; right: 2px; font-size: 14px; color: white; text-shadow: 1px 1px 2px black; }
        .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 0; background-color: var(--color-cooldown); pointer-events: none; display: flex; justify-content: center; align-items: center; font-size: 18px; color: white; overflow: hidden; }

        #xp-bar { position: relative; bottom: 0; left: 0; transform: none; width: 80vw; max-width: 544px; height: 8px; background-color: rgba(0,0,0,0.5); border: 1px solid var(--color-border); pointer-events: none; display: flex; }
        #xp-bar-fill { width: 0%; height: 100%; background-color: var(--color-xp); transition: width 0.5s ease-in-out; }
        #xp-bar-rested-fill { width: 0%; height: 100%; background-color: var(--color-xp-rested); transition: width 0.5s ease-in-out; }

        #minimap { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; border-radius: 50%; border: 3px solid var(--color-border); background-color: var(--color-bg-dark); overflow: hidden; pointer-events: all; }
        #minimap-canvas { width: 100%; height: 100%; }
        .window { position: absolute; width: 350px; background: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; box-shadow: 0 0 15px rgba(0,0,0,0.7); display: none; flex-direction: column; pointer-events: all; z-index: 100; }
        .window-header { padding: 8px; background: var(--color-bg-light); cursor: move; display: flex; justify-content: space-between; align-items: center; }
        .window-header .close-btn { cursor: pointer; }
        .window-content { padding: 10px; max-height: 400px; overflow-y: auto; }
        #character-window { top: 150px; left: 100px; width: 450px; }
        #inventory-window { top: 150px; left: 500px; }
        #storage-window { top: 150px; left: 860px; }
        #quest-log-window { top: 100px; right: 200px; }
        #talent-window { top: 200px; left: 150px; width: 450px; }
        #spellbook-window { top: 200px; left: 600px; width: 300px; }
        #reputation-window { top: 200px; left: 950px; width: 300px; }
        #vendor-window { top: 100px; left: 300px; width: 400px; }
        #crafting-window { top: 100px; left: 300px; width: 400px; }
        
        #map-window {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            height: 80vh;
        }
        #map-window .window-content {
            padding: 0;
            overflow: hidden;
            background-color: var(--color-bg-dark);
            flex-grow: 1; 
            max-height: none;
        }
        #map-canvas {
            width: 100%;
            height: 100%;
        }
        .profession-line {
            margin-bottom: 8px; /* Add some space between professions */
        }
        .profession-xp-bar {
            width: 100%;
            height: 5px;
            background-color: var(--color-bg-dark);
            border: 1px solid var(--color-border);
            border-radius: 2px;
            margin-top: 3px;
        }
        .profession-xp-bar-fill {
            height: 100%;
            background-color: var(--color-xp);
            border-radius: 1px;
            transition: width 0.3s ease-in-out;
        }
        #character-sheet-container { display: flex; justify-content: space-between; gap: 10px; }
         #character-window .window-content {
            max-height: none; /* Removes the fixed height limit */
            overflow-y: visible; /* Hides the scrollbar */
        }
        #vendor-window .window-content {
            max-height: none;
            overflow-y: visible;
        }
        #equipment-slots { display: flex; flex-direction: column; gap: 5px; }
        .equipment-slot { width: 50px; height: 50px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 24px; position: relative; margin-bottom: 12px; }
        .equipment-slot[draggable="true"] { cursor: grab; }
        .equipment-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        .equipment-slot-name { position: absolute; bottom: -15px; width: 100%; text-align: center; font-size: 10px; color: var(--color-text-muted); }
        #stats-column { flex-grow: 1; }

        #inventory-grid, #storage-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .inventory-slot, .storage-slot { width: 60px; height: 60px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 28px; position: relative; }
        .inventory-slot[draggable="true"], .storage-slot[draggable="true"] { cursor: grab; }
        .inventory-slot.drag-over, .storage-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; text-shadow: 1px 1px 1px black; }
        .quality-common { color: var(--color-text); }
        .quality-magic { color: var(--color-text-magic); }
        .quality-rare { color: var(--color-text-rare); }
        .quality-epic { color: var(--color-text-epic); }
        .stat-line { display: flex; justify-content: space-between; padding: 4px 0; }
        
        .currency-container { display: flex; justify-content: flex-end; align-items: center; gap: 5px; font-size: 14px; }
        .currency-item { display: flex; align-items: center; gap: 2px; }
        .currency-icon { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #333; }
        .gold { background-color: var(--color-gold); }
        .silver { background-color: var(--color-silver); }
        .copper { background-color: var(--color-copper); }

        .quest-item { padding: 8px; border-bottom: 1px solid var(--color-border); display: flex; justify-content: space-between; align-items: center; }
        .quest-item > div { flex-grow: 1; }
        .auto-quest-btn { padding: 4px 8px; font-size: 12px; background-color: var(--color-bg-light); border: 1px solid var(--color-border); color: var(--color-text-quest); cursor: pointer; pointer-events: all; margin-left: 10px; flex-shrink: 0; transition: background-color 0.2s; }
        .auto-quest-btn:hover { background-color: var(--color-bg-medium); border-color: #fff; }
        .auto-quest-btn.active { background-color: var(--color-enemy-health); color: white; }

        .quest-title { font-weight: bold; color: var(--color-text-quest); }
        .quest-objective { font-size: 14px; padding-left: 15px; }
        .floating-text { position: absolute; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; animation: floatUp 1.5s ease-out forwards; pointer-events: none; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-60px); opacity: 0; } }
        .floating-text.crit { font-size: 24px; animation: floatUpCrit 1.5s ease-out forwards; color: #ff4500 !important; }
        @keyframes floatUpCrit { 0% { transform: translateY(0) scale(1); opacity: 1; } 50% { transform: translateY(-40px) scale(1.5); } 100% { transform: translateY(-80px) scale(1); opacity: 0; } }
        .floating-text.miss { color: #ccc !important; font-style: italic; font-size: 16px; }

        #tooltip { position: absolute; background: var(--color-bg-dark); border: 1px solid var(--color-border); padding: 10px; border-radius: 5px; display: none; max-width: 250px; pointer-events: none; z-index: 10000; }
        #tooltip .name { font-weight: bold; margin-bottom: 5px; }
        #tooltip .description { font-size: 14px; color: var(--color-text-muted); }
        #tooltip .stats { margin-top: 8px; font-size: 14px; }
        #tooltip .durability { color: #ff4500; }
        
        #mobile-controls { position: absolute; bottom: 10px; left: 10px; width: 150px; height: 150px; display: none; pointer-events: all; }
        #joystick-area { position: relative; width: 100%; height: 100%; background: rgba(50, 50, 50, 0.4); border-radius: 50%; }
        #joystick-thumb { position: absolute; width: 60px; height: 60px; background: rgba(120, 120, 120, 0.7); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #system-menu { position: absolute; bottom: 20px; right: 20px; display: flex; pointer-events: all; gap: 2px; }
        .sys-button { width: 30px; height: 30px; background: var(--color-bg-light); border: 1px solid var(--color-border); cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .sys-button:hover { background: var(--color-bg-medium); }
        
        #talent-points-display { text-align: center; margin-bottom: 10px; font-weight: bold; }
        .talent-tree { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .talent { background: var(--color-bg-dark); border: 1px solid var(--color-border); padding: 5px; text-align: center; cursor: pointer; position: relative; }
        .talent.locked { filter: grayscale(1) brightness(0.5); cursor: not-allowed; }
        .talent.maxed { border-color: gold; }
        .talent:not(.locked):not(.maxed):hover { border-color: white; }
        .talent-icon { font-size: 30px; }
        .talent-name { font-size: 12px; margin-top: 4px; }
        .talent-rank { position: absolute; bottom: 2px; right: 2px; font-size: 12px; background: rgba(0,0,0,0.7); padding: 1px 3px; border-radius: 3px; }

        #spellbook-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .spellbook-slot { width: 50px; height: 50px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 24px; position: relative; }
        .spellbook-slot[draggable="true"] { cursor: grab; }

        .reputation-line { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid var(--color-border); }
        .rep-bar-container { width: 120px; height: 16px; background: var(--color-bg-dark); border: 1px solid var(--color-border); }
        .rep-bar-fill { height: 100%; background-color: var(--color-health); }

                /* --- NEW: Add this rule for the container --- */
        .vendor-item-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px; /* Small gap between item and price */
        }

        #vendor-content, #crafting-content { display: flex; flex-direction: column; gap: 10px; }
        .vendor-section, .crafting-section { border: 1px solid var(--color-border); padding: 8px; background: var(--color-bg-dark); }
        .vendor-section h3, .crafting-section h3 { margin: 0 0 5px 0; font-size: 1.1em; color: var(--color-text-quest); }
        
        /* FIX: Adjusted vendor grid to better space the new containers */
        .vendor-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); 
            gap: 10px; 
            row-gap: 15px; /* More vertical space for the price below */
        }
        .crafting-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); 
            gap: 5px; 
        }

        .vendor-item-slot, .crafting-recipe-slot { width: 60px; height: 60px; background: var(--color-bg-medium); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 28px; position: relative; cursor: pointer; }
        .vendor-item-slot:hover, .crafting-recipe-slot:hover { border-color: white; }
        
        /* FIX: Vendor price is no longer absolutely positioned. It sits below the slot in the flex container. */
        .vendor-item-price {
            font-size: 11px;
            color: var(--color-gold);
            text-shadow: 1px 1px 2px black;
            display: flex;
            align-items: center;
        }

        /* The crafting recipe cost remains inside its slot, so its style is kept separate */
        .crafting-recipe-cost { 
            position: absolute; 
            bottom: 2px; 
            left: 2px; 
            font-size: 10px; 
            color: var(--color-gold); 
            text-shadow: 1px 1px 2px black; 
            display: flex; 
            align-items: center; 
        }

        .crafting-recipe-cost.unmet { color: red; }
        .craft-button { display: block; width: calc(100% - 16px); padding: 8px; margin: 8px; background-color: var(--color-bg-light); border: 1px solid var(--color-border); color: var(--color-text); cursor: pointer; text-align: center; }
        .craft-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .craft-button:not(:disabled):hover { background-color: var(--color-bg-medium); }


        #death-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; flex-direction: column; color: #dc3545; text-align: center; font-size: 3em; text-shadow: 2px 2px 4px black; pointer-events: all; z-index: 20000; }
        #res-sickness-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(100, 0, 0, 0.2); pointer-events: none; z-index: 19999; display: none; }
        #release-spirit-button { padding: 15px 30px; font-size: 1.2em; color: var(--color-text); background-color: var(--color-bg-light); border: 2px solid var(--color-border); border-radius: 5px; cursor: pointer; margin-top: 20px; }
    
        #mobile-action-buttons { position: absolute; bottom: 20px; right: 20px; display: none; flex-direction: row; gap: 10px; pointer-events: all; }
        .mobile-action-button { width: 65px; height: 65px; background-color: var(--color-bg-medium); border: 2px solid var(--color-border); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 30px; position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .mobile-action-button .cooldown-overlay { border-radius: 50%; font-size: 22px; }

        @media (max-width: 900px) and (orientation: landscape) {
            #action-bar, #system-menu { display: none; }
            #mobile-controls { width: 180px; height: 180px; }
            #joystick-thumb { width: 70px; height: 70px; }
            #mobile-action-buttons { display: flex; }
            .unit-frame { width: 200px; transform: scale(0.9); transform-origin: top left; }
            #target-frame { left: 200px; }
            #minimap { width: 120px; height: 120px; transform: scale(0.9); transform-origin: top right; }
            .window { width: 90vw; height: 85vh; top: 50%; left: 50%; transform: translate(-50%, -50%); }
            .window-content { max-height: calc(85vh - 50px); }
        }
        #quest-tracker {
            position: absolute;
            top: 175px;
            right: 20px;
            width: 250px;
            background-color: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--color-border);
            border-radius: 5px;
            padding: 10px;
            color: var(--color-text);
            font-size: 13px;
            pointer-events: none;
            display: none; /* Hide by default */
        }
        #quest-tracker h3 {
            margin: 0 0 8px 0;
            font-size: 1.1em;
            color: var(--color-text-quest);
            text-align: center;
        }
        .tracker-quest-title {
            font-weight: bold;
            color: var(--color-text-quest);
            margin-top: 5px;
        }
        .tracker-quest-objective {
            color: #ccc;
            padding-left: 10px;
        }
        #stamina-bar {
            position: absolute;
            top: 95px; /* Positioned just below the player frame */
            left: 20px;
            width: 250px;
            height: 8px;
            display: none; /* Hidden by default */
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #stamina-bar-fill {
            background-color: #ffd700; /* A nice gold/yellow for stamina */
            transition: width 0.1s linear; /* Smooths the depletion/refill */
        }
        #pet-info-panel {
            padding: 10px;
            margin-top: 10px;
            border-top: 1px solid var(--color-border);
        }
        .pet-xp-bar {
            width: 100%;
            height: 10px;
            background-color: var(--color-bg-dark);
            border: 1px solid var(--color-border);
            margin-top: 5px;
        }
        .pet-xp-bar-fill {
            height: 100%;
            background-color: magenta;
        }
    </style>
</head>
<body>
    <div id="main-menu" class="fullscreen-overlay">
        <div class="menu-box">
            <h1>Mini-RPG</h1>
            <p>The 2D Adventure</p>
            <button id="continue-button" class="menu-button">Continue</button>
            <button id="new-char-button" class="menu-button">New Character</button>
        </div>
    </div>

    <div id="character-creation-screen" class="fullscreen-overlay" style="display: none;">
        <div class="menu-box">
            <h1>Create Your Hero</h1>
            <input type="text" id="char-name-input" placeholder="Enter Name" maxlength="12">
            <div class="race-selection">
                <div class="race-option" data-race="Human">
                    <h3><i class="fas fa-user"></i> Human</h3>
                    <p>No mana. No natural health regen.</p>
                </div>
                <div class="race-option" data-race="Elf">
                    <h3><i class="fas fa-leaf"></i> Elf</h3>
                    <p>Has mana. Regenerates health.</p>
                </div>
            </div>
            <button id="start-game-button" class="menu-button">Start Adventure</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="player-frame" class="unit-frame">
                <div class="portrait"><i class="fas fa-user"></i></div>
                <div class="unit-info">
                    <div class="name-level"><span id="player-name">Player</span><span id="player-level">Lvl 1</span></div>
                    <div class="resource-bar"><div id="player-health-fill" class="bar-fill"></div><div id="player-health-text" class="bar-text">100 / 100</div></div>
                    <div class="resource-bar" id="player-mana-bar"><div id="player-mana-fill" class="bar-fill"></div><div id="player-mana-text" class="bar-text">100 / 100</div></div>
                    <div class="buff-container" id="player-buffs"></div>
                </div>
            </div>

            <div id="stamina-bar" class="resource-bar">
                <div id="stamina-bar-fill" class="bar-fill"></div>
            </div>
            
            <div id="target-frame" class="unit-frame">
                <div class="portrait" id="target-portrait"></div>
                <div class="unit-info">
                    <div class="name-level"><span id="target-name"></span><span id="target-level"></span></div>
                    <div class="resource-bar"><div id="target-health-fill" class="bar-fill"></div><div id="target-health-text" class="bar-text"></div></div>
                    <div class="buff-container" id="target-buffs"></div>
                </div>
            </div>
            
            <div id="quest-tracker"></div>
            
            <div id="bottom-ui-container">
                <div id="action-bar"></div>
                <div id="xp-bar"><div id="xp-bar-rested-fill"></div><div id="xp-bar-fill"></div></div>
            </div>
            
            <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
            <div id="floating-text-container"></div>
            <div id="tooltip"></div>

            <div id="character-window" class="window">
                <div class="window-header"><span>Character</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="character-content"></div>
            </div>
            <div id="inventory-window" class="window">
                <div class="window-header"><span>Inventory</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="inventory-grid"></div><div id="currency" class="currency-container" style="margin-top: 10px; text-align: right;"></div></div>
            </div>
            <div id="quest-log-window" class="window">
                <div class="window-header"><span>Quest Log</span><i class="fas fa-times close-btn"></i></div><div class="window-content" id="quest-log-content"></div>
            </div>
            <div id="map-window" class="window">
                <div class="window-header"><span>World Map</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><canvas id="map-canvas"></canvas></div>
            </div>
            <div id="talent-window" class="window">
                <div class="window-header"><span>Talents</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content">
                    <div id="talent-points-display">Talent Points: 0</div>
                    <div id="talent-tree" class="talent-tree"></div>
                </div>
            </div>
            <div id="spellbook-window" class="window">
                <div class="window-header"><span>Spellbook</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="spellbook-grid"></div></div>
            </div>
            <div id="reputation-window" class="window">
                <div class="window-header"><span>Reputation</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="reputation-content"></div>
            </div>

            <div id="vendor-window" class="window">
                <div class="window-header"><span>Vendor</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="vendor-content">
                    <div class="vendor-section">
                        <h3>Your Items (Click to Sell)</h3>
                        <div id="vendor-player-inventory" class="vendor-grid"></div>
                    </div>
                    <div class="vendor-section">
                        <h3>Vendor Sells</h3>
                        <div id="vendor-sells-grid" class="vendor-grid"></div>
                    </div>
                    <div class="currency-container" style="text-align: right; margin-top: 10px;"><span id="vendor-gold-display" style="margin-right: 20px;"></span>Your Gold: <span id="vendor-player-gold"></span></div>
                </div>
            </div>
            
            <div id="crafting-window" class="window">
                <div class="window-header"><span>Crafting</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="crafting-content">
                    <div class="crafting-section">
                        <h3>Recipes</h3>
                        <div id="crafting-recipes-grid" class="crafting-grid"></div>
                    </div>
                    <div class="crafting-section">
                        <h3>Materials</h3>
                        <div id="crafting-materials-display"></div>
                    </div>
                    <button id="craft-button" class="craft-button" disabled>Craft</button>
                </div>
            </div>

            <div id="storage-window" class="window">
                <div class="window-header"><span>Storage</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="storage-grid"></div></div>
            </div>

            <div id="mobile-controls"><div id="joystick-area"><div id="joystick-thumb"></div></div></div>
            <div id="mobile-action-buttons"></div>
            <div id="system-menu">
                <button class="sys-button" id="save-button" title="Save Game"><i class="fas fa-save"></i></button>
                <button class="sys-button" data-window="storage-window" title="Open Storage"><i class="fas fa-box-archive"></i></button>
                <button class="sys-button" data-window="character-window" title="Character (C)"><i class="fas fa-user-circle"></i></button>
                <button class="sys-button" data-window="inventory-window" title="Inventory (I)"><i class="fas fa-briefcase"></i></button>
                <button class="sys-button" data-window="spellbook-window" title="Spellbook (P)"><i class="fas fa-book"></i></button>
                <button class="sys-button" data-window="talent-window" title="Talents (N)"><i class="fas fa-sitemap"></i></button>
                <button class="sys-button" data-window="quest-log-window" title="Quest Log (L)"><i class="fas fa-book-open"></i></button>
                <button class="sys-button" data-window="map-window" title="Map (M)"><i class="fas fa-map"></i></button>
                <button class="sys-button" data-window="reputation-window" title="Reputation (U)"><i class="fas fa-users"></i></button>
            </div>
            <div id="death-screen"><p>You have died.</p><button id="release-spirit-button">Release Spirit</button></div>
            <div id="res-sickness-overlay"></div>
        </div>
    </div>

<script type="module">
const $ = (selector) => document.querySelector(selector);
const $$ = (selector) => document.querySelectorAll(selector);
const distance = (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);

const WORLD_SIZE = 100000;
const STARTING_ZONE_CENTER = { x: 50000, y: 50000 };
const RESPAWN_POINT = { x: 50000, y: 50000 };
const GRAVEYARD_POINT = { x: 48500, y: 48000 };

const GameData = {
    SCENERY: {
        1: { id: 1, name: 'Tall Pine', icon: '\uf1bb', size: 90, color: '#2E7D32' },
        2: { id: 2, name: 'Medium Oak', icon: '\uf1bb', size: 70, color: '#4CAF50' },
        3: { id: 3, name: 'Small Bush', icon: '\uf5bb', size: 40, color: '#689F38' },
        4: { id: 4, name: 'Spruce', icon: '\uf1bb', size: 80, color: '#1B5E20' },
        5: { id: 5, name: 'Cave Wall', icon: '\uf1b2', size: 120, color: '#4a4238' },
        6: { id: 6, name: 'Grass Tuft', icon: '\uf4d8', size: 20, color: '#7CFC00' },
    },
    GEAR_SETS: {
        'goblin_guard': {
            name: "Goblin Guard's Battlegear",
            bonuses: [
                { count: 2, stats: { strength: 5, stamina: 5 }, description: "Set (2): +5 Strength, +5 Stamina" }
            ]
        }
    },
    ITEMS: {
        // (Existing items 1-27, 101-102, 301-303 remain the same)
        1: { id: 1, name: "Rusty Sword", icon: 'fa-gavel', slot: "main-hand", quality: "common", weaponDamage: { min: 3, max: 5 }, durability: 100, maxDurability: 100, sellPrice: 100 },
        2: { id: 2, name: "Worn Leather Vest", icon: "fa-vest-patches", slot: "chest", quality: "common", stats: { armor: 5 }, durability: 100, maxDurability: 100, sellPrice: 150 },
        3: { id: 3, name: "Spider Silk", icon: "fa-network-wired", slot: "material", quality: "common", stackable: true, sellPrice: 50 },
        4: { id: 4, name: "Wolf Fang", icon: "fa-tooth", slot: "material", quality: "common", stackable: true, sellPrice: 40 },
        5: { id: 5, name: "Minor Healing Potion", icon: "fa-flask-vial", slot: "consumable", quality: "common", stackable: true, onUse: (player) => player.heal(50), sellPrice: 25 },
        6: { id: 6, name: "Peacebloom", icon: "fa-leaf", slot: "material", quality: "common", stackable: true, sellPrice: 20 },
        7: { id: 7, name: "Copper Ore", icon: "fa-gem", slot: "material", quality: "common", stackable: true, color: "#b87333", sellPrice: 30 },
        8: { id: 8, name: "Rough Wooden Staff", icon: "fa-staff-snake", slot: "main-hand", quality: "common", weaponDamage: { min: 2, max: 4 }, stats: { intellect: 1 }, durability: 100, maxDurability: 100, sellPrice: 200 },
        9: { id: 9, name: "Thick Leather", icon: "fa-paw", slot: "material", quality: "common", stackable: true, sellPrice: 70 },
        10: { id: 10, name: "Sturdy Wooden Shield", icon: "fa-shield", slot: "off-hand", quality: "common", stats: { armor: 3, stamina: 1 }, durability: 100, maxDurability: 100, sellPrice: 250 },
        11: { id: 11, name: "Bear Flank", icon: "fa-drumstick-bite", slot: "material", quality: "common", stackable: true, sellPrice: 80},
        12: { id: 12, name: "Living Root", icon: "fa-seedling", slot: "material", quality: "magic", stackable: true, sellPrice: 120},
        13: { id: 13, name: "Silverleaf", icon: "fa-seedling", slot: "material", quality: "common", stackable: true, sellPrice: 50 },
        14: { id: 14, name: "Tin Ore", icon: "fa-gem", slot: "material", quality: "common", color: "#a9a9a9", stackable: true, sellPrice: 60 },
        15: { id: 15, name: "Oak Wood", icon: "fa-tree", slot: "material", quality: "common", stackable: true, sellPrice: 55 },
        16: { id: 16, name: "Reinforced Staff", icon: "fa-staff-snake", slot: "main-hand", quality: "magic", weaponDamage: { min: 5, max: 8 }, stats: { intellect: 3 }, durability: 100, maxDurability: 100, sellPrice: 450 },
        17: { id: 17, name: "Oak Shield", icon: "fa-shield", slot: "off-hand", quality: "magic", stats: { armor: 6, stamina: 2 }, durability: 100, maxDurability: 100, sellPrice: 500 },
        18: { id: 18, name: "Copper Bar", icon: "fa-cubes", slot: "material", quality: "common", stackable: true, sellPrice: 65 },
        19: { id: 19, name: "Copper Shortsword", icon: "fa-sword", slot: "main-hand", quality: "common", weaponDamage: { min: 4, max: 6 }, durability: 100, maxDurability: 100, sellPrice: 300 },
        20: { id: 20, name: "Weak Troll's Blood Potion", icon: "fa-flask-vial", slot: "consumable", quality: "common", stackable: true, onUse: (player) => { player.addBuff({ id: 'troll_regen', name: 'Weak Regeneration', icon: 'fa-heart-pulse', duration: 60000, tickRate: 2000, onTick: (p) => p.heal(5), isDebuff: false }); }, sellPrice: 100 },
        21: { id: 21, name: "Copper Mace", icon: "fa-gavel", slot: "main-hand", quality: "common", weaponDamage: { min: 5, max: 7 }, durability: 100, maxDurability: 100, sellPrice: 350 },
        22: { id: 22, name: "Minor Mana Potion", icon: "fa-flask-vial", slot: "consumable", quality: "common", stackable: true, onUse: (player) => { if(player.stats.mana < player.stats.maxMana) player.stats.mana = Math.min(player.stats.maxMana, player.stats.mana + 50); }, sellPrice: 40 },
        23: { id: 23, name: "Reinforced Wooden Buckler", icon: "fa-shield-halved", slot: "off-hand", quality: "magic", stats: { armor: 5, agility: 2 }, durability: 100, maxDurability: 100, sellPrice: 550 },
        24: { id: 24, name: "Tin Bar", icon: "fa-cubes", slot: "material", quality: "common", stackable: true, sellPrice: 120 },
        25: { id: 25, name: "Heavy Copper Armor", icon: "fa-shirt", slot: "chest", quality: "magic", stats: { armor: 12, stamina: 2 }, durability: 100, maxDurability: 100, sellPrice: 800 },
        26: { id: 26, name: "Potion of Swiftness", icon: "fa-flask-vial", slot: "consumable", quality: "magic", stackable: true, onUse: (player) => { player.addBuff({ id: 'swiftness', name: 'Swiftness', icon: 'fa-person-running', duration: 30000, onApply: p => p.speed *= 1.3, onExpire: p => p.speed /= 1.3, isDebuff: false }); }, sellPrice: 250 },
        27: { id: 27, name: "Pickaxe", icon: "fa-person-digging", slot: "tool", quality: "common", stackable: false, sellPrice: 100 },
        
        // --- NEW BOSS LOOT ---
        28: { id: 28, name: "Grolnok's Cleaver", icon: "fa-axe-battle", slot: "main-hand", quality: "epic",
            weaponDamage: { min: 18, max: 25 }, stats: { strength: 5, critChance: 2 },
            description: "The brutal weapon of the Goblin Overlord."
        },
        
        // --- NEW STARTER ITEM ---
        29: { id: 29, name: "Chair", icon: "fa-chair", slot: "material", quality: "common", stackable: true, sellPrice: 75, description: "A simple, but sturdy chair. Good for sitting, or selling." },
        30: { id: 30, name: "Simple Wooden Bow", icon: "fa-crosshairs", slot: "main-hand", quality: "common", 
            weaponDamage: { min: 7, max: 9 }, range: 1500,
            attackSpeed: 2000, 
            durability: 100, maxDurability: 100, sellPrice: 400 
        },
        31: { id: 31, name: "Simple Wooden Arrow", icon: "fa-arrows", slot: "material", quality: "common", 
            stackable: true, maxStack: 99, sellPrice: 5 
        },
        32: { id: 32, name: "Goblin Whelp Egg", icon: "fa-egg", slot: "consumable", quality: "epic",
              description: "A strange, surprisingly warm egg. Use: Teaches you how to summon a Goblin Whelp companion. Can also be fed to a max-level Goblin Whelp to unlock its potential.",
              onUse: (player) => { player.addPet('goblin_whelp'); },
              // --- NEW: Add this property ---
              petId: 'goblin_whelp'
        },
        33: { id: 33, name: "Broodmother's Fang", icon: "fa-tooth", slot: "main-hand", quality: "rare",
              weaponDamage: { min: 8, max: 12 }, stats: { agility: 3 },
              description: "A razor-sharp fang dripping with potent venom." 
        },
        34: { id: 34, name: "Chitinous Leggings", icon: "fa-socks", slot: "legs", quality: "magic",
              stats: { armor: 10, agility: 2 },
              description: "Sturdy leg armor crafted from spider chitin."
        },

        301: { id: 301, name: "Stormwind Tabard", icon: "fa-shirt", slot: "tabard", quality: "rare", description: "A symbol of your dedication to Stormwind. Increases reputation gain with the Stormwind Guard by 10%.", requiredFaction: { name: 'Stormwind Guard', tier: 'Friendly' } },
        302: { id: 302, name: "Guard's Heavy Blade", icon: "fa-gavel", slot: "main-hand", quality: "rare", weaponDamage: { min: 10, max: 15 }, stats: { strength: 3, stamina: 3 }, requiredFaction: { name: 'Stormwind Guard', tier: 'Honored' } },
        303: { id: 303, name: "Commander's Greathelm", icon: "fa-user-shield", slot: "head", quality: "epic", stats: { armor: 15, stamina: 5, strength: 5 }, requiredFaction: { name: 'Stormwind Guard', tier: 'Exalted' } },
        101: { id: 101, name: "Goblin-Forged Blade", icon: "fa-scythe", slot: "main-hand", quality: "rare", weaponDamage: { min: 8, max: 12 }, stats: { strength: 2 }, durability: 100, maxDurability: 100, sellPrice: 500 },
        102: { id: 102, name: "Enchanted Robes", icon: "fa-jedi", slot: "chest", quality: "magic", stats: { armor: 8, intellect: 3 }, durability: 100, maxDurability: 100, sellPrice: 400 },
    },
    ABILITIES: {
        1: { id: 1, name: "Slash", icon: "fa-burst", cost: 0, cooldown: 3000, range: 90, 
            description: "A swift attack that deals 120% of weapon damage plus a bonus from your Attack Power.",
            onUse: (caster, target) => { 
                ParticleSystem.create(target.x, target.y, 'red', 15, 0.1, 10); 
                
                // --- FIX: Perform the damage roll BEFORE calculating the final damage ---
                const damageRange = caster.getWeaponDamage();
                const baseWeaponDamage = Math.floor(Math.random() * (damageRange.max - damageRange.min + 1)) + damageRange.min;

                const finalDamage = (baseWeaponDamage * 1.2) + (caster.stats.attackPower * 0.3); 
                
                target.takeDamage(Math.round(finalDamage), 'physical', caster); 
            }
        },
        2: { 
            id: 2, name: "Fireball", icon: "fa-fire-flame-curved", cost: 10, cooldown: 2000, range: 200, 
            // --- UPDATED LOGIC ---
            onUse: (caster, target) => { 
                // Define the effect that happens ON HIT
                const fireballEffect = (caster, target) => {
                    ParticleSystem.create(target.x, target.y, 'orange', 25, 0.2, 15); 
                    const baseDamage = (caster.stats.intellect * 2) + 10; 
                    const damage = baseDamage * (caster.talentBonuses.fireballDamageMultiplier || 1);
                    target.takeDamage(damage, 'magic', caster); 
                };

                // Create and spawn the projectile
                const projectile = new Projectile(caster, target, 400, '\uf6d6', 'orange', 15, fireballEffect);
                game.entities.push(projectile);
            }
        },
        3: { 
            id: 3, name: "Rend", icon: "fa-skull", cost: 15, cooldown: 6000, range: 90, 
            description: "Wounds the target, causing them to bleed for a small amount of physical damage over 9 seconds.",
            onUse: (caster, target) => { 
                const rendEffectOnHit = (caster, target) => {
                    target.addBuff({ 
                        id: 'rend_dot', name: 'Rend', icon: 'fa-skull', 
                        duration: 9000, tickRate: 3000, isDebuff: true,
                        onTick: (t) => { 
                            const damageRange = caster.getWeaponDamage();
                            const baseWeaponDamage = Math.floor(Math.random() * (damageRange.max - damageRange.min + 1)) + damageRange.min;
                            const damage = baseWeaponDamage * 0.2; 
                            t.takeDamage(damage, 'physical', caster, true); 
                            game.createFloatingText(Math.round(damage), t.x, t.y, '#ff4500'); 
                            ParticleSystem.create(t.x, t.y, '#9a031e', 12, 0.4, 8, { vx: (Math.random() - 0.5) * 50, vy: (Math.random() - 0.5) * 50 });
                        }
                    });
                };
                const projectile = new Projectile(caster, target, 600, '\uf786', '#9a031e', 12, rendEffectOnHit);
                game.entities.push(projectile);
            }
        },
        4: { 
            id: 4, name: "Shoot", icon: "fa-crosshairs", cost: 0, cooldown: 1000, range: 400, 
            description: "A quick shot that deals 100% ranged weapon damage.",
            onUse: (caster, target) => { /* ... Future implementation ... */ }
        },
        5: { 
            id: 5, name: "Blast", icon: "fa-circle-radiation", cost: 20, cooldown: 10000, 
            // Range 0 signifies a self-centered AoE that doesn't require a target
            range: 0, 
            description: "Unleash a wave of arcane energy, dealing magic damage to all enemies within 100 yards.",
            onUse: (caster) => { 
                const AOE_RADIUS = 100;
                
                // Visual effect for the explosion
                ParticleSystem.create(caster.x, caster.y, '#87ceeb', 50, 0.8, 12);
                
                // Calculate damage once
                const damage = (caster.stats.intellect * 2.5) + 15; // Slightly stronger than Fireball
                
                // Find and damage all enemies within the radius
                game.entities.forEach(entity => {
                    if (entity instanceof Enemy && !entity.isDead && distance(caster, entity) <= AOE_RADIUS) {
                        entity.takeDamage(damage, 'magic', caster);
                    }
                });
            }
        },
    },
    ENEMY_TYPES: {
        'WOLF': { name: "Dire Wolf", level: 3,icon: "\uf6f0", color: "#a9a9a9", size: 28, speed: 1.5, health: 80, attack: 5, aggroRadius: 150, attackRange: 40, attackSpeed: 2000, xp: 15, lootTable: [{itemId: 4, chance: 0.8, min: 1, max: 2}, {itemId: 9, chance: 0.5, min: 1, max: 1}, {gold: 50, chance: 1.0}], reputation: { faction: 'Wilderness', value: -10 } },
        'SPIDER': { name: "Forest Spider", level: 2, icon: "\uf717", color: "#654321", size: 25, speed: 1.2, health: 60, attack: 4, aggroRadius: 120, attackRange: 35, attackSpeed: 1800, xp: 10, lootTable: [{itemId: 3, chance: 0.9, min: 1, max: 3}, {gold: 30, chance: 1.0}], reputation: { faction: 'Wilderness', value: -5 } },
        'GOBLIN': { name: "Goblin Thug", level: 6, icon: "\uf7a0", color: "#2E8B57", size: 22, speed: 1.8, health: 120, attack: 8, aggroRadius: 180, attackRange: 45, attackSpeed: 2200, xp: 25, lootTable: [{itemId: 101, chance: 0.1}, {gold: 150, chance: 0.5}], reputation: { faction: 'Stormwind Guard', value: 5 } },
        'DARK_CASTER': { name: "Dark Caster", level: 7, icon: "\uf718", color: "#8A2BE2", size: 24, speed: 1.4, health: 100, attack: 5, aggroRadius: 220, attackRange: 200, attackSpeed: 3000, xp: 30, lootTable: [{gold: 200, chance: 0.8}], onAttack: (caster, target) => { target.addBuff({id: 'curse_of_weakness', name: 'Curse of Weakness', icon: 'fa-skull', duration: 15000, isDebuff: true, stats: { attack: -5 }})}, reputation: { faction: 'Stormwind Guard', value: 10 } },
        'BEAR': { name: "Grizzled Bear", level: 8, icon: "\uf704", color: "#d3a483", size: 35, speed: 1.1, health: 200, attack: 12, aggroRadius: 140, attackRange: 45, attackSpeed: 2500, xp: 35, lootTable: [{itemId: 11, chance: 0.9, min: 1, max: 2}, {gold: 100, chance: 1.0}], reputation: { faction: 'Wilderness', value: -20 } },
        'TREANT': { name: "Treant Sapling", level: 5, icon: "\uf1bb", color: "#66827a", size: 30, speed: 1.3, health: 110, attack: 7, aggroRadius: 160, attackRange: 150, attackSpeed: 2800, xp: 28, lootTable: [{itemId: 12, chance: 0.6}, {gold: 80, chance: 1.0}], onAttack: (caster, target) => { if (Math.random() < 0.25) { target.addBuff({id: 'entangling_roots', name: 'Entangling Roots', icon: 'fa-vine', duration: 5000, isDebuff: true, onApply: (t) => t.isRooted = true, onExpire: (t) => t.isRooted = false }); } }, reputation: { faction: 'Wilderness', value: -15 } },
        'GOBLIN_STALKER': { name: "Goblin Stalker", level: 9, icon: "\uf6d5", color: "#9acd32", size: 20, speed: 2.2, health: 90, attack: 10, aggroRadius: 170, attackRange: 40, attackSpeed: 1600, xp: 30, lootTable: [{gold: 180, chance: 0.9}], reputation: { faction: 'Stormwind Guard', value: 7 } },
        'GOBLIN_GUARD': { name: "Goblin Guard", level: 10, icon: "\uf7a0", color: "#556B2F", size: 25, speed: 1.6, health: 250, attack: 15, aggroRadius: 200, attackRange: 45, attackSpeed: 2000, xp: 50, lootTable: [{gold: 300, chance: 1.0}], reputation: { faction: 'Stormwind Guard', value: 15 } },
        
        // --- VERIFIED AND CORRECTED BOSS DEFINITION ---
        'GOBLIN_BOSS': { 
            name: "Overlord Grolnok", level: 12, icon: "\uf6a4", color: "#8B0000", size: 40, speed: 1.2, health: 100, attack: 5, aggroRadius: 300, attackRange: 50, attackSpeed: 2500, xp: 200, 
            lootTable: [
                {itemId: 28, chance: 0.2},
                {itemId: 29, chance: 0.5},
                {itemId: 30, chance: 0.5},
                {itemId: 32, chance: 1.0},
                {gold: 5000, chance: 1.0}
            ], 
            reputation: { faction: 'Stormwind Guard', value: 100 },
            onAttack: (caster, target) => {
                if (!caster.summonCooldown || Date.now() > caster.summonCooldown) {
                    caster.summonCooldown = Date.now() + 10000;
                    if (Math.random() < 0.5) {
                        game.createFloatingText("Grolnok calls for help!", caster.x, caster.y - 40, 'orange');
                        const spawnX = caster.x + (Math.random() > 0.5 ? 60 : -60);
                        const spawnY = caster.y + (Math.random() > 0.5 ? 60 : -60);
                        game.entities.push(new Enemy(spawnX, spawnY, GameData.ENEMY_TYPES['GOBLIN_GUARD']));
                    }
                }
            }
        },
        'VENOMFANG_LURKER': { 
            name: "Venomfang Lurker", level: 4, icon: "\uf717", color: "#3c1a42", size: 28, speed: 1.4, 
            health: 150, attack: 10, aggroRadius: 160, attackRange: 40, attackSpeed: 2000, xp: 40, 
            lootTable: [
                {itemId: 3, chance: 0.9, min: 2, max: 4}, // More Spider Silk
                {gold: 200, chance: 1.0}
            ], 
            reputation: { faction: 'Wilderness', value: -15 } 
        },
        'SPIDER_BOSS': { 
            name: "Arachna, the Broodmother", level: 6, icon: "\uf717", color: "#6e0d60", size: 45, speed: 1.1, 
            health: 800, attack: 20, aggroRadius: 250, attackRange: 45, attackSpeed: 2200, xp: 150, 
            lootTable: [
                {itemId: 33, chance: 0.5}, // Broodmother's Fang
                {itemId: 34, chance: 1.0}, // Chitinous Leggings (guaranteed drop)
                {gold: 3000, chance: 1.0}
            ], 
            reputation: { faction: 'Wilderness', value: -75 },
            onAttack: (caster, target) => { // Boss ability: summon smaller spiders
                if (!caster.summonCooldown || Date.now() > caster.summonCooldown) {
                    caster.summonCooldown = Date.now() + 12000;
                    if (Math.random() < 0.6) {
                        game.createFloatingText("Arachna summons her brood!", caster.x, caster.y - 40, 'purple');
                        const spawnX = caster.x + (Math.random() > 0.5 ? 50 : -50);
                        const spawnY = caster.y + (Math.random() > 0.5 ? 50 : -50);
                        // Summons a regular Forest Spider
                        game.entities.push(new Enemy(spawnX, spawnY, GameData.ENEMY_TYPES['SPIDER']));
                    }
                }
            }
        },
    },
    NPC_TYPES: {
        'BLACKSMITH': { name: "Barton the Blacksmith", icon: '\uf0e7', color: '#a9a9a9', interactType: 'repair' },
        'SPIRIT_HEALER': { name: "Spirit Healer", icon: '\uf70e', color: '#a0c4ff', interactType: 'resurrect', interaction: (player) => { if (player.isGhost) { const doRes = confirm("Resurrect here? You will suffer Resurrection Sickness and your equipped items will lose durability."); if(doRes) { player.resurrectAtHealer(); } } else { alert("The spirits can only help the dead."); } } },
        
        // --- THIS IS THE VENDOR TO FIX ---
        'GENERAL_VENDOR': { 
            name: "General Goods Vendor", icon: '\uf54e', color: '#c0c0c0', interactType: 'vendor', 
            // FIX: Add 'main-hand' to this array
            buys: ['consumable', 'material', 'main-hand', 'off-hand', 'head', 'chest', 'tabard'],
            startingGold: 100099,
            sells: [{itemId: 5, quantity: 5, price: 50}] 
        },

        'WOODWORKING_TRAINER': { name: "Master Woodworker", icon: '\uf6f8', color: '#8b4513', interactType: 'crafting_trainer', professions: ['Woodworking', 'Lumberjacking'] },
        'BLACKSMITHING_TRAINER': { name: "Thorin the Smith", icon: '\uf6e3', color: '#d2b48c', interactType: 'crafting_trainer', professions: ['Blacksmithing', 'Mining'] },
        'ALCHEMIST': { name: "Alchemist Fiona", icon: '\uf5a7', color: '#9932cc', interactType: 'crafting_trainer', professions: ['Alchemy', 'Herbalism'] },

        'QUARTERMASTER': { name: "Stormwind Quartermaster", icon: '\uf4f7', color: '#0070dd', interactType: 'vendor', faction: 'Stormwind Guard', sells: [
            { itemId: 301, price: 5000 },
            { itemId: 302, price: 25000 },
            { itemId: 303, price: 100000 },
        ], buys: [] },
    },
    QUESTS: { 
        // (Existing quests 1, 2, 3, 101, 102, 103, 104 remain the same)
        1: { id: 1, title: "A Tangled Web", description: "The forest path is overrun with spiders. Clear out 5 of them so travelers can pass safely.", objectives: [{ type: 'kill', target: 'SPIDER', count: 5 }], rewards: { xp: 100, gold: 1000, items: [{id: 2, quantity: 1}], reputation: { faction: 'Stormwind Guard', value: 50 } }, repeatable: false },
        2: { id: 2, title: "Wolf Hunting", description: "The local farmers are losing livestock to dire wolves. Hunt 3 dire wolves.", objectives: [{ type: 'kill', target: 'WOLF', count: 3 }], rewards: { xp: 80, gold: 800, items: [{id: 4, quantity: 1}], reputation: { faction: 'Stormwind Guard', value: 40 } }, repeatable: true, cooldown: 3600000 },
        3: { id: 3, title: "Bear Necessities", description: "Grizzled Bears have become a threat. Thin their numbers by slaying 3 of them.", objectives: [{ type: 'kill', target: 'BEAR', count: 3 }], rewards: { xp: 150, gold: 1500 }, repeatable: true, cooldown: 1800000 },
        101: { id: 101, title: "Advanced Woodworking", description: "You've shown promise, young artisan. To further your skills, craft 2 Rough Wooden Staves and 2 Sturdy Wooden Shields. Your dedication will be rewarded.", requirements: [{ type: 'profession', name: 'Woodworking', level: 10 }], objectives: [ { type: 'craft', itemId: 8, count: 2 }, { type: 'craft', itemId: 10, count: 2 } ], rewards: { xp: 200, gold: 2000, recipes: ['reinforced_staff', 'oak_shield'] }, repeatable: false },
        102: { id: 102, title: "The Art of the Forge", description: "You've proven adept at finding ore. Now, let's see if you can shape it. Smelt 10 Copper Bars and bring them to me. A true smith knows their materials.", requirements: [{ type: 'profession', name: 'Mining', level: 10 }], objectives: [ { type: 'gather', itemId: 18, count: 10 } ], rewards: { xp: 250, gold: 2500, recipes: ['copper_mace'] }, repeatable: false },
        103: { id: 103, title: "Budding Alchemist", description: "You have a feel for the flora of the woods. Bring me 10 Peacebloom so I can teach you how to unlock their latent power.", requirements: [{ type: 'profession', name: 'Herbalism', level: 10 }], objectives: [ { type: 'gather', itemId: 6, count: 10 } ], rewards: { xp: 200, gold: 1500, recipes: ['minor_mana_potion'] }, repeatable: false },
        104: { id: 104, title: "A Sturdy Foundation", description: "A good shield starts with good wood. Your skill with an axe is growing. Bring me 15 Oak Wood, and I will show you a more advanced design.", requirements: [{ type: 'profession', name: 'Lumberjacking', level: 10 }], objectives: [ { type: 'gather', itemId: 15, count: 15 } ], rewards: { xp: 200, gold: 1500, recipes: ['reinforced_buckler'] }, repeatable: false },
        // --- NEW TIER 2 QUESTS ---
        201: {
            id: 201, title: "Working with Tin",
            description: "Copper is useful, but Tin is stronger. The foothills to the east are rich with it. Bring me 10 Tin Ore, and I will teach you how to smelt it.",
            requirements: [{ type: 'profession', name: 'Mining', level: 20 }],
            objectives: [ { type: 'gather', itemId: 14, count: 10 } ],
            rewards: { xp: 400, gold: 3000, recipes: ['tin_bar', 'heavy_copper_armor'] },
            repeatable: false
        },
        202: {
            id: 202, title: "The Elusive Silverleaf",
            description: "Not all herbs are as common as Peacebloom. Silverleaf is more potent and grows in more secluded places. Gather 5 Silverleaf for me, and I'll teach you a recipe that harnesses its energy.",
            requirements: [{ type: 'profession', name: 'Herbalism', level: 20 }],
            objectives: [ { type: 'gather', itemId: 13, count: 5 } ],
            rewards: { xp: 350, gold: 2500, recipes: ['potion_of_swiftness'] },
            repeatable: false
        },
    },
    XP_TABLE: [0, 100, 250, 500, 1000, 2000, 4000, 8000, 12000, 18000],
    TALENTS: {
        'HUMAN_WARRIOR': [
            { id: 'str1', name: 'Toughness', maxRank: 5, icon: 'fa-hand-fist', description: 'Increases total Stamina by 2% per rank.', requires: null, apply: (p, r) => p.statBonuses.staminaBonus = (p.statBonuses.staminaBonus || 0) + 0.02 * r },
            { id: 'crit1', name: 'Cruelty', maxRank: 5, icon: 'fa-gavel', description: 'Increases critical strike chance by 1% per rank.', requires: null, apply: (p, r) => p.stats.critChance = (p.baseStats.critChance || 0) + (1 * r) },
        ],
        'ELF_MAGE': [
            { id: 'rend1', name: 'Improved Rend', maxRank: 3, icon: 'fa-heart-crack', description: 'Increases the damage of your Rend ability by 15% per rank.', requires: null, apply: (p, r) => p.talentBonuses.rendDamageMultiplier = (p.talentBonuses.rendDamageMultiplier || 1) + 0.15 * r},
            { id: 'ef1', name: 'Eternal Flame', maxRank: 3, icon: 'fa-fire-flame-curved', description: 'Increases the damage of your Fireball ability by 15% per rank.', requires: null, apply: (p, r) => p.talentBonuses.fireballDamageMultiplier = (p.talentBonuses.fireballDamageMultiplier || 1) + 0.15 * r},
            { id: 'str1', name: 'Toughness', maxRank: 5, icon: 'fa-hand-fist', description: 'Increases total Stamina by 2% per rank.', requires: null, apply: (p, r) => p.statBonuses.staminaBonus = (p.statBonuses.staminaBonus || 0) + 0.02 * r },
            { id: 'crit1', name: 'Cruelty', maxRank: 5, icon: 'fa-gavel', description: 'Increases critical strike chance by 1% per rank.', requires: null, apply: (p, r) => p.stats.critChance = (p.baseStats.critChance || 0) + (1 * r) },
        ]
    },
    FACTIONS: {
        'Stormwind Guard': { name: 'Stormwind Guard', tiers: ['Hated', 'Hostile', 'Unfriendly', 'Neutral', 'Friendly', 'Honored', 'Revered', 'Exalted'], base: 3000, values: [-42000, -6000, -3000, 0, 3000, 9000, 21000, 999999] },
        'Wilderness': { name: 'The Wilds', tiers: ['Ally', 'Neutral', 'Enemy'], base: 0, values: [0, 1000, -1000] },
    },
    RESOURCE_NODES: {
        // Tier 1 Resources (Skill 1+)
        'PEACEBLOOM': { name: 'Peacebloom', icon: '\uf06c', color: '#adff2f', size: 20, itemId: 6, respawnTime: 30000, requiredSkill: 'Herbalism', requiredSkillLevel: 1, gatherTime: 1500, yield: 1 },
        'COPPER_VEIN': { name: 'Copper Vein', icon: '\uf3a5', color: '#b87333', size: 24, itemId: 7, respawnTime: 60000, requiredSkill: 'Mining', requiredSkillLevel: 1, gatherTime: 2500, yield: 1 },
        
        // --- FIX: Added yield: 2 to this node ---
        'OAK_LOGS': { name: 'Oak Tree', icon: '\uf1bb', color: '#8b4513', size: 28, itemId: 15, respawnTime: 75000, requiredSkill: 'Lumberjacking', requiredSkillLevel: 1, gatherTime: 3000, yield: 2 },
        
        // Tier 2 Resources (Skill 20+)
        'SILVERLEAF': { name: 'Silverleaf', icon: '\uf4d8', color: '#c0c0c0', size: 22, itemId: 13, respawnTime: 45000, requiredSkill: 'Herbalism', requiredSkillLevel: 20, gatherTime: 1500, yield: 1 },
        'TIN_VEIN': { name: 'Tin Vein', icon: '\uf3a5', color: '#a9a9a9', size: 26, itemId: 14, respawnTime: 90000, requiredSkill: 'Mining', requiredSkillLevel: 20, gatherTime: 4000, yield: 1 },
    },
    CRAFTING_RECIPES: {
        'wooden_staff': { id: 'wooden_staff', name: 'Rough Wooden Staff', icon: 'fa-staff-snake', itemId: 8, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 15, quantity: 5}], time: 3000, playerXpGain: 10 },
        'wooden_shield': { id: 'wooden_shield', name: 'Sturdy Wooden Shield', icon: 'fa-shield', itemId: 10, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 15, quantity: 3}, {itemId: 9, quantity: 2}], time: 4000, playerXpGain: 10 },
        'reinforced_staff': { id: 'reinforced_staff', name: 'Reinforced Staff', icon: 'fa-staff-snake', itemId: 16, profession: 'Woodworking', skillRequired: 10, materials: [{itemId: 15, quantity: 8}, {itemId: 7, quantity: 2}], time: 5000, playerXpGain: 20 },
        'oak_shield': { id: 'oak_shield', name: 'Oak Shield', icon: 'fa-shield', itemId: 17, profession: 'Woodworking', skillRequired: 10, materials: [{itemId: 15, quantity: 6}, {itemId: 9, quantity: 4}], time: 6000, playerXpGain: 20 },
        'copper_bar': { id: 'copper_bar', name: 'Copper Bar', icon: 'fa-cubes', itemId: 18, profession: 'Blacksmithing', skillRequired: 1, materials: [{itemId: 7, quantity: 2}], time: 2000, playerXpGain: 20 },
        'copper_shortsword': { id: 'copper_shortsword', name: 'Copper Shortsword', icon: 'fa-sword', itemId: 19, profession: 'Blacksmithing', skillRequired: 5, materials: [{itemId: 18, quantity: 5}], time: 5000, playerXpGain: 30 },
        'weak_trolls_blood': { id: 'weak_trolls_blood', name: "Weak Troll's Blood Potion", icon: 'fa-flask-vial', itemId: 20, profession: 'Alchemy', skillRequired: 1, materials: [{itemId: 6, quantity: 2}, {itemId: 13, quantity: 1}], time: 3000, playerXpGain: 50 },
        'copper_mace': { id: 'copper_mace', name: 'Copper Mace', icon: 'fa-gavel', itemId: 21, profession: 'Blacksmithing', skillRequired: 10, materials: [{itemId: 18, quantity: 7}], time: 6000, playerXpGain: 50 },
        'minor_mana_potion': { id: 'minor_mana_potion', name: 'Minor Mana Potion', icon: 'fa-flask-vial', itemId: 22, profession: 'Alchemy', skillRequired: 10, materials: [{itemId: 6, quantity: 1}, {itemId: 12, quantity: 1}], time: 3000, playerXpGain: 100 },
        'reinforced_buckler': { id: 'reinforced_buckler', name: 'Reinforced Wooden Buckler', icon: 'fa-shield-halved', itemId: 23, profession: 'Woodworking', skillRequired: 10, materials: [{itemId: 15, quantity: 10}, {itemId: 18, quantity: 1}], time: 7000, playerXpGain: 50 },
        
        // --- FIX: Added the 'fa-pickaxe' icon to this recipe ---
        'pickaxe': { id: 'pickaxe', name: 'Pickaxe', icon: 'fa-person-digging', itemId: 27, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 15, quantity: 5}], time: 3000, playerXpGain: 50 },
        
        'chair': { id: 'chair', name: 'Chair', icon: 'fa-chair', itemId: 29, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 15, quantity: 1}], time: 2000, playerXpGain: 10 },
        'simple_wooden_bow': { 
            id: 'simple_wooden_bow', name: 'Simple Wooden Bow', icon: 'fa-crosshairs', itemId: 30, 
            profession: 'Woodworking', skillRequired: 3, 
            materials: [{itemId: 15, quantity: 10}], time: 5000, 
            playerXpGain: 25,
        },
        'simple_wooden_arrow': { 
            id: 'simple_wooden_arrow', name: 'Simple Wooden Arrow', icon: 'fa-arrows', itemId: 31, 
            profession: 'Woodworking', skillRequired: 3, 
            materials: [{itemId: 15, quantity: 1}], time: 2000,
            xpGain: 15,   // Gives 5 Woodworking XP
            yield: 10,    // Yields 10 arrows per craft
            playerXpGain: 20 
        },

        'tin_bar': { id: 'tin_bar', name: 'Tin Bar', icon: 'fa-cubes', itemId: 24, profession: 'Blacksmithing', skillRequired: 20, materials: [{itemId: 14, quantity: 2}], time: 2500, playerXpGain: 50 },
        'heavy_copper_armor': { id: 'heavy_copper_armor', name: 'Heavy Copper Armor', icon: 'fa-shirt', itemId: 25, profession: 'Blacksmithing', skillRequired: 25, materials: [{itemId: 18, quantity: 10}, {itemId: 24, quantity: 2}], time: 8000, playerXpGain: 50 },
        'potion_of_swiftness': { id: 'potion_of_swiftness', name: 'Potion of Swiftness', icon: 'fa-flask-vial', itemId: 26, profession: 'Alchemy', skillRequired: 20, materials: [{itemId: 13, quantity: 3}], time: 4000, playerXpGain: 50 },
    },
    SKILL_RECIPE_UNLOCKS: {
        'Lumberjacking': [], 
        'Woodworking': [
            { level: 1, recipeId: 'chair' },
            { level: 2, recipeId: 'pickaxe' },
            // --- NEW: Unlock the bow recipe at Woodworking level 3 ---
            { level: 3, recipeId: 'simple_wooden_bow' }
        ]
    },
    PROFESSIONS: {
        'Herbalism': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        'Mining': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        'Woodworking': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 50 },
        'Lumberjacking': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        // --- NEW PROFESSIONS ---
        'Blacksmithing': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 50 },
        'Alchemy': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 50 },
    },
    REGIONS: [
        {
            id: 'starting_zone', name: 'Whispering Woods', x: 20000, y: 20000, width: 60000, height: 60000,
            isRestZone: true,
            bgColor: "#182c18",
            sceneryPatches: [ { type: [1, 2, 3, 4, 6], density: 3750, patchCenter: {x: 50000, y: 50000}, patchRadius: 10000 } ],
            enemyPacks: [
                { type: 'SPIDER', count: 200, levelMin: 1, levelMax: 5, packCenter: {x: 50000, y: 50000}, packRadius: 4000 },
                { type: 'WOLF', count: 150, levelMin: 10, levelMax: 20, packCenter: {x: 35000, y: 35000}, packRadius: 8000 }, // Top-left
                { type: 'BEAR', count: 150, levelMin: 10, levelMax: 20, packCenter: {x: 65000, y: 35000}, packRadius: 8000 }, // Top-right
                { type: 'TREANT', count: 150, levelMin: 10, levelMax: 20, packCenter: {x: 35000, y: 65000}, packRadius: 8000 }, // Bottom-left
                { type: 'GOBLIN_STALKER', count: 150, levelMin: 10, levelMax: 20, packCenter: {x: 65000, y: 65000}, packRadius: 8000 }, // Bottom-right
            ],
            resourcePatches: [
                { type: 'PEACEBLOOM', count: 600, patchCenter: {x: 52000, y: 51000}, patchRadius: 4000 }, // 10x from 160
                { type: 'COPPER_VEIN', count: 400, patchCenter: {x: 48000, y: 54000}, patchRadius: 3500 }, // 10x from 140
                { type: 'OAK_LOGS', count: 450, patchCenter: {x: 55000, y: 48000}, patchRadius: 4500 },     // 10x from 120
            ],
            npcs: [
                { type: 'QuestGiver', name: "Old Man Willow", x: 50000, y: 49500, questIds: [1, 2, 3] },
                // --- NEW: Add the cabin as a specifically placed scenery object ---
                { type: 'PlayerHouse', houseId: 'CABIN', x: 50150, y: 49550 },
                { type: 'Portal', name: "To the Goblin Hideout", x: 50300, y: 49400, target: { x: 87500, y: 29000 } },
                { type: 'DungeonEntrance', name: "Spider Lair", x: 44000, y: 44000, target: { x: 20500, y: 84500 } },
                { type: 'GenericNPC', npcType: 'BLACKSMITH', x: 49000, y: 50500 },
                { type: 'GenericNPC', npcType: 'GENERAL_VENDOR', x: 51000, y: 50500 },
                { type: 'GenericNPC', npcType: 'SPIRIT_HEALER', x: 48500, y: 48000 },
                { type: 'QuestGiver', name: "Master Woodworker", npcType: 'WOODWORKING_TRAINER', x: 49000, y: 49500, questIds: [101, 104] },
                { type: 'CraftingStation', stationType: 'WOODWORKING_BENCH', x: 49000, y: 49600 },
                { type: 'QuestGiver', name: "Thorin the Smith", npcType: 'BLACKSMITHING_TRAINER', x: 49100, y: 50500, questIds: [102, 201] },
                { type: 'CraftingStation', stationType: 'FORGE', x: 49100, y: 50600 },
                { type: 'QuestGiver', name: "Alchemist Fiona", npcType: 'ALCHEMIST', x: 51000, y: 49500, questIds: [103, 202] },
                { type: 'CraftingStation', stationType: 'ALCHEMY_TABLE', x: 51000, y: 49600 },
                { type: 'GenericNPC', npcType: 'QUARTERMASTER', x: 50500, y: 50500 },
                { type: 'Portal', name: "To the Stonetalon Foothills", x: 50600, y: 50600, target: { x: 87000, y: 44900 } }
            ]
        },
        {
            id: 'foothills', name: 'Stonetalon Foothills', x: 80000, y: 40000, width: 15000, height: 40000,
            bgColor: "#4a4238",
            sceneryPatches: [ { type: [1, 4], density: 80, patchCenter: {x: 87500, y: 60000}, patchRadius: 10000 } ],
            enemyPacks: [
                { type: 'GOBLIN', count: 250, levelMin: 40, levelMax: 50, packCenter: {x: 85000, y: 50000}, packRadius: 10000 },
                { type: 'DARK_CASTER', count: 100, levelMin: 50, levelMax: 60, packCenter: {x: 83000, y: 60000}, packRadius: 6000 },
            ],
            resourcePatches: [ 
                { type: 'TIN_VEIN', count: 1200, patchCenter: {x: 87000, y: 55000}, patchRadius: 8000 },    // 10x from 120
                { type: 'SILVERLEAF', count: 800, patchCenter: {x: 84000, y: 48000}, patchRadius: 6000 },   // 10x from 80
            ],
            npcs: [
                { type: 'Portal', name: "Back to Town", x: 87000, y: 44900, target: { x: 50600, y: 50600 } },
                { type: 'DungeonEntrance', name: "Goblin Cave", x: 87100, y: 45000, target: { x: 80500, y: 84500 } }
            ]
        },
        {
            id: 'goblin_camp', name: 'Goblin Hideout', x: 80000, y: 10000, width: 15000, height: 30000,
            bgColor: "#3b302c",
            sceneryPatches: [ { type: [1, 4], density: 50, patchCenter: {x: 87500, y: 25000}, patchRadius: 7500 } ],
            enemyPacks: [
                { type: 'GOBLIN', count: 300, levelMin: 40, levelMax: 50, packCenter: {x: 85000, y: 20000}, packRadius: 6000 },
                { type: 'DARK_CASTER', count: 100, levelMin: 45, levelMax: 55, packCenter: {x: 88000, y: 15000}, packRadius: 2000 },
            ],
            resourcePatches: [ 
                { type: 'COPPER_VEIN', count: 800, patchCenter: {x: 82000, y: 18000}, patchRadius: 4000 }, // 10x from 80
            ],
            npcs: [
                { type: 'Portal', name: "Back to the Woods", x: 87500, y: 29000, target: { x: 50300, y: 49400 } }
            ]
        },
        {
            id: 'goblin_cave', name: 'The Goblin Cave', x: 80000, y: 80000, width: 5000, height: 5000,
            isDungeon: true,
            bgColor: "#3b302c",
            sceneryPatches: [ { type: [5], density: 50, patchCenter: {x: 82500, y: 82500}, patchRadius: 2500 } ],
            enemyPacks: [
                { type: 'GOBLIN_GUARD', count: 50, levelMin: 35, levelMax: 40, packCenter: {x: 82500, y: 82500}, packRadius: 4000 },
                { type: 'GOBLIN_BOSS', count: 1, levelMin: 40, levelMax: 40, packCenter: {x: 84000, y: 81000}, packRadius: 100 },
            ],
            npcs: [
                { type: 'DungeonEntrance', name: "Exit Cave", x: 80500, y: 84500, isExit: true }
            ]
        },
        {
            id: 'player_house_interior', name: 'Your Cozy Home', x: 10000, y: 10000, 
            // --- FIX: Made the interior much smaller for a room-like feel ---
            width: 800, height: 600,
            isDungeon: true,
            bgColor: "#e6d5b8", 
            sceneryPatches: [], 
            enemyPacks: [],
            resourcePatches: [],
            npcs: [
                { type: 'StorageContainer', x: 10100, y: 10100, icon: '\ue188', size: 50, color: '#a0522d' },
                { type: 'DungeonEntrance', name: "Exit", x: 10400, y: 10550, isExit: true }
            ]
        },
        {
            id: 'spider_lair', name: 'The Spider Lair', x: 20000, y: 80000, width: 5000, height: 5000,
            isDungeon: true,
            bgColor: "#2a1d2c",
            sceneryPatches: [ { type: [5], density: 40, patchCenter: {x: 22500, y: 82500}, patchRadius: 2500 } ],
            enemyPacks: [
                { type: 'VENOMFANG_LURKER', count: 60, levelMin: 25, levelMax: 35, packCenter: {x: 22500, y: 82500}, packRadius: 2000 },
                { type: 'SPIDER_BOSS', count: 1, levelMin: 35, levelMax: 35, packCenter: {x: 24000, y: 81000}, packRadius: 100 },
            ],
            npcs: [
                // The exit portal
                { type: 'DungeonEntrance', name: "Exit Lair", x: 20500, y: 84500, isExit: true }
            ]
        }
    ],
    // --- NEW CRAFTING STATIONS ---
    CRAFTING_STATIONS: {
        'WOODWORKING_BENCH': {
            name: 'Woodworking Bench', icon: '\uf6e3', color: '#8B4513',
            recipes: ['chair', 'wooden_staff', 'wooden_shield', 'reinforced_staff', 'oak_shield', 'pickaxe', 'simple_wooden_bow', 'simple_wooden_arrow']
        },
        'FORGE': {
            name: 'Forge', icon: '\uf6e3', color: '#d2691e',
            recipes: ['copper_bar', 'copper_shortsword', 'tin_bar', 'heavy_copper_armor']
        },
        'ALCHEMY_TABLE': {
            name: 'Alchemy Table', icon: '\uf5a7', color: '#9932cc',
            recipes: ['weak_trolls_blood', 'minor_mana_potion', 'potion_of_swiftness']
        }
    },
    PLAYER_HOUSE_DATA: {
        'CABIN': { 
            name: 'Abandoned Cabin', icon: '\uf015', size: 90, color: '#8B4513', 
            isCollidable: true,
            // --- FIX: Updated the target to a safe spot in the new smaller room ---
            target: { x: 10400, y: 10300 }
        }
    },
        PETS: {
        'goblin_whelp': {
            name: "Goblin Whelp",
            icon: '\uf7a0',
            color: '#9acd32',
            size: 18,
            maxLevel: 10, // The initial level cap
            favoriteFoods: {
                3: 10,  // Spider Silk
                4: 15,  // Wolf Fang
                11: 25, // Bear Flank
            },
            // --- EXPANDED to 20 levels ---
            xpPerLevel: [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900],
            statsByLevel: [
                { stats: { stamina: 1 } }, // Level 1
                { stats: { stamina: 2 } }, // Level 2
                { stats: { stamina: 3 } }, // Level 3
                { stats: { stamina: 4 } }, // Level 4
                { stats: { stamina: 5 } }, // Level 5
                { stats: { stamina: 6, strength: 1 } }, // Level 6
                { stats: { stamina: 7, strength: 2 } }, // Level 7
                { stats: { stamina: 8, strength: 3 } }, // Level 8
                { stats: { stamina: 9, strength: 4 } }, // Level 9
                { stats: { stamina: 10, strength: 5 } },// Level 10
                // --- NEW BREAKTHROUGH LEVELS ---
                { stats: { stamina: 12, strength: 6 } },// Level 11
                { stats: { stamina: 14, strength: 7 } },// Level 12
                { stats: { stamina: 16, strength: 8 } },// Level 13
                { stats: { stamina: 18, strength: 9 } },// Level 14
                { stats: { stamina: 20, strength: 10 } },// Level 15 (Your specified bonus)
                { stats: { stamina: 23, strength: 11 } },// Level 16
                { stats: { stamina: 26, strength: 12 } },// Level 17
                { stats: { stamina: 29, strength: 13 } },// Level 18
                { stats: { stamina: 32, strength: 14 } },// Level 19
                { stats: { stamina: 35, strength: 15 } },// Level 20 (Your specified bonus)
            ]
        }
    },
};

let game;

class Game {
    constructor(playerOptions) {
        this.canvas = $("#game-canvas"); this.ctx = this.canvas.getContext("2d");
        this.lastTime = 0; this.entities = []; this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        this.init(playerOptions);
    }
    init(playerOptions) {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        this.input = new InputHandler(this.isMobile);
        this.world = new World(this.ctx, WORLD_SIZE, WORLD_SIZE);
        ParticleSystem.init(this.ctx);
        
        if (playerOptions) { 
            this.player = new Player(RESPAWN_POINT.x, RESPAWN_POINT.y, this.input, playerOptions.name, playerOptions.race);
            this.player.autoSlotAbilities();
            this.player.addItem(32, 2); // Goblin Whelp Egg for testing 
        } else { 
            this.player = new Player(RESPAWN_POINT.x, RESPAWN_POINT.y, this.input, 'Hero', 'Human'); 
        }

        this.ui = new UI(this);
        this.camera = new Camera(this.player, this.canvas.width, this.canvas.height);
        
        if (!playerOptions && !this.loadGame()) {
            console.error("Failed to load game, but no new character options were provided.");
            showMainMenu(); 
            return;
        } else if (playerOptions) {
            this.spawnEntities(); 
        }

        this.ui.updateAll(this.player);
        this.setupUIInteractions(); 
        this.initAtmosphere();
        setInterval(() => this.saveGame(true), 30000);
        this.gameLoop(0);
    }
    resizeCanvas() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; if(this.camera) { this.camera.width = this.canvas.width; this.camera.height = this.canvas.height; } }
    
    spawnEntities() {
        this.entities = [];

        GameData.REGIONS.forEach(regionData => {
            if (regionData.npcs) {
                regionData.npcs.forEach(npc => {
                    let npcEntity;
                    if (npc.type === 'QuestGiver') {
                        npcEntity = new QuestGiver(npc.x, npc.y, npc.name, npc.questIds, npc.npcType);
                    } else if (npc.type === 'GenericNPC') {
                        npcEntity = new GenericNPC(npc.x, npc.y, GameData.NPC_TYPES[npc.npcType]);
                    } else if (npc.type === 'CraftingStation') {
                        npcEntity = new CraftingStation(npc.x, npc.y, GameData.CRAFTING_STATIONS[npc.stationType]);
                    } else if (npc.type === 'DungeonEntrance') {
                        npcEntity = new DungeonEntrance(npc.x, npc.y, npc.name, npc.target, npc.isExit);
                    } 
                    else if (npc.type === 'Portal') {
                        npcEntity = new Portal(npc.x, npc.y, npc.name, npc.target);
                    }
                    // --- NEW: Add a case to handle specifically placed scenery ---
                    else if (npc.type === 'Scenery') {
                        const sceneryData = GameData.SCENERY[npc.sceneryId];
                        if (sceneryData) {
                            npcEntity = new Scenery(npc.x, npc.y, sceneryData);
                        }
                    }
                    else if (npc.type === 'PlayerHouse') {
                        const houseData = GameData.PLAYER_HOUSE_DATA[npc.houseId];
                        if (houseData) {
                            npcEntity = new PlayerHouse(npc.x, npc.y, houseData);
                        }
                    }
                    else if (npc.type === 'StorageContainer') {
                        npcEntity = new StorageContainer(npc.x, npc.y, npc.icon, npc.color, npc.size);
                    }
                    if (npcEntity) this.entities.push(npcEntity);
                });
            }
            
            if (regionData.enemyPacks) {
                regionData.enemyPacks.forEach(pack => {
                    for (let i = 0; i < pack.count; i++) {
                        // --- THIS IS THE BLOCK TO REPLACE ---
                        let x = pack.packCenter.x + (Math.random() - 0.5) * 2 * pack.packRadius;
                        let y = pack.packCenter.y + (Math.random() - 0.5) * 2 * pack.packRadius;
                        
                        // --- NEW: Safe Zone Logic ---
                        const SAFE_ZONE_RADIUS = 1300;
                        const distFromOrigin = distance({x, y}, RESPAWN_POINT);

                        if (distFromOrigin < SAFE_ZONE_RADIUS) {
                            // This spawn is inside the safe zone. Let's push it out.
                            const angle = Math.atan2(y - RESPAWN_POINT.y, x - RESPAWN_POINT.x);
                            x = RESPAWN_POINT.x + Math.cos(angle) * SAFE_ZONE_RADIUS;
                            y = RESPAWN_POINT.y + Math.sin(angle) * SAFE_ZONE_RADIUS;
                        }
                        // --- END of Safe Zone Logic ---

                        let level = null;
                        if (pack.levelMin && pack.levelMax) {
                            level = Math.floor(Math.random() * (pack.levelMax - pack.levelMin + 1)) + pack.levelMin;
                        }
                        
                        this.entities.push(new Enemy(x, y, GameData.ENEMY_TYPES[pack.type], level));
                        // --- END OF REPLACEMENT BLOCK ---
                    }
                });
            }

            if (regionData.resourcePatches) {
                regionData.resourcePatches.forEach(patch => {
                    for (let i = 0; i < patch.count; i++) {
                        const x = patch.patchCenter.x + (Math.random() - 0.5) * 4 * patch.patchRadius;
                        const y = patch.patchCenter.y + (Math.random() - 0.5) * 4 * patch.patchRadius;
                        this.entities.push(new ResourceNode(x, y, GameData.RESOURCE_NODES[patch.type]));
                    }
                });
            }

            if (regionData.sceneryPatches) {
                regionData.sceneryPatches.forEach(patch => {
                    for (let i = 0; i < patch.density; i++) {
                        const x = patch.patchCenter.x + (Math.random() - 0.5) * 2 * patch.patchRadius;
                        const y = patch.patchCenter.y + (Math.random() - 0.5) * 2 * patch.patchRadius;
                        const randomSceneryId = patch.type[Math.floor(Math.random() * patch.type.length)];
                        const baseSceneryType = GameData.SCENERY[randomSceneryId];
                        
                        // --- FIX: Logic to randomize tree height ---
                        if (baseSceneryType) {
                            // Create a copy so we don't modify the original GameData object
                            const sceneryInstanceData = { ...baseSceneryType };

                            // Only randomize the size for non-bushes (bush is ID 3)
                            if (sceneryInstanceData.id !== 3) {
                                const sizeMultiplier = 0.8 + Math.random() * 0.4; // Random size from 80% to 120%
                                sceneryInstanceData.size = Math.round(sceneryInstanceData.size * sizeMultiplier);
                            }
                            
                            this.entities.push(new Scenery(x, y, sceneryInstanceData));
                        }
                    }
                });
            }
        });
    }

    initAtmosphere() {
        setInterval(() => {
            if (game && game.camera) {
                const x = game.camera.x + Math.random() * game.camera.width;
                const y = game.camera.y + Math.random() * game.camera.height;
                ParticleSystem.create(x, y, 'rgba(255, 255, 255, 0.03)', 1, 8, 0.1, { vx: (Math.random() - 0.5) * 0.2, vy: (Math.random() - 0.5) * 0.2 });
            }
        // --- FIX: Interval reduced from 100 to 33 to triple the fog particle rate ---
        }, 33);

        setInterval(() => {
            if (game && game.camera) {
                const x = game.camera.x + Math.random() * game.camera.width;
                const y = game.camera.y + Math.random() * game.camera.height;
                ParticleSystem.create(x, y, 'yellow', 10, 1.5, 3, { vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4 });
            }
        // --- FIX: Interval reduced from 4000-7000 to 1333-2333 to triple the insect swarm rate ---
        }, 1333 + Math.random() * 1000);
    }

    gameLoop(timestamp) { const deltaTime = timestamp - this.lastTime; this.lastTime = timestamp; this.update(deltaTime); this.draw(); requestAnimationFrame((ts) => this.gameLoop(ts)); }
    update(deltaTime) {
        if (!deltaTime) return;
        if (this.player.isRooted) this.input.joystickVector = {x: 0, y: 0};

        if (this.input.mouse.clicked && !this.player.isAutoQuesting && !this.player.isGhost) {
            let clickedOnSomething = false; 
            const clickWorldPos = { x: this.input.mouse.x + this.camera.x, y: this.input.mouse.y + this.camera.y };
            const sortedEntities = [...this.entities].sort((a, b) => b.y - a.y);

            for (const entity of sortedEntities) {
                if (entity !== this.player && distance(clickWorldPos, entity) < entity.size / 2) {
                    
                    if (entity instanceof Enemy) {
                        if (entity === this.player.target && !entity.isDead) {
                            this.player.performClickAttack();
                        } else {
                            this.player.setTarget(entity);
                        }
                        clickedOnSomething = true;
                        break;
                    } 
                    // --- UPGRADED LOGIC FOR INTERACTABLES ---
                    else if (entity.isInteractable) {
                        // If it's a resource node AND we're out of range...
                        if (entity instanceof ResourceNode && distance(this.player, entity) > 100) {
                            // ...set it as our auto-move-interact target.
                            this.player.autoMoveInteractTarget = entity;
                        } else if (distance(this.player, entity) < 100) {
                            // Otherwise, if we're in range, interact immediately.
                            this.player.autoMoveInteractTarget = null; // Cancel any auto-move
                            entity.interact(this.player); 
                        }
                        this.player.setTarget(entity);
                        clickedOnSomething = true;
                        break;
                    }
                }
            }

            if (!clickedOnSomething) this.player.setTarget(null);
            this.input.mouse.clicked = false;
        }
        
        const mouseWorldPos = { x: this.input.mouse.x + this.camera.x, y: this.input.mouse.y + this.camera.y };
        let nodeHovered = false;
        this.entities.forEach(entity => {
            if (entity instanceof ResourceNode) {
                if (!nodeHovered && distance(mouseWorldPos, entity) < entity.size / 2) {
                    entity.isHovered = true;
                    nodeHovered = true;
                } else {
                    entity.isHovered = false;
                }
            }
        });

        this.player.update(deltaTime, this.world, this.entities);
        this.entities.forEach(entity => entity.update(deltaTime, this.world, this.entities, this.player));

        const deadNPCs = this.entities.filter(e => e.isDead && e !== this.player && !(e instanceof PlayerCorpse));
        if(deadNPCs.length > 0) {
            deadNPCs.forEach(dead => { if (dead === this.player.target) this.player.setTarget(null); });
            this.entities = this.entities.filter(e => !deadNPCs.includes(e));
        }
        this.camera.update(); ParticleSystem.update(deltaTime); this.ui.update(this.player, deltaTime);
        this.world.updateAmbiance(deltaTime);
    }
    
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.world.draw(this.camera, this.player.isGhost);

        const objectsToDraw = [...this.entities, this.player];
        objectsToDraw.sort((a, b) => a.y - b.y);

        objectsToDraw.forEach(obj => {
            obj.draw(this.ctx, this.camera, this.player);
        });

        ParticleSystem.draw(this.camera);
    }

    createFloatingText(text, x, y, color, type = '') { this.ui.createFloatingText(text, x, y, color, this.camera, type); }
        setupUIInteractions() {
        if (this.isMobile) $("#mobile-controls").style.display = "block";
        
        $$('.sys-button').forEach(btn => btn.addEventListener('click', () => { 
            const windowId = btn.dataset.window; 
            if (windowId) { 
                const win = $(`#${windowId}`); 
                win.style.display = win.style.display === 'flex' ? 'none' : 'flex'; 
                this.ui.updateAll(this.player); 
            } 
        }));
        
        $('#save-button').addEventListener('click', () => { 
            this.saveGame(); 
            this.createFloatingText("Game Saved!", this.player.x, this.player.y, 'gold'); 
        });

        // --- MODIFY THIS BLOCK ---
        $$('.close-btn').forEach(btn => btn.addEventListener('click', (e) => { 
            const windowElement = e.target.closest('.window');
            windowElement.style.display = 'none'; 
            this.ui.tooltip.style.display = 'none';
            
            // --- FIX: Add this check to remove the listener when the crafting window is closed ---
            if (windowElement.id === 'crafting-window' && this.ui.boundCraftingHandler) {
                $('#craft-button').removeEventListener('click', this.ui.boundCraftingHandler);
                this.ui.boundCraftingHandler = null; // Clean up the reference
            }
        }));

        $$('.window').forEach(win => this.ui.makeDraggable(win));
        window.addEventListener('keydown', (e) => { if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; const keyMap = {c: '#character-window', i: '#inventory-window', l: '#quest-log-window', n: '#talent-window', p: '#spellbook-window', u: '#reputation-window', m: '#map-window'}; if(keyMap[e.key.toLowerCase()]){ const win = $(keyMap[e.key.toLowerCase()]); win.style.display = win.style.display === 'flex' ? 'none' : 'flex'; this.ui.updateAll(this.player); } });
        $('#release-spirit-button').addEventListener('click', () => this.player.releaseSpirit());
        
        window.addEventListener('mouseleave', () => { 
            this.ui.tooltip.style.display = 'none'; 
        });

        window.addEventListener('mousedown', () => {
            if (this.ui && this.ui.tooltip) {
                this.ui.tooltip.style.display = 'none';
            }
        });
    }

    saveGame(isAutoSave = false) {
        if (!this.player || this.player.isDead || this.player.isGhost) return;
        const saveData = {
            player: {
                x: this.player.x, y: this.player.y,
                name: this.player.name, race: this.player.race,
                level: this.player.level, xp: this.player.xp,
                restedXp: this.player.restedXp, gold: this.player.gold,
                baseStats: { ...this.player.baseStats },
                stats: { health: this.player.stats.health, mana: this.player.stats.mana },
                inventory: this.player.inventory.map(item => item ? { id: item.id, quantity: item.quantity, durability: item.durability } : null),
                equipment: Object.entries(this.player.equipment).reduce((acc, [slot, item]) => {
                    if (!item) {
                        acc[slot] = null;
                    } else {
                        acc[slot] = { id: item.id, durability: item.durability };
                        // --- FIX: Also save quantity if the item is stackable ---
                        if (item.stackable) {
                            acc[slot].quantity = item.quantity;
                        }
                    }
                    return acc;
                }, {}),
                hotbar: this.player.hotbar.map(slot => { if (!slot) return null; if (slot.type === 'ability') { return { type: 'ability', id: slot.ref.id }; } if (slot.type === 'item') { const invIndex = this.player.inventory.indexOf(slot.ref); return invIndex > -1 ? { type: 'item', invIndex: invIndex } : null; } return null; }),
                quests: this.player.quests.map(q => ({ id: q.id, progress: q.progress.map(p => p.current) })),
                recipes: this.player.recipes.map(r => r.id),
                spellbook: this.player.spellbook.map(a => a.id),
                talents: { ...this.player.talents },
                talentPoints: this.player.talentPoints,
                reputation: { ...this.player.reputation },
                professions: { ...this.player.professions },
                questCooldowns: Object.entries(this.player.questCooldowns).reduce((acc, [id, timeLeft]) => { acc[id] = Date.now() + timeLeft; return acc; }, {}),
                storage: this.player.storage.map(item => item ? { id: item.id, quantity: item.quantity, durability: item.durability } : null),
                hasHouse: this.player.hasHouse,
                pets: this.player.pets,
                activePetId: this.player.activePetId
            }
        };
        localStorage.setItem('miniWowSaveData', JSON.stringify(saveData));
        if (!isAutoSave) this.createFloatingText("Game Saved!", this.player.x, this.player.y, 'gold');
    }

    loadGame() {
        const savedJSON = localStorage.getItem('miniWowSaveData');
        if (!savedJSON) { console.log("No save data found."); return false; }
        try {
            const saveData = JSON.parse(savedJSON); const pData = saveData.player;
            this.spawnEntities();
            
            this.player.name = pData.name; this.player.race = pData.race; this.player.x = pData.x; this.player.y = pData.y; this.player.level = pData.level; this.player.xp = pData.xp; this.player.restedXp = pData.restedXp; this.player.gold = pData.gold; this.player.baseStats = { ...pData.baseStats }; this.player.talents = { ...pData.talents }; this.player.talentPoints = pData.talentPoints; this.player.reputation = { ...pData.reputation }; this.player.professions = { ...pData.professions }; this.player.pets = pData.pets || {}; this.player.activePetId = pData.activePetId || null; this.player.nextLevelXp = GameData.XP_TABLE[this.player.level] || 99999; 
            this.player.hasHouse = pData.hasHouse || false;
            this.player.storage = (pData.storage || new Array(99).fill(null)).map(itemData => {
                 if (!itemData) return null;
                 const baseItem = { ...GameData.ITEMS[itemData.id] };
                 baseItem.quantity = itemData.quantity;
                 if (itemData.durability !== undefined) baseItem.durability = itemData.durability;
                 return baseItem;
            });
            this.player.inventory = pData.inventory.map(itemData => { if (!itemData) return null; const baseItem = { ...GameData.ITEMS[itemData.id] }; baseItem.quantity = itemData.quantity; if (itemData.durability !== undefined) baseItem.durability = itemData.durability; return baseItem; });
            this.player.equipment = {};
            for (const slot in pData.equipment) {
                const itemData = pData.equipment[slot];
                if (itemData) {
                    const baseItem = { ...GameData.ITEMS[itemData.id] };
                    // --- FIX: Apply durability AND quantity from save data ---
                    if (itemData.durability !== undefined) baseItem.durability = itemData.durability;
                    if (itemData.quantity !== undefined) baseItem.quantity = itemData.quantity;
                    this.player.equipment[slot] = baseItem;
                } else {
                    this.player.equipment[slot] = null;
                }
            }
            this.player.quests = []; pData.quests.forEach(qData => { const questTemplate = GameData.QUESTS[qData.id]; const questGiver = this.entities.find(e => e instanceof QuestGiver && e.questIds.includes(qData.id)); if (questTemplate && questGiver) { this.player.quests.push({ ...questTemplate, progress: questTemplate.objectives.map((o, i) => ({ ...o, current: qData.progress[i] || 0 })), giver: questGiver }); } }); if (pData.spellbook) {
                this.player.spellbook = pData.spellbook.map(id => GameData.ABILITIES[id]);
            }
            
            this.player.recipes = pData.recipes.map(id => GameData.CRAFTING_RECIPES[id]);
            this.player.hotbar = pData.hotbar.map(slotData => { if (!slotData) return null; if (slotData.type === 'ability') { return { type: 'ability', ref: GameData.ABILITIES[slotData.id] }; } if (slotData.type === 'item' && slotData.invIndex !== undefined) { const item = this.player.inventory[slotData.invIndex]; return item ? { type: 'item', ref: item } : null; } return null; });
            this.player.questCooldowns = {}; for(const id in pData.questCooldowns) { const endTime = pData.questCooldowns[id]; const timeLeft = endTime - Date.now(); if (timeLeft > 0) this.player.questCooldowns[id] = timeLeft; }
            
            this.player.recalculateStats();
            if (this.player.activePetId) {
                const petIdToActivate = this.player.activePetId;
                this.player.activePetId = null;
                const newPet = this.player.setActivePet(petIdToActivate);
                if (newPet) {
                    this.entities.push(newPet); // Add the pet to the entity list safely
                }
            }
            this.player.stats.health = pData.stats.health;
            this.player.stats.mana = pData.stats.mana;
            this.ui.setupActionbar(this.player);
            console.log("Game loaded successfully!"); return true;
        } catch (e) { console.error("Failed to load save data. It might be corrupted.", e); localStorage.removeItem('miniWowSaveData'); return false; }
    }
}

class World {
    constructor(ctx, width, height) { this.ctx = ctx; this.width = width; this.height = height; this.bgColor = "#182c18"; this.regions = GameData.REGIONS; this.sparkles = []; this.generateAmbiance(); }
    generateAmbiance() { for (let i = 0; i < 500; i++) { this.sparkles.push({ x: Math.random() * this.width, y: Math.random() * this.height, size: Math.random() * 1.5 + 0.5, opacity: Math.random() * 0.5, opacityDir: 1 }); } }
    updateAmbiance(deltaTime) { this.sparkles.forEach(s => { s.opacity += 0.05 * s.opacityDir * (deltaTime / 16.67); if (s.opacity > 1 || s.opacity < 0) { s.opacityDir *= -1; s.opacity = Math.max(0, Math.min(1, s.opacity)); } }); }
    draw(camera, isGhost = false) {
        this.ctx.save();
        if (isGhost) { this.ctx.filter = 'grayscale(1) brightness(0.7) sepia(1) hue-rotate(180deg)'; }
        
        const currentRegion = this.regions.find(r => 
            camera.target.x >= r.x && camera.target.x < r.x + r.width &&
            camera.target.y >= r.y && camera.target.y < r.y + r.height
        );

        // --- NEW RENDERING LOGIC ---
        if (currentRegion && currentRegion.isDungeon) {
            // --- For Interiors (like the house or a cave) ---
            // 1. Fill the entire background with black
            this.ctx.fillStyle = '#000';
            this.ctx.fillRect(0, 0, camera.width, camera.height);

            // 2. Draw only the floor of the room, creating a border effect
            const drawX = currentRegion.x - camera.x;
            const drawY = currentRegion.y - camera.y;
            this.ctx.fillStyle = currentRegion.bgColor;
            this.ctx.fillRect(drawX, drawY, currentRegion.width, currentRegion.height);

        } else if (currentRegion) {
            // --- For the Overworld (original behavior) ---
            this.ctx.fillStyle = currentRegion.bgColor;
            this.ctx.fillRect(0, 0, camera.width, camera.height);
        } else {
            // Fallback for safety
            this.ctx.fillStyle = this.bgColor;
            this.ctx.fillRect(0, 0, camera.width, camera.height);
        }
        
        this.ctx.restore();
    }
}
class Camera {
    constructor(target, width, height) { this.target = target; this.width = width; this.height = height; this.x = 0; this.y = 0; }
    update() { if(!this.target || (this.target.isDead && !this.target.isGhost)) return; this.x = this.target.x - this.width / 2; this.y = this.target.y - this.height / 2; this.x = Math.max(0, Math.min(this.x, game.world.width - this.width)); this.y = Math.max(0, Math.min(this.y, game.world.height - this.height)); }
}
class Entity {
    constructor(x, y, size, color, icon) {
        this.x = x; this.y = y; this.size = size; this.color = color; this.icon = icon; this.isDead = false;
    }

    draw(ctx, camera, player) {
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;

        if (drawX + this.size < 0 || drawX - this.size > camera.width || drawY + this.size < 0 || drawY - this.size > camera.height) {
            return;
        }

        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(drawX, drawY + this.size / 2, this.size / 2, this.size / 4, 0, 0, 2 * Math.PI);
        ctx.fill();

        ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`;
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icon, drawX, drawY);
    }
    
    update(deltaTime, world, entities) {}
}
class Pet extends Entity {
    constructor(x, y, owner, petData) {
        super(x, y, petData.size, petData.color, petData.icon);
        this.owner = owner;
        this.petData = petData;
        this.leashDistance = 60; // How far the pet can be before it starts moving
    }

    update(deltaTime) {
        const distanceToOwner = distance(this, this.owner);

        // If owner is too far away, move towards them
        if (distanceToOwner > this.leashDistance) {
            const angle = Math.atan2(this.owner.y - this.y, this.owner.x - this.x);
            // Move at the owner's speed, slightly slower
            const moveSpeed = (this.owner.speed * 0.9) * (deltaTime / 16.67); 
            this.x += Math.cos(angle) * moveSpeed;
            this.y += Math.sin(angle) * moveSpeed;
        }
    }
    draw(ctx, camera) {
        // Set the font to Font Awesome before drawing
        ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`;
        
        // Call the original drawing logic from the parent Entity class
        super.draw(ctx, camera);
    }

}
class Character extends Entity {
    constructor(x, y, size, color, icon, name) {
        super(x, y, size, color, icon);
        this.name = name;
        this.level = 1;
        this.baseStats = { strength: 5, agility: 5, stamina: 5, intellect: 5, spirit: 5, attackPower: 0, critChance: 0, dodgeChance: 0, armor: 0 };
        this.stats = { ...this.baseStats };
        this.target = null;
        this.buffs = [];
        this.threatTable = new Map();
        this.isRooted = false;
    }
    recalculateStats() {
        this.buffs.forEach(buff => {
            if (buff.stats) {
                for (const stat in buff.stats) {
                    this.statBonuses[stat] = (this.statBonuses[stat] || 0) + buff.stats[stat];
                }
            }
        });
    }
    update(deltaTime) {
        this.buffs.forEach(buff => {
            buff.duration -= deltaTime;
            if (buff.onTick) { buff.tickTimer = (buff.tickTimer || 0) + deltaTime; if (buff.tickTimer >= buff.tickRate) { buff.onTick(this); buff.tickTimer = 0; } }
        });
        const expiredBuffs = this.buffs.filter(b => b.duration <= 0);
        if (expiredBuffs.length > 0) {
            expiredBuffs.forEach(buff => { if(buff.onExpire) buff.onExpire(this); });
            this.buffs = this.buffs.filter(b => b.duration > 0);
            this.recalculateStats();
        }
    }
    addBuff(buff) {
        const existing = this.buffs.find(b => b.id === buff.id);
        if (existing) { existing.duration = buff.duration; return; }
        if (buff.onApply) buff.onApply(this);
        this.buffs.push({ ...buff, tickTimer: 0 });
        if (buff.stats) this.recalculateStats();
    }
        takeDamage(amount, type, source, isDot = false) {
        if (this.isDead) return;
        if (type === 'physical' && !isDot && Math.random() < this.stats.dodgeChance) { game.createFloatingText('Dodge', this.x, this.y, '#fff', 'miss'); return; }
        
        let isCrit = false;
        // --- FIX: Add a check to ensure the source and its critChance exist ---
        if (!isDot && source && source.stats && source.stats.critChance && Math.random() < source.stats.critChance) {
            amount *= 2;
            isCrit = true;
        }

        let finalAmount = amount;
        if(type === 'physical') {
            const mitigation = 1 - (this.stats.armor / (this.stats.armor + 400 + 85 * this.level));
            finalAmount = Math.max(1, amount * mitigation);
        }
        
        // --- ADDED SAFETY: Check if finalAmount is a valid number before proceeding ---
        if (isNaN(finalAmount)) {
            console.error("Damage calculation resulted in NaN!", {amount, type, source});
            finalAmount = 1; // Default to 1 damage to prevent breaking the game
        }

        finalAmount = Math.round(finalAmount);
        this.stats.health = Math.max(0, this.stats.health - finalAmount);
        
        if (this instanceof Player) {
            game.ui.updatePlayerFrame(this);
            this.fiveSecondRuleTimer = 500;
        }
        if(source) {
            const currentThreat = this.threatTable.get(source) || 0;
            this.threatTable.set(source, currentThreat + finalAmount * (isCrit ? 1.5 : 1));
        }
        
        const color = type === 'physical' ? '#fff' : '#87ceeb';
        game.createFloatingText(finalAmount, this.x, this.y, color, isCrit ? 'crit' : '');
        
        if (this.stats.health <= 0) this.die(source);
    }
    heal(amount, source) {
        this.stats.health = Math.min(this.stats.maxHealth, this.stats.health + amount);
        if (this instanceof Player) { game.ui.updatePlayerFrame(this); }
        if(source && this.inCombatTimer > 0) { const healerThreat = this.threatTable.get(source) || 0; this.threatTable.set(source, healerThreat + amount * 0.5); }
        game.createFloatingText(amount, this.x, this.y, 'lightgreen');
    }
    die(killer) { if (this.isDead) return; this.isDead = true; ParticleSystem.create(this.x, this.y, '#777', 30, 0.5); }
    setTarget(entity) { if (this.target) this.target.isTargeted = false; this.target = entity; if (this.target) this.target.isTargeted = true; }
    getAttackDamage() { return this.stats.attackPower; }

    draw(ctx, camera, player) {
        super.draw(ctx, camera, player);
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;

        if (!this.isDead) {
            const barWidth = this.size * 1.5;
            const barHeight = 4;
            const barYpos = drawY + this.size / 2 + 5;

            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(drawX - barWidth / 2, barYpos, barWidth, barHeight);

            const healthPercent = this.stats.health / this.stats.maxHealth;
            const healthBarColor = (this === player) ? '#28a745' : '#dc3545';
            ctx.fillStyle = healthBarColor;
            
            if (healthPercent > 0) {
                ctx.fillRect(drawX - barWidth / 2, barYpos, barWidth * healthPercent, barHeight);
            }
        }
        
        if(this.isTargeted) {
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(drawX, drawY + this.size/2, this.size/1.5, this.size/3, 0, 0, 2*Math.PI);
            ctx.stroke();
        }
    }
}

class Player extends Character {
        constructor(x, y, input, name, race) {
        super(x, y, 30, '#ddd', '\uf007', name || 'Hero');
        this.race = race || 'Human';
        this.input = input;
        this.speed = 2.2;
        this.xp = 0;
        this.restedXp = 0;
        this.nextLevelXp = GameData.XP_TABLE[this.level];
        this.gold = 5000;
        this.inventory = new Array(16).fill(null);
        this.equipment = { head: null, chest: null, tabard: null, 'main-hand': null, 'off-hand': null, ammo: null };
        this.buffs = [];
        this.baseStats = { ...this.baseStats };
        this.statBonuses = {};
        this.talentBonuses = {};
        this.talents = {};
        this.talentPoints = 0;
        this.reputation = {};
        Object.keys(GameData.FACTIONS).forEach(id => this.reputation[id] = GameData.FACTIONS[id].base);
        
        this.professions = {};
        for (const profName in GameData.PROFESSIONS) {
            const profTemplate = GameData.PROFESSIONS[profName];
            this.professions[profName] = {
                level: 0,
                xp: 0,
                nextLevelXp: profTemplate.nextLevelXp 
            };
        }
        
        this.recipes = [];
        this.hotbar = new Array(10).fill(null);
        this.spellbook = [];

        // --- FIX: Correctly assign abilities based on Race/Class ---
        if (this.race === 'Human') { // Warrior
            this.addAbilityToSpellbook(1); // Slash
            this.addAbilityToSpellbook(3); // Rend
        } else if (this.race === 'Elf') { // Mage
            this.addAbilityToSpellbook(2); // Fireball
            this.addAbilityToSpellbook(5); // Blast
        }
        // --- END OF FIX ---

        this.returnLocation = null;
        this.storage = new Array(99).fill(null);
        this.hasHouse = false;
        this.maxStamina = 6500;
        this.stamina = this.maxStamina;
        this.isSprinting = false;
        this.staminaRegenDelayTimer = 0;
        this.pets = {};
        this.activePetId = null;
        this.activePetInstance = null;
        this.globalClickCooldown = 0;
        this.isGathering = false;
        this.cooldowns = {};
        this.quests = [];
        this.autoAttackTimer = 0;
        this.attackSpeed = 2000;
        this.inCombatTimer = 0;
        this.fiveSecondRuleTimer = 0;
        this.isGhost = false;
        this.corpse = null;
        this.isResting = false;
        this.isAutoQuesting = false;
        this.autoQuest = null;
        this.autoMoveTarget = null;
        this.questCooldowns = {};
        this.autoMoveInteractTarget = null;
        this.gatheringTimer = 0;
        this.gatheringTotalTime = 0;
        this.gatheringTargetNode = null;

        this.addItem(1, 1);
        this.addItem(5, 3);
        this.recalculateStats();
        this.stats.health = this.stats.maxHealth;
        this.stats.mana = this.stats.maxMana;
    }

    startGathering(node) {
        if (this.isGathering || this.inCombatTimer > 0) return;
        this.isGathering = true;
        this.gatheringTargetNode = node;
        this.gatheringTimer = 0;
        this.gatheringTotalTime = node.type.gatherTime || 2000;
        game.createFloatingText(`Gathering ${node.type.name}...`, this.x, this.y, 'white');
    }

    cancelGathering() {
        if (!this.isGathering) return;
        this.isGathering = false;
        this.gatheringTimer = 0;
        this.gatheringTotalTime = 0;
        this.gatheringTargetNode = null;
        game.createFloatingText("Gathering Interrupted", this.x, this.y, 'red');
    }

    completeGathering() {
        if (!this.gatheringTargetNode) {
            this.cancelGathering();
            return;
        }
        const node = this.gatheringTargetNode;

        node.depleted = true;
        node.icon = '\uf2d3'; // A depleted/empty icon
        node.color = '#555';
        
        // --- FIX: Use the new 'yield' property from GameData ---
        const gatherAmount = node.type.yield || 1; // Default to 1 if yield is not defined

        game.createFloatingText(`+${gatherAmount} ${node.type.name}`, this.x, this.y - 20, 'white');
        this.gainProfessionXp(node.type.requiredSkill, 5, -40);
        this.addXp(10, -60);
        
        // --- FIX: Pass the dynamic amount to addItem ---
        this.addItem(node.type.itemId, gatherAmount);
        
        if (node.type.itemId === 7) {
            this.addRecipe('copper_bar');
        }

        game.ui.updateAll(this);
        
        setTimeout(() => {
            node.depleted = false;
            node.icon = node.type.icon;
            node.color = node.type.color;
        }, node.type.respawnTime);

        this.isGathering = false;
        this.gatheringTimer = 0;
        this.gatheringTotalTime = 0;
        this.gatheringTargetNode = null;
    }

    autoSlotAbilities() {
        let nextSlot = 1; 
        this.spellbook.forEach(ability => {
            if (nextSlot < this.hotbar.length) {
                const alreadySlotted = this.hotbar.some(slot => slot && slot.type === 'ability' && slot.ref.id === ability.id);
                if (!alreadySlotted) {
                    this.hotbar[nextSlot] = { type: 'ability', ref: ability };
                    nextSlot++;
                }
            }
        });
    }

    performClickAttack() {
        if (this.globalClickCooldown > 0 || !this.target || this.target.isDead) return;

        const weapon = this.equipment['main-hand'];
        
        if (weapon && weapon.range) {
            // RANGED ATTACK LOGIC (This part is correct and remains the same)
            if (distance(this, this.target) <= weapon.range) {
                const ammo = this.equipment.ammo;
                if (!ammo || ammo.quantity <= 0) {
                    game.createFloatingText("Out of arrows!", this.x, this.y, "red");
                    return;
                }
                ammo.quantity--;
                if (ammo.quantity <= 0) {
                    this.equipment.ammo = null;
                }

                const onArrowHit = (caster, target) => {
                    const damageRange = caster.getWeaponDamage();
                    const finalDamage = Math.floor(Math.random() * (damageRange.max - damageRange.min + 1)) + damageRange.min;
                    target.takeDamage(finalDamage, 'physical', caster);
                    ParticleSystem.create(target.x, target.y, 'rgba(200, 200, 200, 0.5)', 5, 0.1, 8);
                };
                
                const arrowProjectile = new Projectile(this, this.target, 500, '\uf140', '#CD853F', 12, onArrowHit, true);
                game.entities.push(arrowProjectile);

                this.globalClickCooldown = weapon.attackSpeed || 1500; 
                this.inCombatTimer = 8000;
                game.ui.updateAll(this);
            } else { 
                game.createFloatingText("Out of range", this.x, this.y, "yellow");
            }
        } else {
            // MELEE ATTACK LOGIC (This part is now fixed)
            if (distance(this, this.target) <= 40) {
                const damageRange = this.getWeaponDamage();
                const finalDamage = Math.floor(Math.random() * (damageRange.max - damageRange.min + 1)) + damageRange.min;
                this.target.takeDamage(finalDamage, 'physical', this);

                ParticleSystem.create(this.target.x, this.target.y, 'white', 10, 0.1, 8);
                
                // --- FIX: Use the weapon's attackSpeed or a default, NOT this.attackSpeed ---
                this.globalClickCooldown = weapon?.attackSpeed || 2000; // Use weapon's speed, or default to 2s
                
                this.inCombatTimer = 8000;
            } else {
                game.createFloatingText("Out of range", this.x, this.y, "yellow");
            }
        }
    }

    update(deltaTime) {
        super.update(deltaTime); 
        if (this.isDead && !this.isGhost) return;

        if (this.isGathering) {
            this.gatheringTimer += deltaTime;
            if (this.gatheringTimer >= this.gatheringTotalTime) {
                this.completeGathering();
            }
            return; 
        }

        for (const id in this.cooldowns) { this.cooldowns[id] -= deltaTime; if (this.cooldowns[id] <= 0) delete this.cooldowns[id]; }
        for (const id in this.questCooldowns) { this.questCooldowns[id] -= deltaTime; if (this.questCooldowns[id] <= 0) delete this.questCooldowns[id]; }
        if (this.inCombatTimer > 0) { this.inCombatTimer -= deltaTime; if(this.inCombatTimer <= 0) this.inCombatTimer = 0; }
        if (this.globalClickCooldown > 0) this.globalClickCooldown -= deltaTime;
        this.fiveSecondRuleTimer -= deltaTime;
        this.autoAttackTimer += deltaTime;

        this.updateAutoQuest(); 

        const currentRegion = game.world.regions.find(r =>
            this.x >= r.x && this.x < r.x + r.width &&
            this.y >= r.y && this.y < r.y + r.height
        );
        this.isResting = currentRegion ? currentRegion.isRestZone : false;

        let moveVector = { x: 0, y: 0 };
        if (this.autoMoveInteractTarget) {
            if (distance(this, this.autoMoveInteractTarget) > 90) {
                const angle = Math.atan2(this.autoMoveInteractTarget.y - this.y, this.autoMoveInteractTarget.x - this.x);
                moveVector.x = Math.cos(angle);
                moveVector.y = Math.sin(angle);
            } else {
                this.autoMoveInteractTarget.interact(this);
                this.autoMoveInteractTarget = null;
            }
        } 
        else if (!this.isRooted) {
            if (this.isAutoQuesting && this.autoMoveTarget) {
                const angle = Math.atan2(this.autoMoveTarget.y - this.y, this.autoMoveTarget.x - this.x);
                if (distance(this, this.autoMoveTarget) > 5) {
                    moveVector.x = Math.cos(angle);
                    moveVector.y = Math.sin(angle);
                } else {
                    this.autoMoveTarget = null; 
                }
            } else if (!this.isAutoQuesting) {
                moveVector = this.input.getMoveVector();
            }
        }
        
        const isMoving = moveVector.x !== 0 || moveVector.y !== 0;

        if (isMoving && (this.input.getMoveVector().x !== 0 || this.input.getMoveVector().y !== 0)) {
            this.autoMoveInteractTarget = null;
        }

        const canSprint = this.input.keys['shift'] && isMoving;

        if (canSprint && this.stamina > 0) {
            this.isSprinting = true;
            this.stamina -= deltaTime; // Drain stamina
            this.staminaRegenDelayTimer = 500; // Reset regen delay
        } else {
            this.isSprinting = false;
        }

        if (this.stamina <= 0) {
            this.isSprinting = false; // Force stop if out of stamina
        }
        
        // Stamina Regeneration Logic
        if (!this.isSprinting && this.stamina < this.maxStamina) {
            if (this.staminaRegenDelayTimer > 0) {
                this.staminaRegenDelayTimer -= deltaTime;
            } else {
                // Refill stamina over 5 seconds (3x faster than depletion)
                this.stamina += (this.maxStamina / 5000) * deltaTime;
            }
        }
        this.stamina = Math.max(0, Math.min(this.stamina, this.maxStamina)); // Clamp value

        if (isMoving && currentRegion) {
            if (this.isGathering) this.cancelGathering();
            
            const sprintMultiplier = this.isSprinting ? 1.75 : 1;
            const currentSpeed = this.speed * sprintMultiplier * (this.isGhost ? 1.5 : 1) * (deltaTime / 16.67);
            
            let finalX = moveVector.x;
            let finalY = moveVector.y;
            if (finalX !== 0 && finalY !== 0) { 
                finalX *= 0.7071;
                finalY *= 0.7071;
            }
            
            const potentialNewX = this.x + finalX * currentSpeed;
            const potentialNewY = this.y + finalY * currentSpeed;

            const collidables = game.entities.filter(e => e.isCollidable);
            const playerRadius = this.size / 4;

            const isCollidingAt = (px, py) => {
                for (const entity of collidables) {
                    const halfSize = entity.size / 2;
                    if (px + playerRadius > entity.x - halfSize && px - playerRadius < entity.x + halfSize && py + playerRadius > entity.y - halfSize && py - playerRadius < entity.y + halfSize) {
                        return true;
                    }
                }
                return false;
            };

            if (potentialNewX > currentRegion.x && potentialNewX < currentRegion.x + currentRegion.width && !isCollidingAt(potentialNewX, this.y)) {
                this.x = potentialNewX;
            }
            if (potentialNewY > currentRegion.y && potentialNewY < currentRegion.y + currentRegion.height && !isCollidingAt(this.x, potentialNewY)) {
                this.y = potentialNewY;
            }
        }


        if (this.isGhost) {
            if (this.corpse && distance(this, this.corpse) < this.size) this.resurrectAtCorpse();
        } else {
            if (!this.isAutoQuesting) {
                for(let i = 0; i < 10; i++) {
                    if (this.input.keys[`${(i + 1) % 10}`]) {
                        this.useHotbarSlot(i);
                        this.input.keys[`${(i + 1) % 10}`] = false;
                    }
                }
            }
            if (this.target && this.target instanceof Enemy && !this.target.isDead) {
                const weapon = this.equipment['main-hand'];
                const attackRange = weapon?.range || 40; // Use weapon range, or default to 40 for melee

                if (distance(this, this.target) <= attackRange) {
                    if (this.autoAttackTimer >= this.attackSpeed) {
                        this.autoAttack();
                        this.autoAttackTimer = 0;
                    }
                }
            }
        }

        const inCombat = this.inCombatTimer > 0;
        
        if (this.race === 'Elf') {
            if (!inCombat && this.stats.health < this.stats.maxHealth) {
                this.stats.health = Math.min(this.stats.maxHealth, this.stats.health + this.stats.spirit * 0.5 * (deltaTime / 1000));
            }
            if ((!inCombat || this.fiveSecondRuleTimer <= 0) && this.stats.mana < this.stats.maxMana) {
                this.stats.mana = Math.min(this.stats.maxMana, this.stats.mana + this.stats.spirit * 0.8 * (deltaTime / 1000));
            }
        }
        
        if (this.isResting && !inCombat && !isMoving) {
            this.restedXp += 0.5 * (deltaTime / 1000);
            this.restedXp = Math.min(this.restedXp, this.nextLevelXp * 1.5);
        }
    }
    
    toggleAutoQuest(quest) { if (!quest) return; if (this.isAutoQuesting && this.autoQuest && this.autoQuest.id === quest.id) { this.isAutoQuesting = false; this.autoQuest = null; this.autoMoveTarget = null; this.setTarget(null); } else { if(this.isAutoQuesting) this.toggleAutoQuest(this.autoQuest); this.isAutoQuesting = true; this.autoQuest = quest; this.autoMoveTarget = null; } game.ui.updateQuestLog(this); }
    getBestAbilityRange() { let maxRange = 40; this.hotbar.forEach(slot => { if (slot && slot.type === 'ability' && slot.ref.range > maxRange) { maxRange = slot.ref.range; } }); return maxRange * 0.9; }
    
    updateAutoQuest() {
        if (!this.isAutoQuesting || !this.autoQuest || this.isGhost) return;
        
        const isQuestComplete = this.autoQuest.progress.every(p => p.current >= p.count);
        
        if (isQuestComplete) {
            const giver = this.autoQuest.giver;
            if (giver) {
                this.autoMoveTarget = giver;
                if (distance(this, giver) < 100) {
                    this.autoMoveTarget = null;
                    giver.interact(this, true);
                }
            }
        } else {
            const objective = this.autoQuest.progress.find(p => p.current < p.count);
            if (!objective) {
                this.toggleAutoQuest(this.autoQuest);
                return;
            }

            if (objective.type === 'kill') {
                const targetMobType = objective.target;
                const currentTargetIsValid = this.target && this.target instanceof Enemy && !this.target.isDead && this.target.type.name.split(' ')[1].toUpperCase() === targetMobType;
                
                if (this.target && this.target.isDead) this.setTarget(null);

                if (this.target && currentTargetIsValid) {
                    const bestRange = this.getBestAbilityRange();
                    this.autoMoveTarget = this.target;
                    
                    if (distance(this, this.target) <= bestRange) {
                        this.autoMoveTarget = null;
                        for (let i = 0; i < this.hotbar.length; i++) {
                            const slotItem = this.hotbar[i];
                            if (slotItem && slotItem.type === 'ability') {
                                const ability = slotItem.ref;
                                
                                // --- FIX: The redundant distance check is removed here ---
                                if (!this.cooldowns[ability.id] && this.stats.mana >= ability.cost) {
                                    this.useHotbarSlot(i);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    this.autoMoveTarget = null;
                    let closestMob = null;
                    let minDistance = Infinity;
                    for (const entity of game.entities) {
                        if (entity instanceof Enemy && !entity.isDead && entity.type.name.split(' ')[1].toUpperCase() === targetMobType) {
                            const d = distance(this, entity);
                            if (d < minDistance) {
                                minDistance = d;
                                closestMob = entity;
                            }
                        }
                    }
                    if (closestMob) {
                        this.setTarget(closestMob);
                        this.autoMoveTarget = closestMob;
                    } else {
                        if (!this.autoMoveTarget) {
                            this.autoMoveTarget = { x: this.x + (Math.random() * 800 - 400), y: this.y + (Math.random() * 800 - 400) };
                        }
                    }
                }
            } else if (objective.type === 'gather') {
                const targetResourceNode = objective.target;
                const currentTargetIsValid = this.target && this.target instanceof ResourceNode && !this.target.depleted && this.target.type.name.toUpperCase() === targetResourceNode;
                
                if (this.target && this.target.depleted) this.setTarget(null);
                
                if (this.target && currentTargetIsValid) {
                    this.autoMoveTarget = this.target;
                    if (distance(this, this.target) < 100) {
                        this.autoMoveTarget = null;
                        this.target.interact(this);
                        this.setTarget(null);
                    }
                } else {
                    this.autoMoveTarget = null;
                    let closestNode = null;
                    let minDistance = Infinity;
                    for (const entity of game.entities) {
                        if (entity instanceof ResourceNode && !entity.depleted && entity.type.name.toUpperCase() === targetResourceNode) {
                            const d = distance(this, entity);
                            if (d < minDistance) {
                                minDistance = d;
                                closestNode = entity;
                            }
                        }
                    }
                    if (closestNode) {
                        this.setTarget(closestNode);
                        this.autoMoveTarget = closestNode;
                    } else {
                        if (!this.autoMoveTarget) {
                            this.autoMoveTarget = { x: this.x + (Math.random() * 800 - 400), y: this.y + (Math.random() * 800 - 400) };
                        }
                    }
                }
            }
        }
    }

    takeDamage(amount, type, source) { 
        if (this.isGathering) this.cancelGathering();
        super.takeDamage(amount, type, source); 
        if (!this.isDead) { 
            this.inCombatTimer = 8000; 
            this.fiveSecondRuleTimer = 500; 
        } 
    }

    die(killer) { if (this.isDead) return; super.die(killer); if (this.isAutoQuesting) { this.toggleAutoQuest(this.autoQuest); } game.ui.showDeathScreen(); Object.values(this.equipment).forEach(item => { if (item) item.durability = Math.max(0, item.durability - 10); }); this.corpse = new PlayerCorpse(this.x, this.y); game.entities.push(this.corpse); }
    releaseSpirit() { if (!this.isDead || this.isGhost) return; this.isGhost = true; this.x = GRAVEYARD_POINT.x; this.y = GRAVEYARD_POINT.y; this.setTarget(null); game.ui.hideDeathScreen(); }
    
    resurrectAtCorpse() {
        this.isDead = false;
        this.isGhost = false;
        this.recalculateStats(); 
        this.stats.health = this.stats.maxHealth * 0.5;
        this.stats.mana = this.stats.maxMana * 0.5;
        this.x = this.corpse.x;
        this.y = this.corpse.y;
        this.corpse.isDead = true;
        game.entities = game.entities.filter(e => e !== this.corpse);
        this.corpse = null;
        game.ui.updateAll(this);
    }

    resurrectAtHealer() { this.isDead = false; this.isGhost = false; this.x = this.x; this.y = this.y; this.addBuff({ id: 'res_sickness', name: 'Resurrection Sickness', icon: 'fa-skull', duration: 60000, isDebuff: true, stats: { strength: -10, agility: -10, stamina: -10, intellect: -10, spirit: -10 } }); Object.values(this.equipment).forEach(item => { if (item) item.durability = Math.max(0, item.durability - 15); }); this.recalculateStats(); this.stats.health = this.stats.maxHealth * 0.25; this.stats.mana = this.stats.maxMana * 0.25; game.ui.updateAll(this); }
    
    getWeaponDamage() {
        const weapon = this.equipment['main-hand'];
        if (!weapon || !weapon.weaponDamage) {
            return { min: 1, max: 2 }; // Unarmed damage
        }

        let minDamage = weapon.weaponDamage.min;
        let maxDamage = weapon.weaponDamage.max;

        // --- NEW: Smart scaling logic ---
        if (weapon.range) {
            // RANGED WEAPON: Scale with Agility
            // Let's make every 2 points of Agility add 1 damage.
            const agilityBonus = this.stats.agility / 2;
            minDamage += agilityBonus;
            maxDamage += agilityBonus;
        } else {
            // MELEE WEAPON: Scale with Attack Power (from Strength)
            // The existing formula: AP / 14 * weapon_speed
            const weaponSpeed = weapon.attackSpeed ? (weapon.attackSpeed / 1000) : 2.0; // Default speed of 2.0 if not defined
            const apBonus = (this.stats.attackPower / 14) * weaponSpeed;
            minDamage += apBonus;
            maxDamage += apBonus;
        }

        return { min: minDamage, max: maxDamage };
    }

    autoAttack() {
        if (!this.target || this.target.isDead) return;

        const weapon = this.equipment['main-hand'];
        this.inCombatTimer = 8000;

        // --- NEW: Smart attack logic ---
        if (weapon && weapon.range) {
            // RANGED AUTO-ATTACK
            const ammo = this.equipment.ammo;
            if (!ammo || ammo.quantity <= 0) {
                game.createFloatingText("Out of arrows!", this.x, this.y, "red");
                return;
            }
            ammo.quantity--;
            if (ammo.quantity <= 0) {
                this.equipment.ammo = null;
            }

            const onArrowHit = (caster, target) => {
                // --- FIX: Calculate the final damage number here ---
                const damageRange = caster.getWeaponDamage();
                const finalDamage = Math.floor(Math.random() * (damageRange.max - damageRange.min + 1)) + damageRange.min;
                
                target.takeDamage(finalDamage, 'physical', caster);
                ParticleSystem.create(target.x, target.y, 'rgba(200, 200, 200, 0.5)', 5, 0.1, 8);
            };
            
            const arrowProjectile = new Projectile(this, this.target, 500, '\uf140', '#CD853F', 12, onArrowHit, true);
            game.entities.push(arrowProjectile);
            game.ui.updateAll(this);

        } else {
            // MELEE AUTO-ATTACK
            // --- FIX: Also apply the damage roll to melee attacks ---
            const damageRange = this.getWeaponDamage();
            const finalDamage = Math.floor(Math.random() * (damageRange.max - damageRange.min + 1)) + damageRange.min;
            this.target.takeDamage(finalDamage, 'physical', this);
            
            ParticleSystem.create(this.target.x, this.target.y, 'white', 10, 0.1, 8);
        }
    }

    useHotbarSlot(index) {
        const slotItem = this.hotbar[index];
        if (!slotItem || this.isGhost || this.isRooted) return;

        if (slotItem.type === 'ability') {
            const ability = slotItem.ref;
            
            // Basic checks that apply to all abilities
            if (this.cooldowns[ability.id]) return;
            if (this.stats.mana < ability.cost) {
                if (!this.isAutoQuesting) game.createFloatingText("Not enough mana", this.x, this.y, "blue");
                return;
            }
            
            // --- NEW: Logic to handle targeted vs. non-targeted spells ---
            if (ability.range > 0) { // This is a targeted ability
                if (!this.target || this.target.isDead) return; // Needs a valid target
                if (distance(this, this.target) > ability.range) {
                    if (!this.isAutoQuesting) game.createFloatingText("Out of range", this.x, this.y, "yellow");
                    return;
                }
                // If all checks pass, use the ability on the target
                ability.onUse(this, this.target);

            } else { // This is a self-cast or AoE ability (range is 0 or undefined)
                ability.onUse(this); // Use the ability, passing only the caster
            }
            // --- END OF NEW LOGIC ---

            this.stats.mana -= ability.cost;
            this.cooldowns[ability.id] = ability.cooldown;
            this.inCombatTimer = 8000;
            if (ability.cost > 0) this.fiveSecondRuleTimer = 500;
            game.ui.updatePlayerFrame(this);

        } else if (slotItem.type === 'item') { 
            const item = slotItem.ref; if (item.slot === 'consumable' && item.onUse) { item.onUse(this); item.quantity--; if(item.quantity <= 0) { const invIndex = this.inventory.findIndex(i => i === item); if (invIndex > -1) this.inventory[invIndex] = null; this.hotbar[index] = null; } game.ui.updateInventory(this); game.ui.setupActionbar(this); } } }
    
    setHotbarSlot(hotbarIndex, source, sourceIdentifier) { let sourceItem = null; let type = ''; if (source === 'inventory') { const idx = parseInt(sourceIdentifier); if (!isNaN(idx) && this.inventory[idx]) { sourceItem = this.inventory[idx]; type = 'item'; } } else if (source === 'spellbook') { const idx = parseInt(sourceIdentifier); if (!isNaN(idx) && this.spellbook[idx]) { sourceItem = this.spellbook[idx]; type = 'ability'; } } if (sourceItem) { this.hotbar[hotbarIndex] = { type, ref: sourceItem }; } else { this.hotbar[hotbarIndex] = null; } game.ui.setupActionbar(this); }
    
    addXp(amount, yOffset = -20) { 
        let bonusXp = 0; 
        if (this.restedXp > 0) { 
            bonusXp = Math.min(this.restedXp, amount); 
            this.restedXp -= bonusXp; 
        } 
        const totalXp = amount + bonusXp; 
        this.xp += totalXp;

        // FIX 1: Round the numbers to prevent decimals.
        // FIX 2: Use the yOffset parameter to control vertical position.
        const mainXpText = `${Math.round(amount)} XP`;
        const bonusXpText = bonusXp > 0 ? ` (+${Math.round(bonusXp)})` : '';
        
        game.createFloatingText(mainXpText + bonusXpText, this.x, this.y + yOffset, bonusXp > 0 ? '#00bfff' : '#b636d1'); 

        while(this.xp >= this.nextLevelXp && this.level < GameData.XP_TABLE.length -1) this.levelUp(); 
        game.ui.updateXPBar(this); 
    }
    
    levelUp() {
        this.xp -= this.nextLevelXp;
        this.level++;
        this.talentPoints++;
        this.nextLevelXp = GameData.XP_TABLE[this.level] || 99999;
        
        this.baseStats.strength += 2;
        this.baseStats.agility += 1;
        this.baseStats.stamina += 2;
        this.baseStats.intellect += 1;
        this.baseStats.spirit += 1;

        this.recalculateStats();

        this.stats.health = this.stats.maxHealth;
        this.stats.mana = this.stats.maxMana;
        
        game.createFloatingText('LEVEL UP!', this.x, this.y, 'gold', 'crit');
        ParticleSystem.create(this.x, this.y, 'gold', 50, 1.5, 30);
        
        game.ui.updateAll(this);
    }

    addPet(petId) {
        if (this.pets[petId]) {
            game.createFloatingText("You already know how to summon this companion.", this.x, this.y, 'yellow');
            return;
        }
        const petData = GameData.PETS[petId];
        // --- NEW: Store the initial maxLevel ---
        this.pets[petId] = { level: 1, xp: 0, maxLevel: petData.maxLevel };
        game.createFloatingText(`You have a new companion: ${petData.name}!`, this.x, this.y, 'gold');
        game.ui.updateAll(this);
    }

    setActivePet(petId) {
        // Dismiss current pet if there is one
        if (this.activePetInstance) {
            this.activePetInstance.isDead = true;
            this.activePetInstance = null;
        }

        // If we are trying to set the same pet, it means we are dismissing it
        if (this.activePetId === petId) {
            this.activePetId = null;
        } else if (petId && this.pets[petId]) {
            // Summon the new pet
            this.activePetId = petId;
            const petData = GameData.PETS[petId];
            this.activePetInstance = new Pet(this.x - 30, this.y - 30, this, petData);
        }
        
        this.recalculateStats();
        
        // --- FIX: This line is removed to prevent the timing error during game load ---
        // game.ui.updateCharacterSheet(this); 

        // Return the newly created pet instance so the calling function can handle it
        return this.activePetInstance;
    }

    feedPet(itemId) {
        if (!this.activePetId) return;

        const petData = GameData.PETS[this.activePetId];
        const xpGain = petData.favoriteFoods[itemId];
        const petStore = this.pets[this.activePetId];
        const itemData = GameData.ITEMS[itemId];

        if (itemData.petId) {
            if (itemData.petId === this.activePetId) {
                // We are feeding the correct egg to the correct pet
                if (petStore.level >= petStore.maxLevel) {
                    // Breakthrough condition met!
                    this.removeItem(itemId, 1);
                    petStore.maxLevel = 20; // The new cap
                    game.createFloatingText("BREAKTHROUGH!", this.x, this.y, 'lime');
                    game.createFloatingText(`${petData.name}'s level cap increased to 20!`, this.x, this.y - 20, 'gold');
                    game.ui.updateAll(this);
                } else {
                    game.createFloatingText("Your pet must be max level to consume this.", this.x, this.y, 'red');
                }
            } else {
                game.createFloatingText("This pet doesn't want to eat that egg.", this.x, this.y, 'red');
            }
            return; // Stop the function here for egg feeding
        }

        if (xpGain) {
            const petStore = this.pets[this.activePetId];
            if (petStore.level >= petData.statsByLevel.length) {
                game.createFloatingText("Your pet is full and cannot level up further.", this.x, this.y, 'yellow');
                return;
            }

            this.removeItem(itemId, 1);
            petStore.xp += xpGain;
            game.createFloatingText(`+${xpGain} Pet XP`, this.x, this.y, 'magenta');
            
            this.levelUpPetIfReady();
            game.ui.updateAll(this);
        } else {
            game.createFloatingText("Your pet doesn't want to eat that.", this.x, this.y, 'red');
        }
    }

    levelUpPetIfReady() {
        if (!this.activePetId) return;
        const petStore = this.pets[this.activePetId];
        const petData = GameData.PETS[this.activePetId];

        // --- FIX: Check against the dynamic maxLevel, not the array length ---
        if (petStore.level >= petStore.maxLevel) return;

        const nextLevelXp = petData.xpPerLevel[petStore.level - 1];

        if (nextLevelXp && petStore.xp >= nextLevelXp) {
            petStore.level++;
            petStore.xp -= nextLevelXp;
            game.createFloatingText(`${petData.name} grew to Level ${petStore.level}!`, this.x, this.y - 20, 'gold');
            this.recalculateStats();
        }
    }

        recalculateStats() {
        // --- This is the VERY TOP of your recalculateStats method ---
        const newStats = { ...this.baseStats };
        this.statBonuses = {};

        // --- FIX: The pet stat logic is now here and adds to statBonuses ---
        if (this.activePetId && this.pets[this.activePetId]) {
            const petStore = this.pets[this.activePetId];
            const petData = GameData.PETS[this.activePetId];
            const petLevelStats = petData.statsByLevel[petStore.level - 1].stats;
            for (const stat in petLevelStats) {
                // This correctly adds the pet's stats to the main bonus pool
                this.statBonuses[stat] = (this.statBonuses[stat] || 0) + petLevelStats[stat];
            }
        }
        
        // This is the original equipment loop, which is correct
        Object.values(this.equipment).forEach(item => {
            if (item && item.stats) {
                for (const stat in item.stats) {
                    this.statBonuses[stat] = (this.statBonuses[stat] || 0) + item.stats[stat];
                }
            }
        });
        
        // This is the original buff loop, which is also correct
        this.buffs.forEach(buff => {
            if (buff.stats) {
                for (const stat in buff.stats) {
                    this.statBonuses[stat] = (this.statBonuses[stat] || 0) + buff.stats[stat];
                }
            }
        });

        // The rest of the calculation will now correctly include the pet's stats
        for (const stat in this.statBonuses) {
            newStats[stat] = (newStats[stat] || 0) + this.statBonuses[stat];
        }
        
        let weaponDmgBonus = 0;
        const weapon = this.equipment['main-hand'];
        if (weapon && weapon.weaponDamage) {
            weaponDmgBonus = (weapon.weaponDamage.min + weapon.weaponDamage.max) / 2;
        }

        newStats.maxHealth = (newStats.stamina || 0) * 10;
        newStats.maxMana = (newStats.intellect || 0) * 10;
        newStats.attackPower = 5 + ((newStats.strength || 0) * 0.5) + weaponDmgBonus + (this.statBonuses.attackPower || 0);
        newStats.critChance = 0.05 + ((newStats.agility || 0) * 0.0025) + (this.statBonuses.critChance || 0);
        newStats.dodgeChance = 0.05 + ((newStats.agility || 0) * 0.0030) + (this.statBonuses.dodgeChance || 0);
        newStats.armor = (newStats.armor || 0) + (this.statBonuses.armor || 0);
        
        // 4. Preserve current health/mana percentages

        const oldHealth = this.stats ? this.stats.health : newStats.maxHealth;
        const oldMana = this.stats ? this.stats.mana : newStats.maxMana;
        
        this.stats = newStats;
        
        this.stats.health = Math.min(oldHealth, this.stats.maxHealth);
        this.stats.mana = Math.min(oldMana, this.stats.maxMana);
    }

    learnTalent(talentId) { 
        if(this.talentPoints <= 0) return; 
        const talentTreeKey = this.race === 'Elf' ? 'ELF_MAGE' : 'HUMAN_WARRIOR';
        const talentTree = GameData.TALENTS[talentTreeKey] || [];
        const talentData = talentTree.find(t => t.id === talentId); 
        if(!talentData) return; 
        const currentRank = this.talents[talentId] || 0; 
        if(currentRank >= talentData.maxRank) return; 
        this.talents[talentId] = currentRank + 1; 
        this.talentPoints--; 
        this.recalculateStats(); 
        game.ui.updateAll(this); 
    }

    addAbilityToSpellbook(abilityId) { const abilityData = GameData.ABILITIES[abilityId]; if (abilityData && !this.spellbook.find(a => a.id === abilityId)) this.spellbook.push(abilityData); }
    addRecipe(recipeId) { const recipeData = GameData.CRAFTING_RECIPES[recipeId]; if (recipeData && !this.recipes.find(r => r.id === recipeId)) { this.recipes.push(recipeData); game.createFloatingText(`New Recipe: ${recipeData.name}!`, this.x, this.y - 80, 'cyan'); } }
    
        addItem(itemId, quantity = 1) {
        const itemData = { ...GameData.ITEMS[itemId] };
        if (!itemData) return;

        let itemAdded = false;

        // --- NEW: Priority check for the ammo slot ---
        if (itemData.stackable && this.equipment.ammo && this.equipment.ammo.id === itemId) {
            this.equipment.ammo.quantity += quantity;
            itemAdded = true;
            // We still might want to call an update here to refresh the UI
        }

        // --- Original logic for inventory stacking (runs if not added to ammo slot) ---
        if (!itemAdded && itemData.stackable) {
            const existingStack = this.inventory.find(item => item && item.id === itemId);
            if (existingStack) {
                existingStack.quantity += quantity;
                itemAdded = true;
            }
        }
        
        // --- Original logic for adding to an empty slot ---
        if (!itemAdded) {
            const emptySlotIndex = this.inventory.findIndex(slot => slot === null);
            if (emptySlotIndex !== -1) {
                this.inventory[emptySlotIndex] = { ...itemData, quantity };
                itemAdded = true;
            }
        }

        if (!itemAdded) {
            if (game) game.createFloatingText("Inventory Full", this.x, this.y, 'red');
            return; // Exit early if the item couldn't be added
        }

        // --- Special logic for auto-slotting potions ---
        if (itemId === 5) { 
            if (!this.hotbar[0]) {
                const potionStack = this.inventory.find(i => i && i.id === 5);
                if (potionStack) {
                    this.hotbar[0] = { type: 'item', ref: potionStack };
                    // No need for a specific update here, as the final updateAll will catch it
                }
            }
        }
        
        // --- IMPORTANT: Ensure the UI is always updated after any item change ---
        if (game && game.ui) {
            game.ui.updateAll(this);
        }
    }

    removeItem(itemId, quantity = 1) { const itemIndex = this.inventory.findIndex(item => item && item.id === itemId && item.quantity >= quantity); if (itemIndex > -1) { const itemStack = this.inventory[itemIndex]; itemStack.quantity -= quantity; if (itemStack.quantity <= 0) { this.inventory[itemIndex] = null; this.hotbar.forEach((slot, idx) => { if (slot && slot.type === 'item' && slot.ref === itemStack) { this.hotbar[idx] = null; } }); } return true; } return false; }
    
    hasItem(itemId) {
        return this.inventory.some(item => item && item.id === itemId);
    }
    
    equipItem(inventoryIndex) {
        const item = this.inventory[inventoryIndex];
        if (item.slot === 'material' && this.equipment.ammo === null) {
            // Check if the item is an arrow type (we can be more specific later if needed)
            if (item.name.toLowerCase().includes('arrow')) {
                this.equipment.ammo = item;
                this.inventory[inventoryIndex] = null;
                this.recalculateStats();
                game.ui.updateAll(this);
                return;
            }
        }
        if (!item || !item.slot || !this.equipment.hasOwnProperty(item.slot)) return;
        const currentlyEquipped = this.equipment[item.slot];
        this.equipment[item.slot] = item;
        this.inventory[inventoryIndex] = currentlyEquipped;
        
        this.recalculateStats();

        game.ui.updateCharacterSheet(this);
        game.ui.updateInventory(this);
    }
    
    unequipItem(slot) {
        const itemToUnequip = this.equipment[slot];
        if (!itemToUnequip) return;
        const emptyInvSlot = this.inventory.findIndex(i => i === null);
        if (emptyInvSlot === -1) {
            game.createFloatingText("Inventory is full!", this.x, this.y, 'red');
            return;
        }
        this.inventory[emptyInvSlot] = itemToUnequip;
        this.equipment[slot] = null;

        this.recalculateStats();

        game.ui.updateCharacterSheet(this);
        game.ui.updateInventory(this);
    }
    
    addReputation(factionId, value) { if (!this.reputation[factionId]) this.reputation[factionId] = GameData.FACTIONS[factionId].base; this.reputation[factionId] += value; const factionData = GameData.FACTIONS[factionId]; if (factionData && factionData.values) { this.reputation[factionId] = Math.max(factionData.values[0], Math.min(this.reputation[factionId], factionData.values[factionData.values.length - 1])); } game.createFloatingText(`${value > 0 ? '+' : ''}${value} ${GameData.FACTIONS[factionId].name} Rep`, this.x, this.y-60, value > 0 ? 'lightgreen' : 'red'); }
    getRepairCost() { let totalCost = 0; Object.values(this.equipment).forEach(item => { if (item) { const damage = item.maxDurability - item.durability; totalCost += damage * 5; } }); return totalCost; }
    repairAllItems() { Object.values(this.equipment).forEach(item => { if (item) item.durability = item.maxDurability; }); }
    
    addQuest(questId, giver) { if (this.questCooldowns[questId]) { game.createFloatingText("Quest on cooldown!", this.x, this.y, 'red'); return; } if(this.quests.find(q => q.id === questId)) return; const questData = GameData.QUESTS[questId]; const questState = { ...questData, progress: questData.objectives.map(o => ({ ...o, current: 0 })), giver: giver }; this.quests.push(questState); game.ui.updateQuestLog(); }
    
    updateQuestProgress(type, targetId, amount = 1) {
        this.quests.forEach(quest => {
            quest.progress.forEach(obj => {
                const targetMatch = (type === 'craft' && obj.itemId === targetId) || (type === 'kill' && obj.target === targetId);
                if (obj.type === type && targetMatch && obj.current < obj.count) {
                    obj.current += amount;
                    const targetName = (type === 'craft') ? GameData.ITEMS[targetId].name : targetId;
                    game.createFloatingText(`${targetName}: ${obj.current}/${obj.count}`, this.x, this.y - 40, '#ffd700');
                    game.ui.updateQuestLog();
                }
            });
        });
    }
    
        craftItem(recipeId) {
        const recipe = GameData.CRAFTING_RECIPES[recipeId];
        if (!recipe) return false;

        const profession = this.professions[recipe.profession];
        if (!profession || profession.level < recipe.skillRequired) {
            game.createFloatingText("Skill too low!", this.x, this.y, 'red');
            return false;
        }
        
        let hasMaterials = true;
        for (const mat of recipe.materials) {
            const playerMat = this.inventory.find(item => item && item.id === mat.itemId);
            if (!playerMat || playerMat.quantity < mat.quantity) {
                hasMaterials = false;
                game.createFloatingText("Missing materials!", this.x, this.y, 'red');
                break;
            }
        }
        if (!hasMaterials) return false;

        for (const mat of recipe.materials) {
            this.removeItem(mat.itemId, mat.quantity);
        }
        
        const craftYield = recipe.yield || 1;
        this.addItem(recipe.itemId, craftYield); 
        game.createFloatingText(`Crafted: ${recipe.name}` + (craftYield > 1 ? ` (x${craftYield})` : ''), this.x, this.y, 'lightgreen');
        
        // --- FIX: This block is now updated to award player XP ---
        if (recipe.playerXpGain) {
            // We use a different y-offset to stack it neatly with the profession XP text
            this.addXp(recipe.playerXpGain, -20);
        }
        // --- END OF FIX ---

        if (recipeId === 'simple_wooden_bow') {
            this.addRecipe('simple_wooden_arrow');
        }
        
        this.updateQuestProgress('craft', recipe.itemId);

        const profXpGain = recipe.xpGain !== undefined ? recipe.xpGain : 10;
        if (profXpGain > 0) {
            // We use the default y-offset for profession XP
            this.gainProfessionXp(recipe.profession, profXpGain); 
        }

        game.ui.updateAll(this); 
        return true;
    }
    checkRecipeUnlocksForLevel(professionName, level) {
        const recipeUnlocks = GameData.SKILL_RECIPE_UNLOCKS[professionName];
        if (recipeUnlocks) {
            recipeUnlocks.forEach(unlock => {
                if (unlock.level === level) {
                    this.addRecipe(unlock.recipeId);
                }
            });
        }
    }
        gainProfessionXp(professionName, amount, yOffset = -60) {
        const profession = this.professions[professionName]; if (!profession) return;
        const professionData = GameData.PROFESSIONS[professionName]; if (!professionData) return;
        if (profession.level >= professionData.maxLevel) return;
        
        profession.xp += amount; 

        // FIX: Use the yOffset parameter for the vertical position
        game.createFloatingText(`+${amount} ${professionName} XP`, this.x, this.y + yOffset, 'lightgray');
        
        if (profession.level === 0) {
            profession.level = 1;
            this.checkRecipeUnlocksForLevel(professionName, 1);
        }
        
        while (profession.xp >= profession.nextLevelXp && profession.level < professionData.maxLevel) { 
            profession.xp -= profession.nextLevelXp; 
            profession.level++; 
            // --- FIX: Modify the player's 'nextLevelXp', not the template's ---
            profession.nextLevelXp += 50; 
            
            game.createFloatingText(`${professionName} Level Up!`, this.x, this.y - 100, 'gold');

            Object.values(GameData.QUESTS).forEach(quest => {
                if (quest.requirements && !this.quests.find(q => q.id === quest.id)) {
                    quest.requirements.forEach(req => {
                        if (req.type === 'profession' && req.name === professionName && profession.level === req.level) {
                            let giverName = "a Quest Giver";
                            for (const region of GameData.REGIONS) {
                                const giver = region.npcs.find(npc => npc.questIds && npc.questIds.includes(quest.id));
                                if (giver) { giverName = giver.name; break; }
                            }
                            game.createFloatingText(`New Quest Available! Check ${giverName}.`, this.x, this.y - 80, 'gold');
                        }
                    });
                }
            });

            this.checkRecipeUnlocksForLevel(professionName, profession.level);
        }
    }
    
    draw(ctx, camera, player) {
        super.draw(ctx, camera, player);

        if (this.isGathering && this.gatheringTotalTime > 0) {
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            const radius = 25;
            const progress = this.gatheringTimer / this.gatheringTotalTime;
            const startAngle = -Math.PI / 2;
            const endAngle = startAngle + (progress * 2 * Math.PI);

            ctx.beginPath();
            ctx.arc(drawX, drawY - 40, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 5;
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(drawX, drawY - 40, radius, startAngle, endAngle);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 5;
            ctx.stroke();
        }

        if(this.isTargeted) {
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(drawX, drawY + this.size/2, this.size/1.5, this.size/3, 0, 0, 2*Math.PI);
            ctx.stroke();
        }
    }
}

class Projectile extends Entity {
    constructor(caster, target, speed, icon, color, size, onHit, trail = false) {
        // --- FIX: Removed the incorrect 'trail' variable from the super() call ---
        super(caster.x, caster.y, size, color, icon);
        
        this.caster = caster;
        this.target = target;
        this.speed = speed;
        this.onHit = onHit;
        this.isInteractable = false;
        
        this.hasTrail = trail;
        this.trailCooldown = 0;
    }

    update(deltaTime) {
        // If the target is gone or dead, the projectile fizzles out.
        if (!this.target || this.target.isDead) {
            this.isDead = true;
            return;
        }

        if (this.hasTrail) {
            this.trailCooldown -= deltaTime;
            if (this.trailCooldown <= 0) {
                // Create a smaller, fading particle behind the projectile
                ParticleSystem.create(this.x, this.y, this.color, 1, this.size * 0.5, 0.2, { vx: 0, vy: 0 });
                this.trailCooldown = 25; // New trail particle every 25ms
            }
        }

        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
        const distanceToTarget = distance(this, this.target);
        const moveDistance = this.speed * (deltaTime / 1000);

        if (distanceToTarget <= moveDistance) {
            this.onHit(this.caster, this.target);
            this.isDead = true;
        } else {
            this.x += Math.cos(angle) * moveDistance;
            this.y += Math.sin(angle) * moveDistance;
        }
    }
}

class NPC extends Character {
    constructor(x, y, name, icon, color) { super(x, y, 28, color || '#00ff00', icon || '\uf0c0', name); this.isInteractable = true; }
    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        ctx.font = '14px Verdana'; 
        ctx.fillStyle = this.color; 
        ctx.textAlign = 'center'; 
        ctx.fillText(this.name, drawX, drawY - this.size); 
    }
    interact(player) {}
}

class GenericNPC extends NPC {
    constructor(x, y, type) {
        super(x, y, type.name, type.icon, type.color);
        this.interactType = type.interactType;
        this.sells = type.sells;
        this.buys = type.buys;
        this.baseInteraction = type.interaction;
        this.profession = type.profession;
        
        // --- NEW: Gold and Gold Regeneration Logic ---
        this.gold = type.startingGold || 0;
        this.maxGold = type.startingGold || 0;
        // 5 hours = 18,000 seconds. Regen rate = maxGold / 18000
        this.goldRegenRate = this.maxGold / 18000; 
    }
    
    // --- NEW: Add an update method for gold regeneration ---
    update(deltaTime) {
        super.update(deltaTime);
        if (this.gold < this.maxGold) {
            this.gold += this.goldRegenRate * (deltaTime / 1000);
            this.gold = Math.min(this.gold, this.maxGold);
        }
    }

    interact(player) {
        if (player.isGhost) return;
        if (this.interactType === 'vendor') {
            game.ui.openVendorWindow(player, this);
        } else if (this.interactType === 'crafting_trainer') {
            if (this.baseInteraction) {
                this.baseInteraction(player);
            }
        } else {
            if (this.baseInteraction) {
                this.baseInteraction(player);
            } else {
                alert(`Hello, ${player.name}. I am ${this.name}.`);
            }
        }
    }
}

class CraftingStation extends Entity {
    constructor(x, y, typeData) { super(x, y, typeData.size || 30, typeData.color, typeData.icon); this.name = typeData.name; this.type = typeData.type; this.recipes = typeData.recipes; this.isInteractable = true; }
    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        ctx.font = '14px Verdana'; 
        ctx.fillStyle = this.color; 
        ctx.textAlign = 'center'; 
        ctx.fillText(this.name, drawX, drawY - this.size); 
    }
    interact(player) { if (player.isGhost) return; game.ui.openCraftingWindow(player, this); }
}

class PlayerHouse extends Entity {
    constructor(x, y, type) {
        super(x, y, type.size, type.color, type.icon);
        this.type = type;
        this.isInteractable = true;
        this.isCollidable = type.isCollidable || false;
    }

    interact(player) {
        if (player.isGhost) return;

        if (!player.hasHouse) {
            const doClaim = confirm("This house is abandoned and empty with the door wide open. Would you like to claim this house as your home?");
            if (doClaim) {
                player.hasHouse = true;
                game.createFloatingText("You now have a home!", player.x, player.y, 'gold');
                // Optional: Change the house color to show ownership
                this.color = '#ffd700';
            }
        } else {
            // Teleport logic (similar to DungeonEntrance)
            game.createFloatingText("Entering your home...", player.x, player.y, 'white');
            player.returnLocation = { x: player.x, y: player.y };
            player.x = this.type.target.x;
            player.y = this.type.target.y;
        }
    }

    draw(ctx, camera, player) {
        super.draw(ctx, camera, player);
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        
        // Change the nameplate based on ownership
        const nameText = player.hasHouse ? `${player.name}'s Home` : "Abandoned Cabin";
        
        ctx.font = '14px Verdana';
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center';
        ctx.fillText(nameText, drawX, drawY - this.size);
    }
}

class StorageContainer extends Entity {
    constructor(x, y, icon, color, size) {
        super(x, y, size, color, icon);
        this.name = "Storage Chest";
        this.isInteractable = true;
    }

    interact(player) {
        if (player.isGhost) return;
        game.ui.openStorageWindow(player);
        player.setTarget(this);
    }

    draw(ctx, camera, player) {
        super.draw(ctx, camera, player);
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        ctx.font = '14px Verdana';
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center';
        ctx.fillText(this.name, drawX, drawY - this.size);
    }
}

// --- CORRECTED CLASS ---
// Now extends NPC to inherit its drawing methods and other properties.
class DungeonEntrance extends NPC {
    constructor(x, y, name, target, isExit = false) {
        const icon = isExit ? '\uf2f5' : '\uf6d3';
        const color = '#ff8c00';
        super(x, y, name, icon, color);
        this.target = target;
        this.isExit = isExit;
    }

    interact(player) {
        if (this.isExit) {
            if (player.returnLocation) {
                // --- FIX: Get the region name BEFORE teleporting ---
                // Use a fallback name just in case the player is somehow in the void.
                const regionName = game.currentRegion ? game.currentRegion.name : "the dungeon";

                // Now, teleport the player
                player.x = player.returnLocation.x;
                player.y = player.returnLocation.y;
                player.returnLocation = null;

                // Finally, create the floating text using the saved name
                game.createFloatingText(`Leaving ${regionName}...`, player.x, player.y, 'white');
            }
        } else {
            game.createFloatingText(`Entering ${this.name}...`, player.x, player.y, 'white');
            player.returnLocation = { x: player.x, y: player.y };
            player.x = this.target.x;
            player.y = this.target.y;
        }
    }
}

class Portal extends NPC {
    constructor(x, y, name, target) {
        // Use a unique icon and a magical color for portals
        super(x, y, name, '\uf6d9', '#9400d3');
        this.target = target;
    }

    interact(player) {
        if (player.isGhost) return;
        
        game.createFloatingText("Whoosh!", player.x, player.y, '#9400d3');
        player.x = this.target.x;
        player.y = this.target.y;
    }
}

class PlayerCorpse extends Entity {
    constructor(x, y) { super(x, y, 30, '#ff4500', '\uf521'); this.isInteractable = false; }
    draw(ctx, camera, player) { 
        if (player.isGhost) { 
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.fillStyle = "rgba(255, 255, 0, 0.3)"; 
            ctx.beginPath(); 
            ctx.arc(drawX, drawY, 40, 0, 2*Math.PI); 
            ctx.fill(); 
        } 
        super.draw(ctx, camera, player); 
    }
}

class Scenery extends Entity {
    constructor(x, y, type) {
        super(x, y, type.size, type.color, type.icon);
        this.type = type;
        this.isInteractable = false;
        
        // --- FIX: Ensure the isCollidable property is copied from the data to the object instance ---
        this.isCollidable = type.isCollidable || false;
    }
    
    draw(ctx, camera, player) {
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;

        if (drawX + this.size < 0 || drawX - this.size > camera.width || drawY + this.size < 0 || drawY - this.size > camera.height) {
            return;
        }

        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.ellipse(drawX, drawY + this.size / 2, this.size / 2.5, this.size / 5, 0, 0, 2 * Math.PI);
        ctx.fill();

        ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`;
        ctx.fillStyle = this.type.color; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icon, drawX, drawY);
    }
}


class ResourceNode extends Entity {
    constructor(x, y, type) { 
        super(x, y, type.size, type.color, type.icon); 
        this.type = type; 
        this.isInteractable = true; 
        this.depleted = false; 
        
        // --- NEW: Add a property to track hover state ---
        this.isHovered = false;
    }
    
    interact(player) {
        if (this.depleted || player.isGhost) return;

        const profession = player.professions[this.type.requiredSkill];
        
        if (profession.level < this.type.requiredSkillLevel) {
            game.createFloatingText(`Requires ${this.type.requiredSkill} (${this.type.requiredSkillLevel})`, player.x, player.y, 'red');
            return;
        }

        if (this.type.requiredSkill === 'Mining') {
            if (!player.hasItem(27)) {
                game.createFloatingText('Requires Pickaxe', player.x, player.y, 'red');
                return;
            }
        }
        
        if (profession.level === 0) {
            profession.level = 1;
            game.createFloatingText(`You learned ${this.type.requiredSkill}!`, player.x, player.y, 'gold');
        }
        
        player.startGathering(this);
    }
    
    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        
        // --- FIX: Only draw the name if the node is hovered and not depleted ---
        if (!this.depleted && this.isHovered) { 
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.font = '12px Verdana'; 
            ctx.fillStyle = this.type.color; 
            ctx.textAlign = 'center'; 
            ctx.fillText(this.type.name, drawX, drawY - this.size); 
        } 
    }
}

class QuestGiver extends NPC {
    // --- MODIFIED CONSTRUCTOR ---
    constructor(x, y, name, questIds, npcType = null) {
        const typeData = GameData.NPC_TYPES[npcType];
        // Determine icon and color based on npcType, with fallbacks for generic quest givers
        const icon = typeData ? typeData.icon : '\uf0e7';
        const color = typeData ? typeData.color : '#ffd700';
        
        super(x, y, name, icon, color);
        this.questIds = questIds;
        this.npcType = npcType; // Store the npcType for later use in the interact method
    }

    getQuestStatus(player) {
        for (const questId of this.questIds) {
            const questData = GameData.QUESTS[questId];
            const playerQuest = player.quests.find(q => q.id === questId);

            if (playerQuest) { // Player has the quest
                if (playerQuest.progress.every(p => p.current >= p.count)) return 'complete';
            } else { // Player does not have the quest
                if (player.questCooldowns[questId]) continue; // Quest is on cooldown

                // Check requirements
                let meetsReqs = true;
                if (questData.requirements) {
                    for (const req of questData.requirements) {
                        if (req.type === 'profession' && player.professions[req.name].level < req.level) {
                            meetsReqs = false;
                            break;
                        }
                        // Add other requirement types here (e.g., level, reputation)
                    }
                }
                if (meetsReqs) return 'available';
            }
        }
        return 'none';
    }

    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        if(player.isGhost) return; 
        const status = this.getQuestStatus(player); 
        let questIcon = ''; 
        let iconColor = '#ffd700'; 
        if (status === 'available') questIcon = '!'; 
        if (status === 'complete') { questIcon = '?'; iconColor = '#ffd700'; } 
        else if (player.quests.find(q => this.questIds.includes(q.id) && !q.progress.every(p => p.current >= p.count))) { 
            questIcon = '?'; iconColor = '#888'; 
        } 
        if (questIcon) { 
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.font = 'bold 30px Arial'; 
            ctx.fillStyle = iconColor; 
            ctx.fillText(questIcon, drawX, drawY - this.size - 25); 
        } 
    }

    interact(player, isAutomatic = false) {
        if (player.isGhost) return;

        const npcTypeData = GameData.NPC_TYPES[this.npcType];
        
        if (npcTypeData && npcTypeData.interactType === 'crafting_trainer' && npcTypeData.professions) {
            for (const professionName of npcTypeData.professions) {
                const profession = player.professions[professionName];
                if (profession && profession.level === 0) {
                    const doLearn = confirm(`Greetings. I can teach you the basics of ${professionName} for 5 silver. Would you like to learn?`);
                    if (doLearn) {
                        if (player.gold >= 500) {
                            player.gold -= 500;
                            profession.level = 1;
                            alert(`You have learned ${professionName}!`);
                            
                            // --- FIX: Check for level 1 recipes immediately upon learning ---
                            player.checkRecipeUnlocksForLevel(professionName, 1);

                            game.ui.updateAll(player);
                        } else {
                            alert("You don't have enough coin.");
                        }
                    }
                    return; 
                }
            }
        }

        const availableQuestId = this.questIds.find(qId => this.getQuestStatusForId(player, qId) === 'available');
        const completableQuestId = this.questIds.find(qId => this.getQuestStatusForId(player, qId) === 'complete');
        const questId = completableQuestId || availableQuestId;

        if (!questId) {
            if (!isAutomatic) { 
                alert(`Hello, ${player.name}. I have no tasks for you at the moment.`);
            }
            return;
        }

        const questData = GameData.QUESTS[questId];
        const playerQuestInstance = player.quests.find(q => q.id === questId);
        
        if (completableQuestId) {
            if (!isAutomatic) {
                alert(`Quest Complete: ${questData.title}\nYou receive your rewards.`);
            } else {
                game.createFloatingText(`Quest Complete: ${questData.title}`, player.x, player.y - 60, 'gold');
            }
            player.addXp(questData.rewards.xp);
            player.gold += questData.rewards.gold;
            if (questData.rewards.reputation) player.addReputation(questData.rewards.reputation.faction, questData.rewards.reputation.value);
            if (questData.rewards.items) { questData.rewards.items.forEach(item => player.addItem(item.id, item.quantity)); }
            if (questData.rewards.recipes) { questData.rewards.recipes.forEach(recipeId => player.addRecipe(recipeId)); }
            
            player.quests = player.quests.filter(q => q.id !== questId);
            if (questData.repeatable && questData.cooldown) {
                player.questCooldowns[questId] = questData.cooldown;
            }
            if (player.isAutoQuesting && player.autoQuest && player.autoQuest.id === questId) {
                player.toggleAutoQuest(player.autoQuest);
            }
            game.ui.updateAll(player);
        } else if (availableQuestId) {
            const doAccept = isAutomatic || confirm(`Quest: ${questData.title}\n\n${questData.description}\n\nAccept quest?`);
            if (doAccept) {
                player.addQuest(questId, this);
            }
        } else if (playerQuestInstance && !isAutomatic) {
            const objectivesText = playerQuestInstance.progress.map(obj => {
                const targetName = obj.type === 'craft' ? GameData.ITEMS[obj.itemId].name : obj.target;
                return `- ${targetName}: ${obj.current}/${obj.count}`;
            }).join('\n');
            alert(`You are currently on quest: ${playerQuestInstance.title}.\nProgress:\n${objectivesText}`);
        }
    }

    getQuestStatusForId(player, questId) {
        const questData = GameData.QUESTS[questId];
        const playerQuest = player.quests.find(q => q.id === questId);
        if (playerQuest) {
            return playerQuest.progress.every(p => p.current >= p.count) ? 'complete' : 'in_progress';
        }
        if (player.questCooldowns[questId]) return 'on_cooldown';
        let meetsReqs = true;
        if (questData.requirements) {
            for (const req of questData.requirements) {
                if (req.type === 'profession' && player.professions[req.name].level < req.level) {
                    meetsReqs = false;
                    break;
                }
            }
        }
        return meetsReqs ? 'available' : 'unavailable';
    }
}
class Enemy extends Character {
    constructor(x, y, type, levelOverride = null) { 
        super(x, y, type.size, type.color, type.icon, type.name); 
        this.type = type; 
        
        this.level = levelOverride || type.level || 1;

        const baseHealth = type.health || 50;
        const baseAttack = type.attack || 5;

        const healthMultiplier = Math.pow(1.15, this.level - 1);
        const attackMultiplier = Math.pow(1.15, this.level - 1);
        
        this.stats.health = this.stats.maxHealth = Math.round(baseHealth * healthMultiplier);
        this.stats.attackPower = Math.round(baseAttack * attackMultiplier);
        
        const baseXP = type.xp || 10;
        // --- FIX: Store the scaled XP in a new property on the instance, not the template ---
        this.xpValue = Math.round(baseXP * Math.pow(1.1, this.level - 1));

        this.state = 'patrol'; 
        this.patrolTarget = { x: x + (Math.random()*200-100), y: y + (Math.random()*200-100) }; 
        this.attackSpeed = type.attackSpeed; 
        this.autoAttackTimer = 0; 
        this.spawnPoint = {x, y}; 
    }
    update(deltaTime, world, entities, player) { if(this.isDead) return; super.update(deltaTime); this.autoAttackTimer += deltaTime; const distToPlayer = distance(this, player); switch(this.state) { case 'patrol': if(distToPlayer < this.type.aggroRadius && !player.isDead && !player.isGhost) { this.state = 'chase'; this.setTarget(player); this.threatTable.set(player, 1); } else { if (!this.isRooted) this.moveTowards(this.patrolTarget, deltaTime); if (distance(this, this.patrolTarget) < 10) this.patrolTarget = { x: this.spawnPoint.x + (Math.random()*200-100), y: this.spawnPoint.y + (Math.random()*200-100) }; } break; case 'chase': if (!this.target || this.target.isDead || this.target.isGhost || distance(this, this.spawnPoint) > this.type.aggroRadius * 2.5) { this.state = 'patrol'; this.setTarget(null); this.threatTable.clear(); this.stats.health = this.stats.maxHealth; this.patrolTarget = this.spawnPoint; } else if (distance(this, this.target) <= this.type.attackRange) { this.state = 'attack'; } else { if (!this.isRooted) this.moveTowards(this.target, deltaTime); } break; case 'attack': if (!this.target || this.target.isDead || this.target.isGhost) { this.state = 'patrol'; this.setTarget(null); return; } if (distance(this, this.target) > this.type.attackRange) { this.state = 'chase'; } else { if (this.autoAttackTimer >= this.attackSpeed) { if (this.type.onAttack) this.type.onAttack(this, this.target); else this.target.takeDamage(this.stats.attackPower, 'physical', this); this.autoAttackTimer = 0; } } break; } }
    moveTowards(target, deltaTime) { const angle = Math.atan2(target.y - this.y, target.x - this.x); this.x += Math.cos(angle) * this.type.speed * (deltaTime / 16.67); this.y += Math.sin(angle) * this.type.speed * (deltaTime / 16.67); }
    die(killer) { 
        super.die();
        if (killer instanceof Player) {
            // --- FIX: Use the instance's calculated xpValue, not the template's ---
            killer.addXp(this.xpValue);
            
            killer.updateQuestProgress('kill', this.type.name.split(" ")[1].toUpperCase());
            if(this.type.reputation) killer.addReputation(this.type.reputation.faction, this.type.reputation.value);
            this.type.lootTable.forEach(item => { if(Math.random() < item.chance) { if(item.gold) { killer.gold += item.gold; game.createFloatingText(`+${UI.formatCurrency(item.gold)}`, this.x, this.y, 'gold'); } if(item.itemId) { const quantity = item.min ? Math.floor(Math.random() * (item.max - item.min + 1)) + item.min : 1; killer.addItem(item.itemId, quantity); const itemData = GameData.ITEMS[item.itemId]; game.createFloatingText(`+ ${itemData.name}`, this.x, this.y - 20, `var(--color-text-${itemData.quality})`); } } });
            game.ui.updateInventory(killer); game.ui.setupActionbar(killer);
        }
    }
}
class Particle {
    constructor(ctx, x, y, color, size, lifetime, speed, options = {}) {
        this.ctx = ctx; this.x = x; this.y = y; this.color = color;
        this.initialSize = size; this.size = size;
        this.lifetime = lifetime; this.initialLifetime = lifetime;
        const angle = Math.random() * Math.PI * 2;
        this.vx = options.vx !== undefined ? options.vx : Math.cos(angle) * speed * (Math.random() * 5);
        this.vy = options.vy !== undefined ? options.vy : Math.sin(angle) * speed * (Math.random() * 5);
        this.active = true;
    }
    update(deltaTime) {
        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) { this.active = false; return; }
        this.x += this.vx * (deltaTime / 16.67);
        this.y += this.vy * (deltaTime / 16.67);
        this.size = this.initialSize * (this.lifetime / this.initialLifetime);
    }
    draw(ctx, camera) {
        if (!this.active) return;
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(drawX, drawY, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

const ParticleSystem = {
    particles: [],
    init(ctx) { this.ctx = ctx; },
    create(x, y, color, count = 20, lifetime = 1, speed = 2, options = {}) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(this.ctx, x, y, color, Math.random() * 5 + 2, lifetime * 1000, speed, options));
        }
    },
    update(deltaTime) {
        this.particles = this.particles.filter(p => p.active);
        this.particles.forEach(p => p.update(deltaTime));
    },
    draw(camera) {
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'lighter';
        this.particles.forEach(p => {
            p.draw(this.ctx, camera);
        });
        this.ctx.restore();
    }
};

class InputHandler {
    constructor(isMobile) { this.keys = {}; this.mouse = { x: 0, y: 0, clicked: false }; this.isMobile = isMobile; isMobile ? this.setupMobileControls() : this.setupDesktopControls(); }
    setupDesktopControls() { 
        window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true); 
        window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false); 
        window.addEventListener('mousedown', (e) => { if(e.target.id === 'game-canvas') this.mouse.clicked = true; }); 
        window.addEventListener('mousemove', (e) => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; }); 
        
        // --- FIX: Add this event listener to clear keys when the window regains focus ---
        window.addEventListener('focus', () => { this.keys = {}; });
    }
    setupMobileControls() { const joystickArea = $('#joystick-area'); const joystickThumb = $('#joystick-thumb'); this.joystickVector = {x: 0, y: 0}; const handleTouch = (e) => { e.preventDefault(); const joystickRect = joystickArea.getBoundingClientRect(); const centerX = joystickRect.width / 2; const centerY = joystickRect.height / 2; const touch = e.touches[0]; let x = touch.clientX - joystickRect.left - centerX; let y = touch.clientY - joystickRect.top - centerY; const dist = Math.sqrt(x*x + y*y); const maxDist = centerX - joystickThumb.offsetWidth / 2; if (dist > maxDist) { x = (x / dist) * maxDist; y = (y / dist) * maxDist; } joystickThumb.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`; this.joystickVector = { x: x / maxDist, y: y / maxDist }; }; joystickArea.addEventListener('touchstart', handleTouch, { passive: false }); joystickArea.addEventListener('touchmove', handleTouch, { passive: false }); joystickArea.addEventListener('touchend', () => { joystickThumb.style.transform = `translate(-50%, -50%)`; this.joystickVector = { x: 0, y: 0 }; }); $('#game-canvas').addEventListener('touchstart', (e) => { const touch = e.touches[0]; if (touch.clientX > 200 && touch.clientY < window.innerHeight - 100) { this.mouse.x = touch.clientX; this.mouse.y = touch.clientY; this.mouse.clicked = true; } }); }
    getMoveVector() { if(this.isMobile) return this.joystickVector; let vector = { x: 0, y: 0 }; if (this.keys['w']) vector.y -= 1; if (this.keys['s']) vector.y += 1; if (this.keys['a']) vector.x -= 1; if (this.keys['d']) vector.x += 1; return vector; }
}
class UI {
    constructor(game) { 
        this.game = game; 
        this.minimapCanvas = $("#minimap-canvas"); 
        this.mCtx = this.minimapCanvas.getContext("2d");
        this.mapCanvas = $("#map-canvas"); 
        this.mapCtx = this.mapCanvas.getContext("2d"); 
        this.tooltip = $('#tooltip'); 
        this.needsVendorUpdate = true; 
        this.needsCraftingUpdate = true; 
        this.mapCacheCanvas = document.createElement('canvas');
        this.mapCacheCtx = this.mapCacheCanvas.getContext('2d');
        this.mapNeedsRedraw = true;

        this.minimapCanvas.width = 150;
        this.minimapCanvas.height = 150;

        this.setupActionbar(game.player);
        if (game.isMobile) this.setupMobileActionButtons(game.player);
        this.setupTooltips();
        this.setupDragAndDrop(game.player);
        window.addEventListener('resize', () => { this.mapNeedsRedraw = true; });
    }

    // --- All UI Methods Must Be Inside This Class ---

    openStorageWindow(player) {
        $('#storage-window').style.display = 'flex';
        this.updateStorage(player);
    }

    updateStorage(player) {
        const grid = $('#storage-grid');
        grid.innerHTML = '';
        player.storage.forEach((item, index) => {
            const slot = document.createElement('div');
            slot.className = 'storage-slot';
            slot.dataset.index = index;
            slot.dataset.source = 'storage';
            if (item) {
                slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`;
                if (item.stackable && item.quantity > 1) slot.innerHTML += `<div class="item-count">${item.quantity}</div>`;
                slot.dataset.itemId = item.id;
                slot.draggable = true;
            }
            grid.appendChild(slot);
        });
    }

    setupDragAndDrop(player) {
        let draggedItem = null;
        let sourceArray = null;
        let sourceIndex = -1;

        document.body.addEventListener('dragstart', (e) => {
            const slot = e.target.closest('[draggable="true"]');
            if (!slot) return;

            const sourceType = slot.dataset.source;
            const index = parseInt(slot.dataset.index || slot.dataset.slot);
            
            sourceArray = null;
            if (sourceType === 'inventory') sourceArray = player.inventory;
            else if (sourceType === 'storage') sourceArray = player.storage;
            else if (sourceType === 'spellbook') { 
                draggedItem = { type: 'ability', ref: player.spellbook[index] };
                e.dataTransfer.setData('text/plain', `spellbook,${index}`);
                return;
            } else if (sourceType === 'equipment') {
                sourceArray = player.equipment;
                sourceIndex = slot.dataset.slot;
                draggedItem = sourceArray[sourceIndex];
                e.dataTransfer.setData('text/plain', `equipment,${sourceIndex}`);
                return;
            }

            if (sourceArray && sourceArray[index]) {
                sourceIndex = index;
                draggedItem = sourceArray[index];
                e.dataTransfer.setData('text/plain', `${sourceType},${index}`);
            }
        });

        document.body.addEventListener('dragover', (e) => {
            e.preventDefault();
            const targetSlot = e.target.closest('.action-slot, .equipment-slot, .inventory-slot, .storage-slot, #pet-slot');
            $$('.drag-over').forEach(el => el.classList.remove('drag-over'));
            if (targetSlot) {
                targetSlot.classList.add('drag-over');
            }
        });

        document.body.addEventListener('dragleave', (e) => {
            e.target.closest('.drag-over')?.classList.remove('drag-over');
        });

        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            $$('.drag-over').forEach(el => el.classList.remove('drag-over'));
            const targetSlot = e.target.closest('.action-slot, .equipment-slot, .inventory-slot, .storage-slot, #pet-slot');
            if (!targetSlot || !draggedItem) return;

            const [sourceType, sourceIdentifier] = e.dataTransfer.getData('text/plain').split(',');

            if (targetSlot.matches('#pet-slot')) {
                const sourceIndex = parseInt(sourceIdentifier);
                if (sourceType === 'inventory' && player.inventory[sourceIndex]) {
                    player.feedPet(player.inventory[sourceIndex].id);
                }
            } else if (targetSlot.matches('.action-slot')) {
                player.setHotbarSlot(targetSlot.dataset.index, sourceType, sourceIdentifier);
            } 
            // --- FIX: Removed the incorrect '.ref' from the condition ---
            else if (targetSlot.matches('.equipment-slot') && (draggedItem.slot === targetSlot.dataset.slot || (draggedItem.slot === 'material' && targetSlot.dataset.slot === 'ammo'))) {
                player.equipItem(parseInt(sourceIdentifier));
            } else if (targetSlot.matches('.inventory-slot')) {
                const targetIndex = parseInt(targetSlot.dataset.index);
                if (sourceType === 'inventory') {
                    [player.inventory[sourceIndex], player.inventory[targetIndex]] = [player.inventory[targetIndex], player.inventory[sourceIndex]];
                } else if (sourceType === 'storage') {
                    [player.storage[sourceIndex], player.inventory[targetIndex]] = [player.inventory[targetIndex], player.storage[sourceIndex]];
                } else if (sourceType === 'equipment') {
                    player.unequipItem(sourceIdentifier);
                }
            } else if (targetSlot.matches('.storage-slot')) {
                const targetIndex = parseInt(targetSlot.dataset.index);
                if (sourceType === 'storage') {
                    [player.storage[sourceIndex], player.storage[targetIndex]] = [player.storage[targetIndex], player.storage[sourceIndex]];
                } else if (sourceType === 'inventory') {
                    [player.inventory[sourceIndex], player.storage[targetIndex]] = [player.storage[targetIndex], player.inventory[sourceIndex]];
                }
            }

            this.updateInventory(player);
            this.updateStorage(player);
            this.updateCharacterSheet(player);
            this.setupActionbar(player);
            draggedItem = null;
        });
    }

    update(player, deltaTime) {
        this.updatePlayerFrame(player);
        if (!player.isDead) {
            this.updateTargetFrame(player.target);
            this.updateXPBar(player);
            this.updateStaminaBar(player); // --- FIX: Call to updateStaminaBar is now in the correct update method ---
            this.updateCooldowns(player);
            if (this.game.isMobile) this.updateMobileCooldowns(player);
        } else {
            this.updateTargetFrame(null);
        }
        
        this.drawMinimap(player, game.entities);
        this.updateQuestTracker(player);

        $('#res-sickness-overlay').style.display = player.buffs.some(b => b.id === 'res_sickness') ? 'block' : 'none';
        
        if ($('#vendor-window').style.display === 'flex') {
            const vendor = game.entities.find(e => e.isTargeted && e.interactType === 'vendor');
            if (vendor) {
                if (this.needsVendorUpdate) {
                    this.updateVendorWindow(player, vendor);
                    this.needsVendorUpdate = false;
                }
            } else {
                $('#vendor-window').style.display = 'none';
            }
        }
        if ($('#crafting-window').style.display === 'flex') {
            const station = game.entities.find(e => e.isTargeted && e instanceof CraftingStation);
            if (station) {
                if(this.needsCraftingUpdate) {
                    this.updateCraftingWindow(player, station);
                    this.needsCraftingUpdate = false;
                }
            } else {
                $('#crafting-window').style.display = 'none';
            }
        }
        if ($('#map-window').style.display === 'flex') {
            this.updateMap();
        }
    }

    updateAll(player) { 
        this.updatePlayerFrame(player); 
        this.updateTargetFrame(player.target); 
        this.updateCharacterSheet(player); 
        this.updateInventory(player); 
        this.updateXPBar(player); 
        this.updateQuestLog(player); 
        this.updateTalentWindow(player); 
        this.updateSpellbook(player); 
        this.updateReputationWindow(player); 
        if (this.game.isMobile) this.setupMobileActionButtons(player); 
        this.updateMap(player); 
        this.updateStorage(player);
    }
    
    updatePlayerFrame(player) { $('#player-name').textContent = player.name; $('#player-level').textContent = `Lvl ${player.level}`; $('#player-health-text').textContent = `${Math.ceil(player.stats.health)} / ${player.stats.maxHealth}`; $('#player-health-fill').style.width = `${(player.stats.health / player.stats.maxHealth) * 100}%`; $('#player-mana-bar').style.display = player.race === 'Elf' ? 'block' : 'none'; if (player.race === 'Elf') { $('#player-mana-text').textContent = `${Math.ceil(player.stats.mana)} / ${player.stats.maxMana}`; $('#player-mana-fill').style.width = `${(player.stats.mana / player.stats.maxMana) * 100}%`; } this.updateBuffs(player, 'player-buffs'); }
    
    updateTargetFrame(target) { const frame = $('#target-frame'); if (target && target instanceof Character && !target.isDead) { frame.style.display = 'flex'; $('#target-portrait').innerHTML = `<i class="fas ${target.icon.substring(1)}"></i>`; $('#target-portrait').style.color = target.color; $('#target-name').textContent = target.name; $('#target-level').textContent = `Lvl ${target.level}`; $('#target-health-text').textContent = `${Math.ceil(target.stats.health)} / ${target.stats.maxHealth}`; $('#target-health-fill').style.width = `${(target.stats.health / target.stats.maxHealth) * 100}%`; this.updateBuffs(target, 'target-buffs'); } else if (target && !(target instanceof Character)) { frame.style.display = 'flex'; $('#target-portrait').innerHTML = `<i class="fas ${target.icon.substring(1)}"></i>`; $('#target-portrait').style.color = target.color; $('#target-name').textContent = target.name; $('#target-level').textContent = ''; $('#target-health-text').textContent = ''; $('#target-health-fill').style.width = `0%`; this.updateBuffs(target, 'target-buffs'); } else { frame.style.display = 'none'; } }
    
    updateXPBar(player) { const xpPercent = (player.xp / player.nextLevelXp) * 100; const restedPercent = (player.restedXp / player.nextLevelXp) * 100; $('#xp-bar-fill').style.width = `${xpPercent}%`; $('#xp-bar-rested-fill').style.width = `${Math.min(100 - xpPercent, restedPercent)}%`; $('#xp-bar').title = `XP: ${player.xp} / ${player.nextLevelXp}\nRested: ${Math.floor(player.restedXp)}`; }
    
    setupActionbar(player) { const bar = $('#action-bar'); bar.innerHTML = ''; for (let i = 0; i < 10; i++) { const slotItem = player.hotbar[i]; const slot = document.createElement('div'); slot.className = 'action-slot'; slot.dataset.index = i; slot.dataset.dropTarget = 'hotbar'; if (slotItem && slotItem.ref) { const ref = slotItem.ref; slot.innerHTML = `<i class="fas ${ref.icon} quality-${ref.quality || 'common'}"></i><div class="action-keybind">${(i+1)%10}</div>`; if(slotItem.type === 'ability') slot.innerHTML += `<div class="cooldown-overlay" data-ability-id="${ref.id}"></div>`; if(slotItem.type === 'item' && ref.quantity > 1) slot.innerHTML += `<div class="hotbar-item-count">${ref.quantity}</div>`; slot.addEventListener('click', () => player.useHotbarSlot(i)); } else { slot.innerHTML = `<div class="action-keybind">${(i+1)%10}</div>`; } bar.appendChild(slot); } if (this.game.isMobile) this.setupMobileActionButtons(player); }
    
    updateCooldowns(player) { $$('.cooldown-overlay').forEach(overlay => { const id = overlay.dataset.abilityId; const hotbarItem = player.hotbar.find(h => h && h.type === 'ability' && h.ref.id == id); if(hotbarItem && player.cooldowns[id]) { const remaining = player.cooldowns[id]; const percentage = (remaining / hotbarItem.ref.cooldown) * 100; overlay.style.height = `${percentage}%`; overlay.textContent = (remaining / 1000).toFixed(1); } else { overlay.style.height = '0%'; overlay.textContent = ''; } }); }
    
    drawMinimap(player, entities) {
        const size = 150;
        const range = 400;
        this.mCtx.clearRect(0, 0, size, size);
        this.mCtx.fillStyle = '#182c18';
        this.mCtx.fillRect(0, 0, size, size);

        const allEntities = [...entities, player];
        allEntities.sort((a,b) => a.y - b.y);

        allEntities.forEach(entity => {
            if (entity instanceof ResourceNode && entity.depleted) {
                return;
            }

            const dx = entity.x - player.x;
            const dy = entity.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const isImportant = entity instanceof QuestGiver || entity instanceof GenericNPC || entity instanceof PlayerCorpse || entity instanceof CraftingStation || entity instanceof PlayerHouse;

            if (dist > range && !isImportant) {
                return;
            }

            let mapX, mapY;

            if (dist > range) {
                const clampRadius = (size / 2) - 5;
                mapX = (size / 2) + (dx / dist) * clampRadius;
                mapY = (size / 2) + (dy / dist) * clampRadius;
            } else {
                mapX = (size / 2) + (dx / range) * (size / 2);
                mapY = (size / 2) + (dy / range) * (size / 2);
            }

            let color = 'gray';
            let radius = 3;
            if (entity instanceof Player) {
                color = player.isResting ? 'cyan' : 'white';
                radius = 4;
            } else if (entity instanceof Enemy) color = 'red';
            else if (entity instanceof QuestGiver) { color = 'yellow'; radius = 4; }
            else if (entity instanceof GenericNPC) color = '#bbb';
            else if (entity instanceof ResourceNode) color = entity.type.color;
            else if (entity instanceof PlayerCorpse) { color = '#ff4500'; radius = 4; }
            else if (entity instanceof CraftingStation) { color = entity.color; radius = 4; }
            else if (entity instanceof PlayerHouse) { color = entity.color; radius = 5; }
            else if (entity instanceof Scenery) {
                color = entity.type.color;
                radius = entity.type.size / 20;
            }
            
            this.mCtx.fillStyle = color;
            this.mCtx.beginPath();
            this.mCtx.arc(mapX, mapY, radius, 0, 2 * Math.PI);
            this.mCtx.fill();
        });
    }

    updateStaminaBar(player) {
        const bar = $('#stamina-bar');
        const fill = $('#stamina-bar-fill');

        if (player.isSprinting || (player.stamina < player.maxStamina && player.staminaRegenDelayTimer <= 0)) {
            bar.style.display = 'block';
            const percent = (player.stamina / player.maxStamina) * 100;
            fill.style.width = `${percent}%`;
        } else {
            bar.style.display = 'none';
        }
    }

    // --- FIX: The duplicate 'update' method has been REMOVED ---

    updateMap() {
        if (!game || !game.player || $('#map-window').style.display !== 'flex') {
            return;
        }

        const canvas = this.mapCanvas;
        if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            this.mapNeedsRedraw = true;
        }
        
        if (this.mapNeedsRedraw && canvas.width > 0) {
            this.drawStaticMapToCache();
            this.mapNeedsRedraw = false;
        }

        this.mapCtx.clearRect(0, 0, canvas.width, canvas.height);
        if (this.mapCacheCanvas.width > 0) {
            this.mapCtx.drawImage(this.mapCacheCanvas, 0, 0);
        }
        this.drawDynamicMapElements();
    }
    drawStaticMapToCache() {
        const regions = GameData.REGIONS;
        const cacheCanvas = this.mapCacheCanvas;
        const cacheCtx = this.mapCacheCtx;
        
        cacheCanvas.width = this.mapCanvas.width;
        cacheCanvas.height = this.mapCanvas.height;
        if (cacheCanvas.width === 0) return;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        regions.forEach(r => {
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
        });

        const padding = 5000;
        minX -= padding; minY -= padding; maxX += padding; maxY += padding;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        const worldToMap = (worldX, worldY) => ({
            x: ((worldX - minX) / contentWidth) * cacheCanvas.width,
            y: ((worldY - minY) / contentHeight) * cacheCanvas.height
        });

        cacheCtx.fillStyle = "#0A0A0A";
        cacheCtx.fillRect(0, 0, cacheCanvas.width, cacheCanvas.height);

        regions.forEach(region => {
            const start = worldToMap(region.x, region.y);
            const end = worldToMap(region.x + region.width, region.y + region.height);
            const w = end.x - start.x;
            const h = end.y - start.y;

            cacheCtx.fillStyle = region.bgColor;
            cacheCtx.globalAlpha = 0.6;
            cacheCtx.fillRect(start.x, start.y, w, h);
            cacheCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            cacheCtx.lineWidth = 1;
            cacheCtx.strokeRect(start.x, start.y, w, h);

            cacheCtx.globalAlpha = 1.0;
            cacheCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            cacheCtx.font = 'bold 14px Verdana';
            cacheCtx.textAlign = 'center';
            cacheCtx.textBaseline = 'middle';
            cacheCtx.shadowColor = "black";
            cacheCtx.shadowBlur = 4;
            cacheCtx.fillText(region.name, start.x + w / 2, start.y + h / 2);
            cacheCtx.shadowBlur = 0;
        });
    }
    drawDynamicMapElements() {
        const player = game.player;
        const entities = game.entities;
        const regions = GameData.REGIONS;
        const ctx = this.mapCtx;
        const canvasWidth = this.mapCanvas.width;
        const canvasHeight = this.mapCanvas.height;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        regions.forEach(r => { minX = Math.min(minX, r.x); minY = Math.min(minY, r.y); maxX = Math.max(maxX, r.x + r.width); maxY = Math.max(maxY, r.y + r.height); });
        const padding = 5000;
        minX -= padding; minY -= padding; maxX += padding; maxY += padding;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        const worldToMap = (worldX, worldY) => ({
            x: ((worldX - minX) / contentWidth) * canvasWidth,
            y: ((worldY - minY) / contentHeight) * canvasHeight
        });

        const dynamicEntities = [player, ...entities.filter(e => e instanceof QuestGiver || e instanceof GenericNPC || e instanceof CraftingStation)];
        
        dynamicEntities.forEach(entity => {
            const pos = worldToMap(entity.x, entity.y);

            if (entity instanceof Player) {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                const moveVector = game.input.getMoveVector();
                const angle = (moveVector.x === 0 && moveVector.y === 0) ? -Math.PI / 2 : Math.atan2(moveVector.y, moveVector.x);
                ctx.rotate(angle + Math.PI / 2);

                ctx.fillStyle = '#3498db'; ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6);
                ctx.closePath();
                ctx.fill(); ctx.stroke();
                ctx.restore();

            } else if (entity instanceof QuestGiver) {
                const status = entity.getQuestStatus(player);
                let icon = '', iconColor = 'yellow';
                if (status === 'available') icon = '!';
                else if (status === 'complete') { icon = '?'; iconColor = 'yellow'; }
                else if (player.quests.find(q => entity.questIds.includes(q.id))) { icon = '?'; iconColor = '#888'; }

                if (icon) {
                    ctx.font = 'bold 24px Arial'; ctx.fillStyle = iconColor; ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; ctx.strokeStyle = 'black'; ctx.lineWidth = 4;
                    ctx.strokeText(icon, pos.x, pos.y); ctx.fillText(icon, pos.x, pos.y);
                }
            } else if (entity instanceof GenericNPC || entity instanceof CraftingStation) {
                ctx.fillStyle = entity.color || 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            }
        });
    }
    createFloatingText(text, worldX, worldY, color, camera, type = '') {
        const textElement = document.createElement('div');
        textElement.className = `floating-text ${type}`;
        textElement.textContent = text;
        textElement.style.color = color;
        
        // --- NEW DYNAMIC STACKING LOGIC ---
        let finalY = worldY - camera.y;
        const screenX = worldX - camera.x;
        const allFloatingTexts = $$('#floating-text-container .floating-text');
        const verticalSpacing = 20; // How many pixels to move up to avoid overlap

        let isOverlapping;
        do {
            isOverlapping = false;
            for (const existingText of allFloatingTexts) {
                const existingY = existingText.offsetTop;
                // Check if our new text's Y position is too close to an existing one
                if (Math.abs(finalY - existingY) < verticalSpacing) {
                    finalY -= verticalSpacing; // Move our text up
                    isOverlapping = true;
                    break; // Restart the check with the new Y position
                }
            }
        } while (isOverlapping);
        // --- END OF NEW LOGIC ---

        textElement.style.left = `${screenX}px`;
        textElement.style.top = `${finalY}px`; // Use the final, non-overlapping Y position

        $('#floating-text-container').appendChild(textElement);
        setTimeout(() => textElement.remove(), 1500);
    }
    updateCharacterSheet(player) {
        player.recalculateStats();
        const content = $('#character-content');
        
        content.innerHTML = `
            <div id="character-sheet-container">
                <div id="equipment-column"></div>
                <div id="stats-column"></div>
            </div>
        `;

        const equipCol = $('#equipment-column');
        const slotOrder = ['head', 'chest', 'tabard', 'main-hand', 'off-hand', 'ammo'];

        slotOrder.forEach(slotName => {
            if (player.equipment.hasOwnProperty(slotName)) {
                const slot = document.createElement('div');
                slot.className = 'equipment-slot';
                slot.dataset.slot = slotName;
                const item = player.equipment[slotName];

                if (item) {
                    slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`;
                    
                    // --- FIX: Add this block to display the stack count for ammo ---
                    if (item.stackable && item.quantity > 0) {
                        slot.innerHTML += `<div class="item-count">${item.quantity}</div>`;
                    }
                    
                    slot.draggable = true;
                    slot.dataset.source = 'equipment';
                }
                slot.innerHTML += `<div class="equipment-slot-name">${slotName.replace('-', ' ')}</div>`;
                equipCol.appendChild(slot);
            }
        });

        // Add the Pet Slot to the equipment column
        const petSlot = document.createElement('div');
        petSlot.id = 'pet-slot';
        petSlot.className = 'equipment-slot';
        petSlot.dataset.slot = 'pet';
        
        const activePetData = player.activePetId ? GameData.PETS[player.activePetId] : null;
        if (activePetData) {
            petSlot.innerHTML = `<i class="fas ${activePetData.icon}"></i><div class="equipment-slot-name">Pet</div>`;
        } else {
            petSlot.innerHTML = `<div class="equipment-slot-name">Pet</div>`;
        }
        petSlot.onclick = () => {
            const firstOwnedPet = Object.keys(player.pets)[0];
            if (firstOwnedPet) {
                const newPet = player.setActivePet(player.activePetId === firstOwnedPet ? null : firstOwnedPet);
                // If a new pet was created (i.e., not dismissed), add it to the game world
                if (newPet) {
                    game.entities.push(newPet);
                }
            }
        };
        equipCol.appendChild(petSlot);

        const statsCol = $('#stats-column');
        let statsHtml = `<div class="stat-line"><span>Health</span><span>${Math.ceil(player.stats.health)} / ${player.stats.maxHealth}</span></div>`;
        if (player.race === 'Elf') statsHtml += `<div class="stat-line"><span>Mana</span><span>${Math.ceil(player.stats.mana)} / ${player.stats.maxMana}</span></div>`;
        statsHtml += `<hr><div class="stat-line"><span>Strength</span><span>${Math.floor(player.stats.strength)}</span></div> <div class="stat-line"><span>Agility</span><span>${Math.floor(player.stats.agility)}</span></div> <div class="stat-line"><span>Stamina</span><span>${Math.floor(player.stats.stamina)}</span></div>`;
        if (player.race === 'Elf') statsHtml += `<div class="stat-line"><span>Intellect</span><span>${Math.floor(player.stats.intellect)}</span></div>`;
        statsHtml += `<div class="stat-line"><span>Spirit</span><span>${Math.floor(player.stats.spirit)}</span></div><hr> <div class="stat-line"><span>Attack Power</span><span>${player.stats.attackPower.toFixed(1)}</span></div> <div class="stat-line"><span>Crit Chance</span><span>${(player.stats.critChance * 100).toFixed(2)}%</span></div> <div class="stat-line"><span>Dodge Chance</span><span>${(player.stats.dodgeChance * 100).toFixed(2)}%</span></div> <div class="stat-line"><span>Armor</span><span>${player.stats.armor}</span></div>`;
        
        let professionsHtml = '<hr><h3>Professions</h3>';
        for (const profName in player.professions) {
            const prof = player.professions[profName];
            if (prof.level > 0) {
                const profData = GameData.PROFESSIONS[profName]; 
                const xpPercent = prof.nextLevelXp > 0 ? (prof.xp / prof.nextLevelXp) * 100 : 0;
                professionsHtml += `<div class="profession-line"><div class="stat-line"><span>${profName}</span><span>${prof.level} / ${profData.maxLevel}</span></div><div class="profession-xp-bar" title="XP: ${prof.xp} / ${prof.nextLevelXp}"><div class="profession-xp-bar-fill" style="width: ${xpPercent}%;"></div></div></div>`;
            }
        }
        statsCol.innerHTML = statsHtml + professionsHtml;

        if (player.activePetId) {
            const petStore = player.pets[player.activePetId];
            const petData = GameData.PETS[player.activePetId];
            const nextLevelXp = petData.xpPerLevel[petStore.level - 1] || 'Max';
            const xpPercent = nextLevelXp !== 'Max' ? (petStore.xp / nextLevelXp) * 100 : 100;

            const petPanel = document.createElement('div');
            petPanel.id = 'pet-info-panel';
            petPanel.innerHTML = `
                <hr><h3>Pet Companion</h3>
                <div class="stat-line"><span>${petData.name}</span><span>Level ${petStore.level}</span></div>
                <div class="pet-xp-bar" title="XP: ${petStore.xp} / ${nextLevelXp}">
                    <div class="pet-xp-bar-fill" style="width: ${xpPercent}%;"></div>
                </div>
                <small>Favorite Foods: ${Object.keys(petData.favoriteFoods).map(id => GameData.ITEMS[id].name).join(', ')}</small>
            `;
            statsCol.appendChild(petPanel);
        }
    }
    updateInventory(player) { const grid = $('#inventory-grid'); grid.innerHTML = ''; player.inventory.forEach((item, index) => { const slot = document.createElement('div'); slot.className = 'inventory-slot'; slot.dataset.index = index; slot.dataset.source = 'inventory'; if (item) { slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`; if(item.stackable && item.quantity > 1) slot.innerHTML += `<div class="item-count">${item.quantity}</div>`; slot.dataset.itemId = item.id; slot.draggable = true; slot.addEventListener('click', (e) => { const currentVendor = game.entities.find(entity => entity.isTargeted && entity.interactType === 'vendor'); if (currentVendor) { this.sellItemFromInventory(player, item, index, currentVendor); } }); } grid.appendChild(slot); }); $('#currency').innerHTML = UI.formatCurrency(player.gold, true); }
    static formatCurrency(amount, useIcons = false) { const gold = Math.floor(amount / 10000); const silver = Math.floor((amount % 10000) / 100); const copper = amount % 100; if(useIcons) { return `<div class="currency-item">${gold} <div class="currency-icon gold"></div></div> <div class="currency-item">${silver} <div class="currency-icon silver"></div></div> <div class="currency-item">${copper} <div class="currency-icon copper"></div></div>`; } return `${gold}g ${silver}s ${copper}c`; }
    updateQuestLog(player = this.game.player) {
        const content = $('#quest-log-content'); content.innerHTML = ''; if (player.quests.length === 0) { content.innerHTML = 'You have no active quests.'; }
        player.quests.forEach(quest => { const item = document.createElement('div'); item.className = 'quest-item'; const details = document.createElement('div'); let objectivesHtml = ''; quest.progress.forEach(obj => { if (obj.type === 'kill') { objectivesHtml += `<div class="quest-objective">- ${obj.target} slain: ${obj.current} / ${obj.count}</div>`; } else if (obj.type === 'gather') { objectivesHtml += `<div class="quest-objective">- ${obj.target} gathered: ${player.inventory.filter(i => i && i.name.toUpperCase() === obj.target).reduce((sum, i) => sum + i.quantity, 0)} / ${obj.count}</div>`; } }); details.innerHTML = `<div class="quest-title">${quest.title}</div>${objectivesHtml}`; const button = document.createElement('button'); button.className = 'auto-quest-btn'; if (player.isAutoQuesting && player.autoQuest && player.autoQuest.id === quest.id) { button.textContent = 'Stop'; button.classList.add('active'); } else { button.textContent = 'Auto'; } button.addEventListener('click', (e) => { e.stopPropagation(); player.toggleAutoQuest(quest); }); item.appendChild(details); item.appendChild(button); content.appendChild(item); });
        const cooldownsDiv = document.createElement('div'); cooldownsDiv.style.marginTop = '10px'; cooldownsDiv.innerHTML = '<h3>Quest Cooldowns</h3>'; let hasCooldowns = false; for (const questId in player.questCooldowns) { const remainingTime = player.questCooldowns[questId]; if (remainingTime > 0) { const questData = GameData.QUESTS[questId]; const minutes = Math.floor(remainingTime / 60000); const seconds = Math.floor((remainingTime % 60000) / 1000); cooldownsDiv.innerHTML += `<div class="stat-line"><span>${questData.title}</span><span>${minutes}m ${seconds}s</span></div>`; hasCooldowns = true; } } if (hasCooldowns) { content.appendChild(cooldownsDiv); } else if (player.quests.length === 0) { content.innerHTML = 'You have no active quests or quests on cooldown.'; }
    }
    setupTooltips() {
        document.body.addEventListener('mouseover', (e) => {
            let itemRef;
            const slot = e.target.closest('.inventory-slot, .action-slot, .spellbook-slot, .buff-icon, .talent, .vendor-item-slot, .crafting-recipe-slot, .equipment-slot');
            if (!slot) return;

            if(slot.matches('.talent')) {
                const talentId = slot.dataset.talentId;
                const talentTreeKey = game.player.race === 'Elf' ? 'ELF_MAGE' : 'HUMAN_WARRIOR';
                const talentTree = GameData.TALENTS[talentTreeKey] || [];
                itemRef = talentTree.find(t => t.id === talentId);
            } 
            else if(slot.matches('.inventory-slot[data-item-id], .action-slot')) {
                let hotbarItem;
                if(slot.dataset.itemId) {
                    const invIndex = slot.dataset.index;
                    itemRef = game.player.inventory[invIndex];
                } else if (slot.dataset.index && (hotbarItem = game.player.hotbar[slot.dataset.index])) {
                    if(hotbarItem) itemRef = hotbarItem.ref;
                }
            } else if (slot.matches('.equipment-slot')) {
                const slotName = slot.dataset.slot;
                itemRef = game.player.equipment[slotName];
            } else if(slot.matches('.spellbook-slot')) {
                const spellIndex = slot.dataset.index;
                itemRef = game.player.spellbook[spellIndex];
            } else if(slot.matches('.buff-icon')) {
                const buffId = slot.dataset.buffId;
                const parentFrame = slot.closest('.unit-frame').id;
                const unit = parentFrame === 'player-frame' ? game.player : game.player.target;
                if(unit) itemRef = unit.buffs.find(b => b.id === buffId);
            } else if(slot.matches('.vendor-item-slot')) {
                const itemId = slot.dataset.itemId;
                itemRef = GameData.ITEMS[itemId];
            } else if (slot.matches('.crafting-recipe-slot')) {
                const recipeId = slot.dataset.recipeId;
                itemRef = GameData.CRAFTING_RECIPES[recipeId];
            }
            
            if (!itemRef) return;

            let statsHtml = '';
            
            if (itemRef.weaponDamage) {
                statsHtml += `<div class="stats"><div>${itemRef.weaponDamage.min} - ${itemRef.weaponDamage.max} Damage</div></div>`;
            }

            if (itemRef.stats) {
                statsHtml += '<div class="stats">';
                for(const stat in itemRef.stats) statsHtml += `<div style="color: lightgreen">+${itemRef.stats[stat]} ${stat.charAt(0).toUpperCase() + stat.slice(1)}</div>`;
                statsHtml += '</div>';
            }
            if (itemRef.cost) statsHtml += `<div class="stats"><div>Mana Cost: ${itemRef.cost}</div><div>Cooldown: ${itemRef.cooldown/1000}s</div></div>`;
            if (itemRef.durability !== undefined) statsHtml += `<div class="durability">Durability: ${itemRef.durability} / ${itemRef.maxDurability}</div>`;
            if (itemRef.materials) {
                statsHtml += '<div class="stats">Required:<ul>';
                for (const mat of itemRef.materials) {
                    const matData = GameData.ITEMS[mat.itemId];
                    statsHtml += `<li>${mat.quantity}x ${matData.name}</li>`;
                }
                statsHtml += '</ul></div>';
            }
            
            if (itemRef.requiredFaction) {
                statsHtml += `<div class="stats" style="color: red;">Requires: ${itemRef.requiredFaction.name} - ${itemRef.requiredFaction.tier}</div>`;
            }

            let description = itemRef.slot || (itemRef.range ? `Range: ${itemRef.range}` : itemRef.description || '');
            
            if (slot.matches('.talent')) {
                const currentRank = game.player.talents[itemRef.id] || 0;
                description = `Rank ${currentRank} / ${itemRef.maxRank}<br><br>${itemRef.description}`;
            }

            this.tooltip.innerHTML = `<div class="name quality-${itemRef.quality || 'common'}">${itemRef.name}</div><div class="description">${description}</div>${statsHtml}`;
            this.tooltip.style.display = 'block';
        });

        document.body.addEventListener('mousemove', (e) => {
            if (this.tooltip.style.display === 'block') {
                let x = e.clientX + 15;
                let y = e.clientY + 15;
                if (x + this.tooltip.offsetWidth > window.innerWidth) x = e.clientX - this.tooltip.offsetWidth - 15;
                if (y + this.tooltip.offsetHeight > window.innerHeight) y = e.clientY - this.tooltip.offsetHeight - 15;
                this.tooltip.style.left = `${x}px`;
                this.tooltip.style.top = `${y}px`;
            }
        });

        document.body.addEventListener('mouseout', (e) => {
            const slot = e.target.closest('.inventory-slot, .action-slot, .spellbook-slot, .buff-icon, .talent, .vendor-item-slot, .crafting-recipe-slot, .equipment-slot');
            if (slot) this.tooltip.style.display = 'none';
        });
    }
    makeDraggable(element) { let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; const header = element.querySelector('.window-header'); const dragMouseDown = (e) => { e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; }; const elementDrag = (e) => { e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; element.style.top = (element.offsetTop - pos2) + "px"; element.style.left = (element.offsetLeft - pos1) + "px"; }; const closeDragElement = () => { document.onmouseup = null; document.onmousemove = null; }; if (header) header.onmousedown = dragMouseDown; else element.onmousedown = dragMouseDown; }
    showDeathScreen() { $('#death-screen').style.display = 'flex'; }
    hideDeathScreen() { $('#death-screen').style.display = 'none'; }
    updateTalentWindow(player) { 
        $('#talent-points-display').textContent = `Talent Points: ${player.talentPoints}`; 
        const tree = $('#talent-tree'); 
        tree.innerHTML = ''; 
        const talentTreeKey = player.race === 'Elf' ? 'ELF_MAGE' : 'HUMAN_WARRIOR';
        const talentTree = GameData.TALENTS[talentTreeKey] || [];
        talentTree.forEach(talent => { 
            const currentRank = player.talents[talent.id] || 0; 
            const div = document.createElement('div'); 
            div.className = 'talent'; 
            div.dataset.talentId = talent.id; 
            if (currentRank >= talent.maxRank) div.classList.add('maxed'); 
            if (player.talentPoints === 0 && currentRank < talent.maxRank) div.classList.add('locked'); 
            div.innerHTML = `<div class="talent-icon"><i class="fas ${talent.icon}"></i></div><div class="talent-name">${talent.name}</div><div class="talent-rank">${currentRank} / ${talent.maxRank}</div>`; 
            if (!div.classList.contains('locked') && !div.classList.contains('maxed')) { 
                div.addEventListener('click', () => player.learnTalent(talent.id)); 
            } 
            tree.appendChild(div); 
        }); 
    }
    updateSpellbook(player) { const grid = $('#spellbook-grid'); grid.innerHTML = ''; player.spellbook.forEach((ability, index) => { const slot = document.createElement('div'); slot.className = 'spellbook-slot'; slot.dataset.index = index; slot.dataset.source = 'spellbook'; slot.draggable = true; slot.innerHTML = `<i class="fas ${ability.icon}"></i>`; grid.appendChild(slot); }); if (player.recipes.length > 0) { const recipeSection = document.createElement('div'); recipeSection.innerHTML = '<hr><h3>Recipes</h3><div id="spellbook-recipes-grid" class="spellbook-grid"></div>'; grid.appendChild(recipeSection); const recipeGrid = $('#spellbook-recipes-grid'); player.recipes.forEach((recipe, index) => { const slot = document.createElement('div'); slot.className = 'spellbook-slot'; slot.dataset.index = index; slot.dataset.source = 'recipe'; slot.draggable = false; slot.innerHTML = `<i class="fas ${recipe.icon}"></i>`; recipeGrid.appendChild(slot); }); } }
    updateReputationWindow(player) { const content = $('#reputation-content'); content.innerHTML = ''; for (const factionId in GameData.FACTIONS) { const faction = GameData.FACTIONS[factionId]; const playerRep = player.reputation[factionId] || faction.base; let currentTier = faction.tiers[0]; for (let i = 0; i < faction.tiers.length; i++) { if (playerRep >= faction.values[i]) { currentTier = faction.tiers[i]; } else { break; } } let nextTierValue = ''; const currentTierIndex = faction.tiers.indexOf(currentTier); if (currentTierIndex < faction.tiers.length - 1) { nextTierValue = ` / ${faction.values[currentTierIndex + 1]}`; } content.innerHTML += `<div class="reputation-line"><span>${faction.name} (${currentTier})</span><span>${playerRep}${nextTierValue}</span></div>`; } }
    updateBuffs(character, containerId) { const container = $(`#${containerId}`); container.innerHTML = ''; if(!character || !character.buffs) return; character.buffs.forEach(buff => { const div = document.createElement('div'); div.className = 'buff-icon'; if (buff.isDebuff) div.classList.add('debuff'); div.dataset.buffId = buff.id; div.innerHTML = `<i class="fas ${buff.icon}"></i><div class="buff-duration">${(buff.duration/1000).toFixed(0)}</div>`; container.appendChild(div); }); }
    openVendorWindow(player, vendor) { this.needsVendorUpdate = true; $('#vendor-window').style.display = 'flex'; player.setTarget(vendor); }
    sellItemFromInventory(player, item, index, vendor) {
        if (!item || !item.sellPrice || !vendor.buys.includes(item.slot)) {
            game.createFloatingText("Vendor doesn't buy that!", player.x, player.y, 'red');
            return;
        }

        if (vendor.gold < item.sellPrice) {
            game.createFloatingText("Vendor doesn't have enough gold!", player.x, player.y, 'red');
            return;
        }

        // --- CORE FIX STARTS HERE ---
        
        // 1. Update gold for both parties first
        player.gold += item.sellPrice;
        vendor.gold -= item.sellPrice;
        
        game.createFloatingText(`+${UI.formatCurrency(item.sellPrice)}`, player.x, player.y, 'gold');

        // 2. Directly remove the item from the specified inventory index
        if (item.stackable && item.quantity > 1) {
            // If it's a stack, just decrease the quantity
            item.quantity--;
        } else {
            // If it's a single item or the last in a stack, remove it completely
            player.inventory[index] = null;
        }
        
        // --- This flag is no longer strictly needed but is good practice ---
        this.needsVendorUpdate = true;
        
        // --- Finally, update all relevant UI windows ---
        game.ui.updateAll(player);
    }
    buyItemFromVendor(player, itemData, price, quantity) {
        if (player.gold < price) {
            game.createFloatingText("Not enough gold!", player.x, player.y, 'red');
            return;
        }
        if (player.inventory.filter(s => s === null).length === 0 && (!itemData.stackable || !player.inventory.some(i => i && i.id === itemData.id))) {
            game.createFloatingText("Inventory full!", player.x, player.y, 'red');
            return;
        }

        this.needsVendorUpdate = true;
        
        // Find the vendor the player is interacting with
        const currentVendor = game.entities.find(e => e.isTargeted && e.interactType === 'vendor');

        // --- CORE FIX IS HERE ---
        player.gold -= price;
        // Add gold to the vendor if they exist
        if (currentVendor) {
            currentVendor.gold += price;
        }
        // --- END OF FIX ---

        player.addItem(itemData.id, quantity);
        game.createFloatingText(`-${UI.formatCurrency(price)}`, player.x, player.y, 'red');
        game.createFloatingText(`+ ${itemData.name}`, player.x, player.y - 20, 'white');
        
        // Use updateAll to ensure the vendor's gold display refreshes
        this.updateAll(player); 
    }
    openCraftingWindow(player, station) {
        $('#crafting-window').style.display = 'flex';
        this.updateCraftingWindow(player, station);
        player.setTarget(station);
        this.activeCraftingStation = station;
        this.selectedRecipe = null;
        
        // Remove any old listener to prevent duplicates
        $('#craft-button').removeEventListener('click', this.boundCraftingHandler);
        
        // --- FIX: Create a new handler with a safety check inside it ---
        this.boundCraftingHandler = () => {
            // Check if a recipe is selected at the moment of the click
            if (this.selectedRecipe) {
                player.craftItem(this.selectedRecipe.id);
            } else {
                console.error("Craft button clicked, but no recipe is selected.");
                // Optionally, give the player feedback
                game.createFloatingText("Select a recipe to craft!", player.x, player.y, 'red');
            }
        };

        $('#craft-button').addEventListener('click', this.boundCraftingHandler);
    }
    updateVendorWindow(player, vendor) {
        const playerInventoryGrid = $('#vendor-player-inventory');
        const vendorSellsGrid = $('#vendor-sells-grid');
        $('#vendor-player-gold').innerHTML = UI.formatCurrency(player.gold, true);
        const vendorGoldDisplay = $('#vendor-gold-display');
        vendorGoldDisplay.innerHTML = `Vendor Gold: ${UI.formatCurrency(Math.floor(vendor.gold), true)}`;

        playerInventoryGrid.innerHTML = '';
        vendorSellsGrid.innerHTML = '';

        player.inventory.forEach((item, index) => {
            if (item && vendor.buys.includes(item.slot) && item.sellPrice) {
                const container = document.createElement('div');
                container.className = 'vendor-item-container';

                const slot = document.createElement('div');
                slot.className = 'vendor-item-slot';
                slot.dataset.index = index;
                slot.dataset.itemId = item.id;
                slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`;

                if (item.stackable && item.quantity > 1) {
                    slot.innerHTML += `<div class="item-count">${item.quantity}</div>`;
                }

                slot.addEventListener('click', () => this.sellItemFromInventory(player, item, index, vendor));

                const priceDiv = document.createElement('div');
                priceDiv.className = 'vendor-item-price';
                priceDiv.innerHTML = UI.formatCurrency(item.sellPrice, true);

                container.appendChild(slot);
                container.appendChild(priceDiv);
                playerInventoryGrid.appendChild(container);
            }
        });

        if (vendor.sells) {
            vendor.sells.forEach((itemDef) => {
                const itemData = GameData.ITEMS[itemDef.itemId];
                if (itemData) {
                    const container = document.createElement('div');
                    container.className = 'vendor-item-container';

                    const slot = document.createElement('div');
                    slot.className = 'vendor-item-slot';
                    slot.dataset.itemId = itemData.id;
                    slot.innerHTML = `<i class="fas ${itemData.icon} quality-${itemData.quality}"></i>`;

                    if (itemDef.quantity > 1) {
                        slot.innerHTML += `<div class="item-count">${itemDef.quantity}</div>`;
                    }
                    
                    const priceDiv = document.createElement('div');
                    priceDiv.className = 'vendor-item-price';
                    priceDiv.innerHTML = UI.formatCurrency(itemDef.price, true);

                    let canBuy = true;
                    if (itemData.requiredFaction) {
                        const playerRep = player.reputation[itemData.requiredFaction.name];
                        const factionData = GameData.FACTIONS[itemData.requiredFaction.name];
                        const requiredTierIndex = factionData.tiers.indexOf(itemData.requiredFaction.tier);
                        if (!playerRep || playerRep.tierIndex < requiredTierIndex) {
                            canBuy = false;
                            slot.classList.add('locked');
                        }
                    }

                    if (canBuy) {
                        slot.addEventListener('click', () => {
                            this.buyItemFromVendor(player, itemData, itemDef.price, itemDef.quantity || 1);
                            this.needsVendorUpdate = true;
                        });
                    }

                    container.appendChild(slot);
                    container.appendChild(priceDiv);
                    vendorSellsGrid.appendChild(container);
                }
            });
        }
    }
    setupMobileActionButtons(player) { const container = $('#mobile-action-buttons'); container.innerHTML = ''; const numButtons = 3; for (let i = 0; i < numButtons; i++) { const slotItem = player.hotbar[i]; const button = document.createElement('div'); button.className = 'mobile-action-button'; if (slotItem) { const ref = slotItem.ref; button.innerHTML = `<i class="fas ${ref.icon}"></i><div class="cooldown-overlay" data-ability-id="${ref.id}"></div>`; button.addEventListener('touchstart', (e) => { e.preventDefault(); player.useHotbarSlot(i); }); } else { button.innerHTML = ``; } container.appendChild(button); } }
    updateMobileCooldowns(player) { $$('#mobile-action-buttons .cooldown-overlay').forEach((overlay, index) => { const id = overlay.dataset.abilityId; const hotbarItem = player.hotbar[index]; if(hotbarItem && player.cooldowns[id]) { const remaining = player.cooldowns[id]; const percentage = (remaining / hotbarItem.ref.cooldown) * 100; overlay.style.height = `${percentage}%`; overlay.textContent = (remaining / 1000).toFixed(1); } else { overlay.style.height = '0%'; overlay.textContent = ''; } }); }
    updateCraftingWindow(player, station) {
        const recipesGrid = $('#crafting-recipes-grid');
        const materialsDisplay = $('#crafting-materials-display');
        const craftButton = $('#craft-button');
        recipesGrid.innerHTML = '';
        materialsDisplay.innerHTML = '';
        craftButton.disabled = true;

        const availableRecipes = player.recipes.filter(r => station.recipes.includes(r.id));
        if (availableRecipes.length === 0) {
            recipesGrid.innerHTML = '<p>You have no recipes for this station.</p>';
            return;
        }
        availableRecipes.forEach(recipe => { const slot = document.createElement('div'); slot.className = 'crafting-recipe-slot'; slot.dataset.recipeId = recipe.id; slot.innerHTML = `<i class="fas ${recipe.icon} quality-${recipe.quality || 'common'}"></i>`; slot.innerHTML += `<div class="crafting-recipe-cost">${recipe.name}</div>`; if(this.selectedRecipe && this.selectedRecipe.id === recipe.id) { slot.style.borderColor = 'gold'; } slot.addEventListener('click', () => { this.selectedRecipe = recipe; this.needsCraftingUpdate = true; }); recipesGrid.appendChild(slot); });
        if (this.selectedRecipe) {
            materialsDisplay.innerHTML = `<h3>${this.selectedRecipe.name} Requirements:</h3><ul>`; let canCraft = true;
            const profession = player.professions[this.selectedRecipe.profession];
            const hasSkill = profession && profession.level >= this.selectedRecipe.skillRequired;
            if (!hasSkill) canCraft = false;

            for (const mat of this.selectedRecipe.materials) {
                const playerMat = player.inventory.find(item => item && item.id === mat.itemId);
                const hasEnough = playerMat && playerMat.quantity >= mat.quantity;
                const matData = GameData.ITEMS[mat.itemId];
                materialsDisplay.innerHTML += `<li style="color: ${hasEnough ? 'lightgreen' : 'red'};">${mat.quantity}x ${matData.name} (${playerMat ? playerMat.quantity : 0} owned)</li>`;
                if (!hasEnough) canCraft = false;
            }
            materialsDisplay.innerHTML += `<li style="color: ${hasSkill ? 'lightgreen' : 'red'};">Requires ${this.selectedRecipe.profession} (${this.selectedRecipe.skillRequired})</li>`;
            materialsDisplay.innerHTML += '</ul>'; craftButton.disabled = !canCraft; craftButton.textContent = `Craft ${this.selectedRecipe.name}`;
        }
    }
    updateQuestTracker(player) {
        const tracker = $('#quest-tracker');
        if (!player || player.quests.length === 0) {
            tracker.style.display = 'none';
            return;
        }

        tracker.style.display = 'block';
        let html = '<h3>Quest Log</h3>';

        player.quests.forEach(quest => {
            if (quest.progress.every(p => p.current >= p.count)) return;

            html += `<div class="tracker-quest-title">${quest.title}</div>`;
            quest.progress.forEach(obj => {
                html += `<div class="tracker-quest-objective">- ${obj.target} slain: ${obj.current} / ${obj.count}</div>`;
            });
        });
        
        if (html === '<h3>Quest Log</h3>') {
            tracker.style.display = 'none';
        } else {
            tracker.innerHTML = html;
        }
    }
}

function showMainMenu() {
    $('#main-menu').style.display = 'flex';
    $('#character-creation-screen').style.display = 'none';
    $('#game-container').style.display = 'none';
    
    const hasSave = localStorage.getItem('miniWowSaveData');
    $('#continue-button').disabled = !hasSave;
}

function initGame(playerOptions = null) {
    $('#main-menu').style.display = 'none';
    $('#character-creation-screen').style.display = 'none';
    $('#game-container').style.display = 'block';
    
    game = new Game(playerOptions);
    window.game = game;
}

document.addEventListener('DOMContentLoaded', () => {
    showMainMenu();

    $('#continue-button').addEventListener('click', () => {
        initGame();
    });

    $('#new-char-button').addEventListener('click', () => {
        $('#main-menu').style.display = 'none';
        $('#character-creation-screen').style.display = 'flex';
    });
    
    let selectedRace = null;
    $$('.race-option').forEach(el => {
        el.addEventListener('click', () => {
            $$('.race-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
            selectedRace = el.dataset.race;
        });
    });

    $('#start-game-button').addEventListener('click', () => {
        const name = $('#char-name-input').value.trim();
        if (!name) { alert("Please enter a name for your hero."); return; }
        if (!selectedRace) { alert("Please select a race."); return; }
        
        localStorage.removeItem('miniWowSaveData');
        
        initGame({ name, race: selectedRace });
    });
});

</script>
</body>
</html>
