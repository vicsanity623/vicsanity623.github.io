<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Mini-WoW: The 2D Adventure</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Icon Enhancement Styles -->
    <style>
        /* General flair for all icons in slots */
        .action-slot i, .inventory-slot i {
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            transition: transform 0.2s ease-out, text-shadow 0.2s ease-out;
            will-change: transform;
        }

        /* Make icons feel interactive on hover */
        .action-slot:hover i, .inventory-slot:hover i {
            transform: scale(1.15);
        }
        
        /* --- Quality-Based Glows --- */
        .quality-magic {
            text-shadow: 0 0 7px var(--color-text-magic), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
        }
        .quality-rare {
            text-shadow: 0 0 10px var(--color-text-rare), 0 0 3px var(--color-text-rare), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
        }
        .quality-epic {
            text-shadow: 0 0 12px var(--color-text-epic), 0 0 5px var(--color-text-epic), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
            animation: epic-glow 2s infinite alternate ease-in-out;
        }
        
        @keyframes epic-glow {
            from { text-shadow: 0 0 12px var(--color-text-epic), 0 0 5px var(--color-text-epic), 1px 1px 3px rgba(0, 0, 0, 0.8); }
            to   { text-shadow: 0 0 20px var(--color-text-epic), 0 0 8px #fff, 1px 1px 3px rgba(0, 0, 0, 0.8); }
        }

        /* --- Thematic Icon Coloring & Styling --- */
        .fa-burst, .fa-hand-fist { color: #ffffa0; }
        .fa-fire-flame-curved { color: #ff8c00; }
        .fa-gavel { color: #c39c6d; }
        .fa-book-skull { color: #8b008b; }
        .fa-leaf { color: #228b22; }
        .fa-person-digging { color: #cd7f32; }
        .fa-hammer { color: #a9a9a9; }
        .fa-ghost { color: #a0c4ff; }
        .fa-dove { color: #ffd700; }
        .fa-shop { color: #c0c0c0; }
        .fa-chair { color: #8b4513; }
        .fa-sword { color: #A9A9A9; }
        .fa-scythe { color: #E0E0E0; }
        .fa-vest-patches { color: #8B4513; }
        .fa-jedi { color: #f0f0f0; }
        .fa-flask-vial { color: #2E8B57; }
        .fa-network-wired { color: #F5F5F5; }
        .fa-tooth { color: #FFFAF0; }
        .fa-tree { color: #66827a; } /* Treant */
        .fa-paw-claws { color: #d3a483; } /* Bear */
        .fa-dagger { color: #9acd32; } /* Goblin Stalker */

    </style>

    <style>
        :root {
            --color-health: #28a745;
            --color-mana: #007bff;
            --color-xp: #9370db;
            --color-xp-rested: #00bfff;
            --color-enemy-health: #dc3545;
            --color-bg-dark: #1a1a1a;
            --color-bg-medium: #2a2a2e;
            --color-bg-light: #3a3a40;
            --color-border: #4f4f58;
            --color-text: #f0f0f0;
            --color-text-muted: #888;
            --color-text-quest: #ffd700;
            --color-text-magic: #87ceeb;
            --color-text-rare: #0070dd;
            --color-text-epic: #a335ee;
            --color-cooldown: rgba(0, 0, 0, 0.75);
            --font-main: 'Verdana', sans-serif;
            --color-gold: #ffd700;
            --color-silver: #c0c0c0;
            --color-copper: #b87333;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--color-bg-dark);
            font-family: var(--font-main); color: var(--color-text);
            user-select: none; -webkit-user-select: none;
        }
        #game-container { position: relative; width: 100%; height: 100%; display: none; }
        #game-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            filter: saturate(1.1) contrast(1.05);
        }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .fullscreen-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: var(--color-bg-dark);
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="none"/><path d="M 10 0 L 10 100 M 20 0 L 20 100 M 30 0 L 30 100 M 40 0 L 40 100 M 50 0 L 50 100 M 60 0 L 60 100 M 70 0 L 70 100 M 80 0 L 80 100 M 90 0 L 90 100 M 0 10 L 100 10 M 0 20 L 100 20 M 0 30 L 100 30 M 0 40 L 100 40 M 0 50 L 100 50 M 0 60 L 100 60 M 0 70 L 100 70 M 0 80 L 100 80 M 0 90 L 100 90" stroke="rgba(42,42,46,0.4)" stroke-width="1"/></svg>');
            display: flex; justify-content: center; align-items: center;
            z-index: 50000;
        }

        .menu-box {
            background-color: var(--color-bg-medium);
            padding: 30px 40px;
            border-radius: 10px; border: 2px solid var(--color-border);
            box-shadow: 0 0 25px rgba(0,0,0,0.7);
            text-align: center;
        }
        .menu-box h1 { font-size: 3em; margin-bottom: 20px; color: var(--color-text-quest); }
        .menu-button {
            display: block; width: 250px; padding: 15px; margin: 15px auto;
            font-size: 1.2em; background-color: var(--color-bg-light);
            border: 1px solid var(--color-border); color: var(--color-text);
            cursor: pointer; transition: background-color 0.2s;
        }
        .menu-button:hover { background-color: var(--color-bg-dark); border-color: #fff; }
        .menu-button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        #character-creation-screen input[type="text"] {
            width: 90%; padding: 10px; margin-bottom: 20px;
            background: var(--color-bg-dark); border: 1px solid var(--color-border);
            color: var(--color-text); font-size: 1.1em;
        }
        .race-selection { display: flex; justify-content: center; gap: 20px; margin-bottom: 20px; }
        .race-option {
            padding: 15px; border: 2px solid var(--color-border);
            cursor: pointer; transition: all 0.2s;
        }
        .race-option.selected { border-color: gold; background: var(--color-bg-light); }
        .race-option h3 { margin: 0 0 5px 0; }
        .race-option p { font-size: 0.8em; color: var(--color-text-muted); margin: 0; }


        .unit-frame { position: absolute; top: 20px; width: 250px; background-color: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; padding: 5px; display: flex; gap: 10px; align-items: center; pointer-events: all; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #player-frame { left: 20px; }
        #target-frame { left: 290px; display: none; }
        .portrait { width: 50px; height: 50px; background: var(--color-bg-dark); border: 2px solid var(--color-border); border-radius: 5px; display: flex; justify-content: center; align-items: center; font-size: 30px; }
        .unit-info { flex-grow: 1; }
        .name-level { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .resource-bar { width: 100%; height: 15px; background-color: var(--color-bg-dark); border-radius: 3px; overflow: hidden; margin-top: 2px; position: relative; }
        .resource-bar .bar-fill { height: 100%; transition: width 0.2s ease-out; }
        .resource-bar .bar-text { position: absolute; width: 100%; text-align: center; font-size: 10px; line-height: 15px; color: white; text-shadow: 1px 1px 1px black; }
        #player-health-fill { background-color: var(--color-health); }
        #player-mana-fill { background-color: var(--color-mana); }
        #target-health-fill { background-color: var(--color-enemy-health); }

        .buff-container { display: flex; gap: 3px; margin-top: 4px; height: 24px; }
        .buff-icon { width: 22px; height: 22px; background-color: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 14px; position: relative; }
        .buff-icon.debuff { border-color: var(--color-enemy-health); }
        .buff-duration { position: absolute; bottom: -1px; right: -1px; font-size: 10px; background: rgba(0,0,0,0.8); padding: 0 2px; border-radius: 2px; color: white; }
        .buff-icon .fa-skull { color: #ff4500; }
        .buff-icon .fa-heart-crack { color: #dc143c; }
        .buff-icon .fa-vine { color: #228b22; }

        #bottom-ui-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column-reverse; align-items: center; gap: 2px; }
        #action-bar { position: relative; bottom: 0; left: 0; transform: none; display: flex; background-color: var(--color-bg-medium); padding: 5px; border-radius: 5px; border: 1px solid var(--color-border); pointer-events: all; }
        .action-slot { width: 50px; height: 50px; background-color: var(--color-bg-dark); border: 1px solid var(--color-border); margin: 2px; position: relative; display: flex; justify-content: center; align-items: center; font-size: 24px; cursor: pointer; }
        .action-slot:hover { border-color: #fff; }
        .action-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        .action-slot i { pointer-events: none; }
        .action-keybind { position: absolute; top: 2px; left: 2px; font-size: 10px; color: var(--color-text-muted); }
        .hotbar-item-count { position: absolute; bottom: 2px; right: 2px; font-size: 14px; color: white; text-shadow: 1px 1px 2px black; }
        .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 0; background-color: var(--color-cooldown); pointer-events: none; display: flex; justify-content: center; align-items: center; font-size: 18px; color: white; overflow: hidden; }

        #xp-bar { position: relative; bottom: 0; left: 0; transform: none; width: 80vw; max-width: 544px; height: 8px; background-color: rgba(0,0,0,0.5); border: 1px solid var(--color-border); pointer-events: none; display: flex; }
        #xp-bar-fill { width: 0%; height: 100%; background-color: var(--color-xp); transition: width 0.5s ease-in-out; }
        #xp-bar-rested-fill { width: 0%; height: 100%; background-color: var(--color-xp-rested); transition: width 0.5s ease-in-out; }

        #minimap { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; border-radius: 50%; border: 3px solid var(--color-border); background-color: var(--color-bg-dark); overflow: hidden; pointer-events: all; }
        #minimap-canvas { width: 100%; height: 100%; }
        .window { position: absolute; width: 350px; background: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; box-shadow: 0 0 15px rgba(0,0,0,0.7); display: none; flex-direction: column; pointer-events: all; z-index: 100; }
        .window-header { padding: 8px; background: var(--color-bg-light); cursor: move; display: flex; justify-content: space-between; align-items: center; }
        .window-header .close-btn { cursor: pointer; }
        .window-content { padding: 10px; max-height: 400px; overflow-y: auto; }
        #character-window { top: 150px; left: 100px; width: 450px; }
        #inventory-window { top: 150px; left: 500px; }
        #quest-log-window { top: 100px; right: 200px; }
        #talent-window { top: 200px; left: 150px; width: 450px; }
        #spellbook-window { top: 200px; left: 600px; width: 300px; }
        #reputation-window { top: 200px; left: 950px; width: 300px; }
        #vendor-window { top: 100px; left: 300px; width: 400px; }
        #crafting-window { top: 100px; left: 300px; width: 400px; }
        
        #map-window {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            height: 80vh;
        }
        #map-window .window-content {
            padding: 0;
            overflow: hidden;
            background-color: var(--color-bg-dark);
            flex-grow: 1; 
            max-height: none;
        }
        #map-canvas {
            width: 100%;
            height: 100%;
        }

        #character-sheet-container { display: flex; justify-content: space-between; gap: 10px; }
        #equipment-slots { display: flex; flex-direction: column; gap: 5px; }
        .equipment-slot { width: 50px; height: 50px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 24px; position: relative; }
        .equipment-slot[draggable="true"] { cursor: grab; }
        .equipment-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        .equipment-slot-name { position: absolute; bottom: -15px; width: 100%; text-align: center; font-size: 10px; color: var(--color-text-muted); }
        #stats-column { flex-grow: 1; }

        #inventory-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .inventory-slot { width: 60px; height: 60px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 28px; position: relative; }
        .inventory-slot[draggable="true"] { cursor: grab; }
        .inventory-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; text-shadow: 1px 1px 1px black; }
        .quality-common { color: var(--color-text); }
        .quality-magic { color: var(--color-text-magic); }
        .quality-rare { color: var(--color-text-rare); }
        .quality-epic { color: var(--color-text-epic); }
        .stat-line { display: flex; justify-content: space-between; padding: 4px 0; }
        
        .currency-container { display: flex; justify-content: flex-end; align-items: center; gap: 5px; font-size: 14px; }
        .currency-item { display: flex; align-items: center; gap: 2px; }
        .currency-icon { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #333; }
        .gold { background-color: var(--color-gold); }
        .silver { background-color: var(--color-silver); }
        .copper { background-color: var(--color-copper); }

        .quest-item { padding: 8px; border-bottom: 1px solid var(--color-border); display: flex; justify-content: space-between; align-items: center; }
        .quest-item > div { flex-grow: 1; }
        .auto-quest-btn { padding: 4px 8px; font-size: 12px; background-color: var(--color-bg-light); border: 1px solid var(--color-border); color: var(--color-text-quest); cursor: pointer; pointer-events: all; margin-left: 10px; flex-shrink: 0; transition: background-color 0.2s; }
        .auto-quest-btn:hover { background-color: var(--color-bg-medium); border-color: #fff; }
        .auto-quest-btn.active { background-color: var(--color-enemy-health); color: white; }

        .quest-title { font-weight: bold; color: var(--color-text-quest); }
        .quest-objective { font-size: 14px; padding-left: 15px; }
        .floating-text { position: absolute; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; animation: floatUp 1.5s ease-out forwards; pointer-events: none; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-60px); opacity: 0; } }
        .floating-text.crit { font-size: 24px; animation: floatUpCrit 1.5s ease-out forwards; color: #ff4500 !important; }
        @keyframes floatUpCrit { 0% { transform: translateY(0) scale(1); opacity: 1; } 50% { transform: translateY(-40px) scale(1.5); } 100% { transform: translateY(-80px) scale(1); opacity: 0; } }
        .floating-text.miss { color: #ccc !important; font-style: italic; font-size: 16px; }

        #tooltip { position: absolute; background: var(--color-bg-dark); border: 1px solid var(--color-border); padding: 10px; border-radius: 5px; display: none; max-width: 250px; pointer-events: none; z-index: 10000; }
        #tooltip .name { font-weight: bold; margin-bottom: 5px; }
        #tooltip .description { font-size: 14px; color: var(--color-text-muted); }
        #tooltip .stats { margin-top: 8px; font-size: 14px; }
        #tooltip .durability { color: #ff4500; }
        
        #mobile-controls { position: absolute; bottom: 10px; left: 10px; width: 150px; height: 150px; display: none; pointer-events: all; }
        #joystick-area { position: relative; width: 100%; height: 100%; background: rgba(50, 50, 50, 0.4); border-radius: 50%; }
        #joystick-thumb { position: absolute; width: 60px; height: 60px; background: rgba(120, 120, 120, 0.7); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #system-menu { position: absolute; bottom: 20px; right: 20px; display: flex; pointer-events: all; gap: 2px; }
        .sys-button { width: 30px; height: 30px; background: var(--color-bg-light); border: 1px solid var(--color-border); cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .sys-button:hover { background: var(--color-bg-medium); }
        
        #talent-points-display { text-align: center; margin-bottom: 10px; font-weight: bold; }
        .talent-tree { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .talent { background: var(--color-bg-dark); border: 1px solid var(--color-border); padding: 5px; text-align: center; cursor: pointer; position: relative; }
        .talent.locked { filter: grayscale(1) brightness(0.5); cursor: not-allowed; }
        .talent.maxed { border-color: gold; }
        .talent:not(.locked):not(.maxed):hover { border-color: white; }
        .talent-icon { font-size: 30px; }
        .talent-name { font-size: 12px; margin-top: 4px; }
        .talent-rank { position: absolute; bottom: 2px; right: 2px; font-size: 12px; background: rgba(0,0,0,0.7); padding: 1px 3px; border-radius: 3px; }

        #spellbook-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .spellbook-slot { width: 50px; height: 50px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 24px; position: relative; }
        .spellbook-slot[draggable="true"] { cursor: grab; }

        .reputation-line { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid var(--color-border); }
        .rep-bar-container { width: 120px; height: 16px; background: var(--color-bg-dark); border: 1px solid var(--color-border); }
        .rep-bar-fill { height: 100%; background-color: var(--color-health); }

        #vendor-content, #crafting-content { display: flex; flex-direction: column; gap: 10px; }
        .vendor-section, .crafting-section { border: 1px solid var(--color-border); padding: 8px; background: var(--color-bg-dark); }
        .vendor-section h3, .crafting-section h3 { margin: 0 0 5px 0; font-size: 1.1em; color: var(--color-text-quest); }
        .vendor-grid, .crafting-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 5px; }
        .vendor-item-slot, .crafting-recipe-slot { width: 60px; height: 60px; background: var(--color-bg-medium); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 28px; position: relative; cursor: pointer; }
        .vendor-item-slot:hover, .crafting-recipe-slot:hover { border-color: white; }
        .vendor-item-price, .crafting-recipe-cost { position: absolute; bottom: 2px; left: 2px; font-size: 10px; color: var(--color-gold); text-shadow: 1px 1px 2px black; display: flex; align-items: center; }
        .crafting-recipe-cost.unmet { color: red; }
        .craft-button { display: block; width: calc(100% - 16px); padding: 8px; margin: 8px; background-color: var(--color-bg-light); border: 1px solid var(--color-border); color: var(--color-text); cursor: pointer; text-align: center; }
        .craft-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .craft-button:not(:disabled):hover { background-color: var(--color-bg-medium); }


        #death-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; flex-direction: column; color: #dc3545; text-align: center; font-size: 3em; text-shadow: 2px 2px 4px black; pointer-events: all; z-index: 20000; }
        #res-sickness-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(100, 0, 0, 0.2); pointer-events: none; z-index: 19999; display: none; }
        #release-spirit-button { padding: 15px 30px; font-size: 1.2em; color: var(--color-text); background-color: var(--color-bg-light); border: 2px solid var(--color-border); border-radius: 5px; cursor: pointer; margin-top: 20px; }
    
        #mobile-action-buttons { position: absolute; bottom: 20px; right: 20px; display: none; flex-direction: row; gap: 10px; pointer-events: all; }
        .mobile-action-button { width: 65px; height: 65px; background-color: var(--color-bg-medium); border: 2px solid var(--color-border); border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 30px; position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .mobile-action-button .cooldown-overlay { border-radius: 50%; font-size: 22px; }

        @media (max-width: 900px) and (orientation: landscape) {
            #action-bar, #system-menu { display: none; }
            #mobile-controls { width: 180px; height: 180px; }
            #joystick-thumb { width: 70px; height: 70px; }
            #mobile-action-buttons { display: flex; }
            .unit-frame { width: 200px; transform: scale(0.9); transform-origin: top left; }
            #target-frame { left: 200px; }
            #minimap { width: 120px; height: 120px; transform: scale(0.9); transform-origin: top right; }
            .window { width: 90vw; height: 85vh; top: 50%; left: 50%; transform: translate(-50%, -50%); }
            .window-content { max-height: calc(85vh - 50px); }
        }
        #quest-tracker {
            position: absolute;
            top: 175px;
            right: 20px;
            width: 250px;
            background-color: rgba(30, 30, 30, 0.7);
            border: 1px solid var(--color-border);
            border-radius: 5px;
            padding: 10px;
            color: var(--color-text);
            font-size: 13px;
            pointer-events: none;
            display: none; /* Hide by default */
        }
        #quest-tracker h3 {
            margin: 0 0 8px 0;
            font-size: 1.1em;
            color: var(--color-text-quest);
            text-align: center;
        }
        .tracker-quest-title {
            font-weight: bold;
            color: var(--color-text-quest);
            margin-top: 5px;
        }
        .tracker-quest-objective {
            color: #ccc;
            padding-left: 10px;
        }
    </style>
</head>
<body>
    <div id="main-menu" class="fullscreen-overlay">
        <div class="menu-box">
            <h1>Mini-WoW</h1>
            <p>The 2D Adventure</p>
            <button id="continue-button" class="menu-button">Continue</button>
            <button id="new-char-button" class="menu-button">New Character</button>
        </div>
    </div>

    <div id="character-creation-screen" class="fullscreen-overlay" style="display: none;">
        <div class="menu-box">
            <h1>Create Your Hero</h1>
            <input type="text" id="char-name-input" placeholder="Enter Name" maxlength="12">
            <div class="race-selection">
                <div class="race-option" data-race="Human">
                    <h3><i class="fas fa-user"></i> Human</h3>
                    <p>No mana. No natural health regen.</p>
                </div>
                <div class="race-option" data-race="Elf">
                    <h3><i class="fas fa-leaf"></i> Elf</h3>
                    <p>Has mana. Regenerates health.</p>
                </div>
            </div>
            <button id="start-game-button" class="menu-button">Start Adventure</button>
        </div>
    </div>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="player-frame" class="unit-frame">
                <div class="portrait"><i class="fas fa-user"></i></div>
                <div class="unit-info">
                    <div class="name-level"><span id="player-name">Player</span><span id="player-level">Lvl 1</span></div>
                    <div class="resource-bar"><div id="player-health-fill" class="bar-fill"></div><div id="player-health-text" class="bar-text">100 / 100</div></div>
                    <div class="resource-bar" id="player-mana-bar"><div id="player-mana-fill" class="bar-fill"></div><div id="player-mana-text" class="bar-text">100 / 100</div></div>
                    <div class="buff-container" id="player-buffs"></div>
                </div>
            </div>
            
            <div id="target-frame" class="unit-frame">
                <div class="portrait" id="target-portrait"></div>
                <div class="unit-info">
                    <div class="name-level"><span id="target-name"></span><span id="target-level"></span></div>
                    <div class="resource-bar"><div id="target-health-fill" class="bar-fill"></div><div id="target-health-text" class="bar-text"></div></div>
                    <div class="buff-container" id="target-buffs"></div>
                </div>
            </div>
            
            <div id="quest-tracker"></div>
            
            <div id="bottom-ui-container">
                <div id="action-bar"></div>
                <div id="xp-bar"><div id="xp-bar-rested-fill"></div><div id="xp-bar-fill"></div></div>
            </div>
            
            <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
            <div id="floating-text-container"></div>
            <div id="tooltip"></div>

            <div id="character-window" class="window">
                <div class="window-header"><span>Character</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="character-content"></div>
            </div>
            <div id="inventory-window" class="window">
                <div class="window-header"><span>Inventory</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="inventory-grid"></div><div id="currency" class="currency-container" style="margin-top: 10px; text-align: right;"></div></div>
            </div>
            <div id="quest-log-window" class="window">
                <div class="window-header"><span>Quest Log</span><i class="fas fa-times close-btn"></i></div><div class="window-content" id="quest-log-content"></div>
            </div>
            <div id="map-window" class="window">
                <div class="window-header"><span>World Map</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><canvas id="map-canvas"></canvas></div>
            </div>
            <div id="talent-window" class="window">
                <div class="window-header"><span>Talents</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content">
                    <div id="talent-points-display">Talent Points: 0</div>
                    <div id="talent-tree" class="talent-tree"></div>
                </div>
            </div>
            <div id="spellbook-window" class="window">
                <div class="window-header"><span>Spellbook</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="spellbook-grid"></div></div>
            </div>
            <div id="reputation-window" class="window">
                <div class="window-header"><span>Reputation</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="reputation-content"></div>
            </div>

            <div id="vendor-window" class="window">
                <div class="window-header"><span>Vendor</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="vendor-content">
                    <div class="vendor-section">
                        <h3>Your Items (Click to Sell)</h3>
                        <div id="vendor-player-inventory" class="vendor-grid"></div>
                    </div>
                    <div class="vendor-section">
                        <h3>Vendor Sells</h3>
                        <div id="vendor-sells-grid" class="vendor-grid"></div>
                    </div>
                    <div class="currency-container" style="text-align: right; margin-top: 10px;">Your Gold: <span id="vendor-player-gold"></span></div>
                </div>
            </div>
            
            <div id="crafting-window" class="window">
                <div class="window-header"><span>Crafting</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="crafting-content">
                    <div class="crafting-section">
                        <h3>Recipes</h3>
                        <div id="crafting-recipes-grid" class="crafting-grid"></div>
                    </div>
                    <div class="crafting-section">
                        <h3>Materials</h3>
                        <div id="crafting-materials-display"></div>
                    </div>
                    <button id="craft-button" class="craft-button" disabled>Craft</button>
                </div>
            </div>

            <div id="mobile-controls"><div id="joystick-area"><div id="joystick-thumb"></div></div></div>
            <div id="mobile-action-buttons"></div>
            <div id="system-menu">
                <button class="sys-button" id="save-button" title="Save Game"><i class="fas fa-save"></i></button>
                <button class="sys-button" data-window="character-window" title="Character (C)"><i class="fas fa-user-circle"></i></button>
                <button class="sys-button" data-window="inventory-window" title="Inventory (I)"><i class="fas fa-briefcase"></i></button>
                <button class="sys-button" data-window="spellbook-window" title="Spellbook (P)"><i class="fas fa-book"></i></button>
                <button class="sys-button" data-window="talent-window" title="Talents (N)"><i class="fas fa-sitemap"></i></button>
                <button class="sys-button" data-window="quest-log-window" title="Quest Log (L)"><i class="fas fa-book-open"></i></button>
                <button class="sys-button" data-window="map-window" title="Map (M)"><i class="fas fa-map"></i></button>
                <button class="sys-button" data-window="reputation-window" title="Reputation (U)"><i class="fas fa-users"></i></button>
            </div>
            <div id="death-screen"><p>You have died.</p><button id="release-spirit-button">Release Spirit</button></div>
            <div id="res-sickness-overlay"></div>
        </div>
    </div>

<script type="module">
const $ = (selector) => document.querySelector(selector);
const $$ = (selector) => document.querySelectorAll(selector);
const distance = (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);

const WORLD_SIZE = 100000;
const STARTING_ZONE_CENTER = { x: 50000, y: 50000 };
const RESPAWN_POINT = { x: 50000, y: 50000 };
const GRAVEYARD_POINT = { x: 48500, y: 48000 };

const GameData = {
    SCENERY: {
        1: { id: 1, name: 'Tall Pine', icon: '\uf1bb', size: 90, color: '#2E7D32' },
        2: { id: 2, name: 'Medium Oak', icon: '\uf1bb', size: 70, color: '#4CAF50' },
        3: { id: 3, name: 'Small Bush', icon: '\uf553', size: 40, color: '#689F38' },
        4: { id: 4, name: 'Spruce', icon: '\uf1bb', size: 80, color: '#1B5E20' },
    },
        ITEMS: {
        1: { id: 1, name: "Rusty Sword", icon: 'fa-gavel', slot: "main-hand", quality: "common", weaponDamage: { min: 3, max: 5 }, durability: 100, maxDurability: 100, sellPrice: 100 },
        2: { id: 2, name: "Worn Leather Vest", icon: "fa-vest-patches", slot: "chest", quality: "common", stats: { armor: 5 }, durability: 100, maxDurability: 100, sellPrice: 150 },
        3: { id: 3, name: "Spider Silk", icon: "fa-network-wired", slot: "material", quality: "common", stackable: true, sellPrice: 50 },
        4: { id: 4, name: "Wolf Fang", icon: "fa-tooth", slot: "material", quality: "common", stackable: true, sellPrice: 40 },
        5: { id: 5, name: "Minor Healing Potion", icon: "fa-flask-vial", slot: "consumable", quality: "common", stackable: true, onUse: (player) => player.heal(50), sellPrice: 25 },
        6: { id: 6, name: "Peacebloom", icon: "fa-leaf", slot: "material", quality: "common", stackable: true, sellPrice: 20 },
        7: { id: 7, name: "Copper Ore", icon: "fa-gem", slot: "material", quality: "common", stackable: true, color: "#b87333", sellPrice: 30 },
        8: { id: 8, name: "Rough Wooden Staff", icon: "fa-staff-snake", slot: "main-hand", quality: "common", weaponDamage: { min: 2, max: 4 }, stats: { intellect: 1 }, durability: 100, maxDurability: 100, sellPrice: 200 },
        9: { id: 9, name: "Thick Leather", icon: "fa-paw", slot: "material", quality: "common", stackable: true, sellPrice: 70 },
        10: { id: 10, name: "Sturdy Wooden Shield", icon: "fa-shield", slot: "off-hand", quality: "common", stats: { armor: 3, stamina: 1 }, durability: 100, maxDurability: 100, sellPrice: 250 },
        11: { id: 11, name: "Bear Flank", icon: "fa-drumstick-bite", slot: "material", quality: "common", stackable: true, sellPrice: 80},
        12: { id: 12, name: "Living Root", icon: "fa-seedling", slot: "material", quality: "magic", stackable: true, sellPrice: 120},
        13: { id: 13, name: "Silverleaf", icon: "fa-seedling", slot: "material", quality: "common", stackable: true, sellPrice: 50 },
        14: { id: 14, name: "Tin Ore", icon: "fa-gem", slot: "material", quality: "common", color: "#a9a9a9", stackable: true, sellPrice: 60 },
        15: { id: 15, name: "Oak Wood", icon: "fa-tree", slot: "material", quality: "common", stackable: true, sellPrice: 55 },
        16: { id: 16, name: "Reinforced Staff", icon: "fa-staff-snake", slot: "main-hand", quality: "magic", weaponDamage: { min: 5, max: 8 }, stats: { intellect: 3 }, durability: 100, maxDurability: 100, sellPrice: 450 },
        17: { id: 17, name: "Oak Shield", icon: "fa-shield", slot: "off-hand", quality: "magic", stats: { armor: 6, stamina: 2 }, durability: 100, maxDurability: 100, sellPrice: 500 },
        18: { id: 18, name: "Copper Bar", icon: "fa-cubes", slot: "material", quality: "common", stackable: true, sellPrice: 65 },
        19: { id: 19, name: "Copper Shortsword", icon: "fa-sword", slot: "main-hand", quality: "common", weaponDamage: { min: 4, max: 6 }, durability: 100, maxDurability: 100, sellPrice: 300 },
        20: { id: 20, name: "Weak Troll's Blood Potion", icon: "fa-flask-vial", slot: "consumable", quality: "common", stackable: true, onUse: (player) => { player.addBuff({ id: 'troll_regen', name: 'Weak Regeneration', icon: 'fa-heart-pulse', duration: 60000, tickRate: 2000, onTick: (p) => p.heal(5), isDebuff: false }); }, sellPrice: 100 },
        21: { id: 21, name: "Copper Mace", icon: "fa-gavel", slot: "main-hand", quality: "common", weaponDamage: { min: 5, max: 7 }, durability: 100, maxDurability: 100, sellPrice: 350 },
        // --- NEW ITEMS ---
        22: { id: 22, name: "Minor Mana Potion", icon: "fa-flask-vial", slot: "consumable", quality: "common", stackable: true, onUse: (player) => { if(player.stats.mana < player.stats.maxMana) player.stats.mana = Math.min(player.stats.maxMana, player.stats.mana + 50); }, sellPrice: 40 },
        23: { id: 23, name: "Reinforced Wooden Buckler", icon: "fa-shield-halved", slot: "off-hand", quality: "magic", stats: { armor: 5, agility: 2 }, durability: 100, maxDurability: 100, sellPrice: 550 },

        101: { id: 101, name: "Goblin-Forged Blade", icon: "fa-scythe", slot: "main-hand", quality: "rare", weaponDamage: { min: 8, max: 12 }, stats: { strength: 2 }, durability: 100, maxDurability: 100, sellPrice: 500 },
        102: { id: 102, name: "Enchanted Robes", icon: "fa-jedi", slot: "chest", quality: "magic", stats: { armor: 8, intellect: 3 }, durability: 100, maxDurability: 100, sellPrice: 400 },
    },
    ABILITIES: {
        1: { id: 1, name: "Slash", icon: "fa-burst", cost: 0, cooldown: 3000, range: 90, 
            description: "A swift attack that deals 120% of weapon damage plus a bonus from your Attack Power.",
            onUse: (caster, target) => { 
            ParticleSystem.create(target.x, target.y, 'red', 15, 0.1, 10); 
            const damage = (caster.getWeaponDamage() * 1.2) + (caster.stats.attackPower * 0.3); 
            target.takeDamage(damage, 'physical', caster); 
        }},
        2: { id: 2, name: "Fireball", icon: "fa-fire-flame-curved", cost: 30, cooldown: 5000, range: 200, onUse: (caster, target) => { 
            ParticleSystem.create(target.x, target.y, 'orange', 25, 0.2, 15); 
            const baseDamage = (caster.stats.intellect * 2) + 10; 
            const damage = baseDamage * (caster.talentBonuses.fireballDamageMultiplier || 1);
            target.takeDamage(damage, 'magic', caster); 
        }},
        3: { id: 3, name: "Rend", icon: "fa-heart-crack", cost: 15, cooldown: 6000, range: 90, onUse: (caster, target) => { target.addBuff({ id: 'rend_dot', name: 'Rend', icon: 'fa-heart-crack', duration: 9000, tickRate: 3000, onTick: (t) => { const damage = caster.getAttackDamage() * 0.2; t.takeDamage(damage, 'physical', caster, true); game.createFloatingText(Math.round(damage), t.x, t.y, '#ff4500'); }, isDebuff: true }); }},
    },
    ENEMY_TYPES: {
        'WOLF': { name: "Dire Wolf", icon: "\uf6f0", color: "#a9a9a9", size: 28, speed: 1.5, health: 80, attack: 5, aggroRadius: 150, attackRange: 40, attackSpeed: 2000, xp: 15, lootTable: [{itemId: 4, chance: 0.8, min: 1, max: 2}, {itemId: 9, chance: 0.5, min: 1, max: 1}, {gold: 50, chance: 1.0}], reputation: { faction: 'Wilderness', value: -10 } },
        'SPIDER': { name: "Forest Spider", icon: "\uf717", color: "#654321", size: 25, speed: 1.2, health: 60, attack: 4, aggroRadius: 120, attackRange: 35, attackSpeed: 1800, xp: 10, lootTable: [{itemId: 3, chance: 0.9, min: 1, max: 3}, {gold: 30, chance: 1.0}], reputation: { faction: 'Wilderness', value: -5 } },
        'GOBLIN': { name: "Goblin Thug", icon: "\uf7a0", color: "#2E8B57", size: 22, speed: 1.8, health: 120, attack: 8, aggroRadius: 180, attackRange: 45, attackSpeed: 2200, xp: 25, lootTable: [{itemId: 101, chance: 0.1}, {gold: 150, chance: 0.5}], reputation: { faction: 'Stormwind Guard', value: 5 } },
        'DARK_CASTER': { name: "Dark Caster", icon: "\uf718", color: "#8A2BE2", size: 24, speed: 1.4, health: 100, attack: 5, aggroRadius: 220, attackRange: 200, attackSpeed: 3000, xp: 30, lootTable: [{gold: 200, chance: 0.8}], onAttack: (caster, target) => { target.addBuff({id: 'curse_of_weakness', name: 'Curse of Weakness', icon: 'fa-skull', duration: 15000, isDebuff: true, stats: { attack: -5 }})}, reputation: { faction: 'Stormwind Guard', value: 10 } },
        'BEAR': { name: "Grizzled Bear", icon: "\uf704", color: "#d3a483", size: 35, speed: 1.1, health: 200, attack: 12, aggroRadius: 140, attackRange: 45, attackSpeed: 2500, xp: 35, lootTable: [{itemId: 11, chance: 0.9, min: 1, max: 2}, {gold: 100, chance: 1.0}], reputation: { faction: 'Wilderness', value: -20 } },
        'TREANT': { name: "Treant Sapling", icon: "\uf1bb", color: "#66827a", size: 30, speed: 1.3, health: 110, attack: 7, aggroRadius: 160, attackRange: 150, attackSpeed: 2800, xp: 28, lootTable: [{itemId: 12, chance: 0.6}, {gold: 80, chance: 1.0}], onAttack: (caster, target) => { if (Math.random() < 0.25) { target.addBuff({id: 'entangling_roots', name: 'Entangling Roots', icon: 'fa-vine', duration: 5000, isDebuff: true, onApply: (t) => t.isRooted = true, onExpire: (t) => t.isRooted = false }); } }, reputation: { faction: 'Wilderness', value: -15 } },
        'GOBLIN_STALKER': { name: "Goblin Stalker", icon: "\uf6d5", color: "#9acd32", size: 20, speed: 2.2, health: 90, attack: 10, aggroRadius: 170, attackRange: 40, attackSpeed: 1600, xp: 30, lootTable: [{gold: 180, chance: 0.9}], reputation: { faction: 'Stormwind Guard', value: 7 } },
    },
    NPC_TYPES: {
        'BLACKSMITH': { name: "Barton the Blacksmith", icon: '\uf0e7', color: '#a9a9a9', interactType: 'repair' },
        'SPIRIT_HEALER': { name: "Spirit Healer", icon: '\uf70e', color: '#a0c4ff', interactType: 'resurrect', interaction: (player) => {
            if (player.isGhost) {
                const doRes = confirm("Resurrect here? You will suffer Resurrection Sickness and your equipped items will lose durability.");
                if(doRes) {
                    player.resurrectAtHealer();
                }
            } else {
                alert("The spirits can only help the dead.");
            }
        }},
        'GENERAL_VENDOR': { name: "General Goods Vendor", icon: '\uf54e', color: '#c0c0c0', interactType: 'vendor', sells: [{itemId: 5, quantity: 5, price: 50}], buys: ['consumable', 'material'] },
        'WOODWORKING_TRAINER': { name: "Master Woodworker", icon: '\uf5bb', color: '#8b4513', interactType: 'crafting_trainer', profession: 'Woodworking' },
        // --- NEW NPCS ---
        'BLACKSMITHING_TRAINER': { name: "Thorin the Smith", icon: '\uf6e3', color: '#d2b48c', interactType: 'crafting_trainer', profession: 'Blacksmithing' },
        'ALCHEMIST': { name: "Alchemist Fiona", icon: '\uf70c', color: '#9932cc', interactType: 'crafting_trainer', profession: 'Alchemy' },
    },
        QUESTS: { 
        1: { id: 1, title: "A Tangled Web", description: "The forest path is overrun with spiders. Clear out 5 of them so travelers can pass safely.", objectives: [{ type: 'kill', target: 'SPIDER', count: 5 }], rewards: { xp: 100, gold: 1000, items: [{id: 2, quantity: 1}], reputation: { faction: 'Stormwind Guard', value: 50 } }, repeatable: false },
        2: { id: 2, title: "Wolf Hunting", description: "The local farmers are losing livestock to dire wolves. Hunt 3 dire wolves.", objectives: [{ type: 'kill', target: 'WOLF', count: 3 }], rewards: { xp: 80, gold: 800, items: [{id: 4, quantity: 1}], reputation: { faction: 'Stormwind Guard', value: 40 } }, repeatable: true, cooldown: 3600000 },
        3: { id: 3, title: "Bear Necessities", description: "Grizzled Bears have become a threat. Thin their numbers by slaying 3 of them.", objectives: [{ type: 'kill', target: 'BEAR', count: 3 }], rewards: { xp: 150, gold: 1500 }, repeatable: true, cooldown: 1800000 },
        101: { 
            id: 101, title: "Advanced Woodworking", 
            description: "You've shown promise, young artisan. To further your skills, craft 2 Rough Wooden Staves and 2 Sturdy Wooden Shields. Your dedication will be rewarded.",
            requirements: [{ type: 'profession', name: 'Woodworking', level: 10 }],
            objectives: [ { type: 'craft', itemId: 8, count: 2 }, { type: 'craft', itemId: 10, count: 2 } ],
            rewards: { xp: 200, gold: 2000, recipes: ['reinforced_staff', 'oak_shield'] },
            repeatable: false 
        },
        102: {
            id: 102, title: "The Art of the Forge",
            description: "You've proven adept at finding ore. Now, let's see if you can shape it. Smelt 10 Copper Bars and bring them to me. A true smith knows their materials.",
            requirements: [{ type: 'profession', name: 'Mining', level: 10 }],
            objectives: [ { type: 'gather', itemId: 18, count: 10 } ],
            rewards: { xp: 250, gold: 2500, recipes: ['copper_mace'] },
            repeatable: false
        },
        // --- NEW QUESTS ---
        103: {
            id: 103, title: "Budding Alchemist",
            description: "You have a feel for the flora of the woods. Bring me 10 Peacebloom so I can teach you how to unlock their latent power.",
            requirements: [{ type: 'profession', name: 'Herbalism', level: 10 }],
            objectives: [ { type: 'gather', itemId: 6, count: 10 } ],
            rewards: { xp: 200, gold: 1500, recipes: ['minor_mana_potion'] },
            repeatable: false
        },
        104: {
            id: 104, title: "A Sturdy Foundation",
            description: "A good shield starts with good wood. Your skill with an axe is growing. Bring me 15 Oak Wood, and I will show you a more advanced design.",
            requirements: [{ type: 'profession', name: 'Lumberjacking', level: 10 }],
            objectives: [ { type: 'gather', itemId: 15, count: 15 } ],
            rewards: { xp: 200, gold: 1500, recipes: ['reinforced_buckler'] },
            repeatable: false
        },
    },
    XP_TABLE: [0, 100, 250, 500, 1000, 2000, 4000, 8000, 12000, 18000],
    TALENTS: {
        'HUMAN_WARRIOR': [
            { id: 'str1', name: 'Toughness', maxRank: 5, icon: 'fa-hand-fist', description: 'Increases total Stamina by 2% per rank.', requires: null, apply: (p, r) => p.statBonuses.staminaBonus = (p.statBonuses.staminaBonus || 0) + 0.02 * r },
            { id: 'crit1', name: 'Cruelty', maxRank: 5, icon: 'fa-gavel', description: 'Increases critical strike chance by 1% per rank.', requires: null, apply: (p, r) => p.stats.critChance = (p.baseStats.critChance || 0) + (1 * r) },
        ],
        'ELF_MAGE': [
            { id: 'rend1', name: 'Improved Rend', maxRank: 3, icon: 'fa-heart-crack', description: 'Increases the damage of your Rend ability by 15% per rank.', requires: null, apply: (p, r) => p.talentBonuses.rendDamageMultiplier = (p.talentBonuses.rendDamageMultiplier || 1) + 0.15 * r},
            { id: 'ef1', name: 'Eternal Flame', maxRank: 3, icon: 'fa-fire-flame-curved', description: 'Increases the damage of your Fireball ability by 15% per rank.', requires: null, apply: (p, r) => p.talentBonuses.fireballDamageMultiplier = (p.talentBonuses.fireballDamageMultiplier || 1) + 0.15 * r},
        ]
    },
    FACTIONS: {
        'Stormwind Guard': { name: 'Stormwind Guard', tiers: ['Hated', 'Hostile', 'Unfriendly', 'Neutral', 'Friendly', 'Honored', 'Revered', 'Exalted'], base: 3000, values: [-42000, -6000, -3000, 0, 3000, 9000, 21000, 999999] },
        'Wilderness': { name: 'The Wilds', tiers: ['Ally', 'Neutral', 'Enemy'], base: 0, values: [0, 1000, -1000] },
    },
    RESOURCE_NODES: {
        'PEACEBLOOM': { name: 'Peacebloom', icon: '\uf06c', color: '#adff2f', size: 20, itemId: 6, respawnTime: 30000, requiredSkill: 'Herbalism' },
        'SILVERLEAF': { name: 'Silverleaf', icon: '\uf4d8', color: '#c0c0c0', size: 22, itemId: 13, respawnTime: 45000, requiredSkill: 'Herbalism' },
        'COPPER_VEIN': { name: 'Copper Vein', icon: '\uf3a5', color: '#b87333', size: 24, itemId: 7, respawnTime: 60000, requiredSkill: 'Mining' },
        'TIN_VEIN': { name: 'Tin Vein', icon: '\uf3a5', color: '#a9a9a9', size: 26, itemId: 14, respawnTime: 90000, requiredSkill: 'Mining' },
        'OAK_LOGS': { name: 'Oak Tree', icon: '\uf1bb', color: '#8b4513', size: 28, itemId: 15, respawnTime: 75000, requiredSkill: 'Lumberjacking' },
    },
        CRAFTING_RECIPES: {
        'wooden_staff': { id: 'wooden_staff', name: 'Rough Wooden Staff', icon: 'fa-staff-snake', itemId: 8, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 15, quantity: 5}], time: 3000 },
        'wooden_shield': { id: 'wooden_shield', name: 'Sturdy Wooden Shield', icon: 'fa-shield', itemId: 10, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 15, quantity: 3}, {itemId: 9, quantity: 2}], time: 4000 },
        'reinforced_staff': { id: 'reinforced_staff', name: 'Reinforced Staff', icon: 'fa-staff-snake', itemId: 16, profession: 'Woodworking', skillRequired: 10, materials: [{itemId: 15, quantity: 8}, {itemId: 7, quantity: 2}], time: 5000 },
        'oak_shield': { id: 'oak_shield', name: 'Oak Shield', icon: 'fa-shield', itemId: 17, profession: 'Woodworking', skillRequired: 10, materials: [{itemId: 15, quantity: 6}, {itemId: 9, quantity: 4}], time: 6000 },
        'copper_bar': { id: 'copper_bar', name: 'Copper Bar', icon: 'fa-cubes', itemId: 18, profession: 'Blacksmithing', skillRequired: 1, materials: [{itemId: 7, quantity: 2}], time: 2000 },
        'copper_shortsword': { id: 'copper_shortsword', name: 'Copper Shortsword', icon: 'fa-sword', itemId: 19, profession: 'Blacksmithing', skillRequired: 5, materials: [{itemId: 18, quantity: 5}], time: 5000 },
        'weak_trolls_blood': { id: 'weak_trolls_blood', name: "Weak Troll's Blood Potion", icon: 'fa-flask-vial', itemId: 20, profession: 'Alchemy', skillRequired: 1, materials: [{itemId: 6, quantity: 2}, {itemId: 13, quantity: 1}], time: 3000 },
        'copper_mace': { id: 'copper_mace', name: 'Copper Mace', icon: 'fa-gavel', itemId: 21, profession: 'Blacksmithing', skillRequired: 10, materials: [{itemId: 18, quantity: 7}], time: 6000 },
        // --- NEW RECIPES ---
        'minor_mana_potion': { id: 'minor_mana_potion', name: 'Minor Mana Potion', icon: 'fa-flask-vial', itemId: 22, profession: 'Alchemy', skillRequired: 10, materials: [{itemId: 6, quantity: 1}, {itemId: 12, quantity: 1}], time: 3000 },
        'reinforced_buckler': { id: 'reinforced_buckler', name: 'Reinforced Wooden Buckler', icon: 'fa-shield-halved', itemId: 23, profession: 'Woodworking', skillRequired: 10, materials: [{itemId: 15, quantity: 10}, {itemId: 18, quantity: 1}], time: 7000 },
    },
    PROFESSIONS: {
        'Herbalism': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        'Mining': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        'Woodworking': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 50 },
        'Lumberjacking': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        // --- NEW PROFESSIONS ---
        'Blacksmithing': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 50 },
        'Alchemy': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 50 },
    },
    REGIONS: [
        {
            id: 'starting_zone', name: 'Whispering Woods', x: 20000, y: 20000, width: 60000, height: 60000,
            isRestZone: true,
            bgColor: "#182c18",
            sceneryPatches: [
                { type: [1, 2, 3, 4], density: 250, patchCenter: {x: 50000, y: 50000}, patchRadius: 10000 }
            ],
            enemyPacks: [
                { type: 'SPIDER', count: 25, packCenter: {x: 45000, y: 45000}, packRadius: 2000 },
                { type: 'WOLF', count: 15, packCenter: {x: 55000, y: 55000}, packRadius: 1500 },
                { type: 'BEAR', count: 10, packCenter: {x: 48000, y: 58000}, packRadius: 2500 },
                { type: 'TREANT', count: 8, packCenter: {x: 60000, y: 45000}, packRadius: 1000 },
            ],
            resourcePatches: [
                { type: 'PEACEBLOOM', count: 80, patchCenter: {x: 52000, y: 51000}, patchRadius: 4000 },
                { type: 'SILVERLEAF', count: 40, patchCenter: {x: 46000, y: 46000}, patchRadius: 3000 },
                { type: 'COPPER_VEIN', count: 70, patchCenter: {x: 48000, y: 54000}, patchRadius: 3500 },
                { type: 'OAK_LOGS', count: 60, patchCenter: {x: 55000, y: 48000}, patchRadius: 4500 },
            ],
                        npcs: [
                { type: 'QuestGiver', name: "Old Man Willow", x: 50000, y: 49500, questIds: [1, 2, 3] },
                { type: 'GenericNPC', npcType: 'BLACKSMITH', x: 49000, y: 50500 },
                { type: 'GenericNPC', npcType: 'GENERAL_VENDOR', x: 51000, y: 50500 },
                { type: 'GenericNPC', npcType: 'SPIRIT_HEALER', x: 48500, y: 48000 },
                // --- MODIFIED: Added questId 104 ---
                { type: 'QuestGiver', name: "Master Woodworker", npcType: 'WOODWORKING_TRAINER', x: 49000, y: 49500, questIds: [101, 104] },
                { type: 'CraftingStation', stationType: 'WOODWORKING_BENCH', x: 49000, y: 49600 },
                { type: 'QuestGiver', name: "Thorin the Smith", npcType: 'BLACKSMITHING_TRAINER', x: 49100, y: 50500, questIds: [102] },
                { type: 'CraftingStation', stationType: 'FORGE', x: 49100, y: 50600 },
                // --- MODIFIED: Added questId 103 ---
                { type: 'QuestGiver', name: "Alchemist Fiona", npcType: 'ALCHEMIST', x: 51000, y: 49500, questIds: [103] },
                { type: 'CraftingStation', stationType: 'ALCHEMY_TABLE', x: 51000, y: 49600 },
            ]
        },
        {
            id: 'goblin_camp', name: 'Goblin Hideout', x: 80000, y: 10000, width: 15000, height: 30000,
            bgColor: "#3b302c",
            sceneryPatches: [
                { type: [1, 4], density: 50, patchCenter: {x: 87500, y: 25000}, patchRadius: 7500 }
            ],
            enemyPacks: [
                { type: 'GOBLIN', count: 15, packCenter: {x: 85000, y: 20000}, packRadius: 3000 },
                { type: 'DARK_CASTER', count: 5, packCenter: {x: 88000, y: 15000}, packRadius: 1000 },
                { type: 'GOBLIN_STALKER', count: 10, packCenter: {x: 83000, y: 25000}, packRadius: 2000 },
            ],
            resourcePatches: [ 
                { type: 'COPPER_VEIN', count: 40, patchCenter: {x: 82000, y: 18000}, patchRadius: 4000 },
                { type: 'TIN_VEIN', count: 50, patchCenter: {x: 87000, y: 23000}, patchRadius: 5000 },
                { type: 'SILVERLEAF', count: 30, patchCenter: {x: 84000, y: 14000}, patchRadius: 3000 },
                { type: 'OAK_LOGS', count: 40, patchCenter: {x: 81000, y: 26000}, patchRadius: 3500 },
            ],
        },
    ],
    // --- NEW CRAFTING STATIONS ---
    CRAFTING_STATIONS: {
        'WOODWORKING_BENCH': {
            name: 'Woodworking Bench', icon: '\uf6e2', color: '#8B4513',
            recipes: ['wooden_staff', 'wooden_shield', 'reinforced_staff', 'oak_shield']
        },
        'FORGE': {
            name: 'Forge', icon: '\uf6e3', color: '#d2691e',
            recipes: ['copper_bar', 'copper_shortsword']
        },
        'ALCHEMY_TABLE': {
            name: 'Alchemy Table', icon: '\uf70c', color: '#9932cc',
            recipes: ['weak_trolls_blood']
        }
    }
};

let game;

class Game {
    constructor(playerOptions) {
        this.canvas = $("#game-canvas"); this.ctx = this.canvas.getContext("2d");
        this.lastTime = 0; this.entities = []; this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        this.init(playerOptions);
    }
    init(playerOptions) {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        this.input = new InputHandler(this.isMobile);
        this.world = new World(this.ctx, WORLD_SIZE, WORLD_SIZE);
        ParticleSystem.init(this.ctx);
        
        if (playerOptions) { 
            this.player = new Player(RESPAWN_POINT.x, RESPAWN_POINT.y, this.input, playerOptions.name, playerOptions.race);
            this.player.autoSlotAbilities(); 
        } else { 
            this.player = new Player(RESPAWN_POINT.x, RESPAWN_POINT.y, this.input, 'Hero', 'Human'); 
        }

        this.ui = new UI(this);
        this.camera = new Camera(this.player, this.canvas.width, this.canvas.height);
        
        if (!playerOptions && !this.loadGame()) {
            console.error("Failed to load game, but no new character options were provided.");
            showMainMenu(); 
            return;
        } else if (playerOptions) {
            this.spawnEntities(); 
        }

        this.ui.updateAll(this.player);
        this.setupUIInteractions(); 
        this.initAtmosphere();
        setInterval(() => this.saveGame(true), 30000);
        this.gameLoop(0);
    }
    resizeCanvas() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; if(this.camera) { this.camera.width = this.canvas.width; this.camera.height = this.canvas.height; } }
    
    spawnEntities() {
        this.entities = [];

        GameData.REGIONS.forEach(regionData => {
            if (regionData.npcs) {
                regionData.npcs.forEach(npc => {
                    let npcEntity;
                    if (npc.type === 'QuestGiver') {
                        // --- MODIFIED: Pass npc.npcType to the constructor ---
                        npcEntity = new QuestGiver(npc.x, npc.y, npc.name, npc.questIds, npc.npcType);
                    } else if (npc.type === 'GenericNPC') {
                        npcEntity = new GenericNPC(npc.x, npc.y, GameData.NPC_TYPES[npc.npcType]);
                    } else if (npc.type === 'CraftingStation') {
                        npcEntity = new CraftingStation(npc.x, npc.y, GameData.CRAFTING_STATIONS[npc.stationType]);
                    }
                    if (npcEntity) this.entities.push(npcEntity);
                });
            }
            
            if (regionData.enemyPacks) {
                regionData.enemyPacks.forEach(pack => {
                    for (let i = 0; i < pack.count; i++) {
                        const x = pack.packCenter.x + (Math.random() - 0.5) * 2 * pack.packRadius;
                        const y = pack.packCenter.y + (Math.random() - 0.5) * 2 * pack.packRadius;
                        this.entities.push(new Enemy(x, y, GameData.ENEMY_TYPES[pack.type]));
                    }
                });
            }

            if (regionData.resourcePatches) {
                regionData.resourcePatches.forEach(patch => {
                    for (let i = 0; i < patch.count; i++) {
                        const x = patch.patchCenter.x + (Math.random() - 0.5) * 2 * patch.patchRadius;
                        const y = patch.patchCenter.y + (Math.random() - 0.5) * 2 * patch.patchRadius;
                        this.entities.push(new ResourceNode(x, y, GameData.RESOURCE_NODES[patch.type]));
                    }
                });
            }

            if (regionData.sceneryPatches) {
                regionData.sceneryPatches.forEach(patch => {
                    for (let i = 0; i < patch.density; i++) {
                        const x = patch.patchCenter.x + (Math.random() - 0.5) * 2 * patch.patchRadius;
                        const y = patch.patchCenter.y + (Math.random() - 0.5) * 2 * patch.patchRadius;
                        const randomSceneryId = patch.type[Math.floor(Math.random() * patch.type.length)];
                        const sceneryType = GameData.SCENERY[randomSceneryId];
                        if (sceneryType) {
                            this.entities.push(new Scenery(x, y, sceneryType));
                        }
                    }
                });
            }
        });
    }

    initAtmosphere() {
        setInterval(() => {
            if (game && game.camera) {
                const x = game.camera.x + Math.random() * game.camera.width;
                const y = game.camera.y + Math.random() * game.camera.height;
                ParticleSystem.create(x, y, 'rgba(255, 255, 255, 0.03)', 1, 8, 0.1, { vx: (Math.random() - 0.5) * 0.2, vy: (Math.random() - 0.5) * 0.2 });
            }
        }, 100);

        setInterval(() => {
            if (game && game.camera) {
                const x = game.camera.x + Math.random() * game.camera.width;
                const y = game.camera.y + Math.random() * game.camera.height;
                ParticleSystem.create(x, y, 'yellow', 10, 1.5, 3, { vx: (Math.random() - 0.5) * 4, vy: (Math.random() - 0.5) * 4 });
            }
        }, 4000 + Math.random() * 3000);
    }

    gameLoop(timestamp) { const deltaTime = timestamp - this.lastTime; this.lastTime = timestamp; this.update(deltaTime); this.draw(); requestAnimationFrame((ts) => this.gameLoop(ts)); }
    update(deltaTime) {
        if (!deltaTime) return;
        if (this.player.isRooted) this.input.joystickVector = {x: 0, y: 0};

        if (this.input.mouse.clicked && !this.player.isAutoQuesting && !this.player.isGhost) {
            let clickedOnSomething = false; const clickWorldPos = { x: this.input.mouse.x + this.camera.x, y: this.input.mouse.y + this.camera.y };
            const sortedEntities = [...this.entities].sort((a, b) => b.y - a.y); // Sort descending for click detection
            for (const entity of sortedEntities) {
                if (entity !== this.player && distance(clickWorldPos, entity) < entity.size / 2) {
                    if (entity.isInteractable && distance(this.player, entity) < 100) { entity.interact(this.player); this.player.setTarget(entity); } else if (entity instanceof Enemy) { this.player.setTarget(entity); }
                    clickedOnSomething = true; break;
                }
            }
            if (!clickedOnSomething) this.player.setTarget(null);
            this.input.mouse.clicked = false;
        }
        
        this.player.update(deltaTime, this.world, this.entities);
        this.entities.forEach(entity => entity.update(deltaTime, this.world, this.entities, this.player));

        const deadNPCs = this.entities.filter(e => e.isDead && e !== this.player && !(e instanceof PlayerCorpse));
        if(deadNPCs.length > 0) {
            deadNPCs.forEach(dead => { if (dead === this.player.target) this.player.setTarget(null); });
            this.entities = this.entities.filter(e => !deadNPCs.includes(e));
        }
        this.camera.update(); ParticleSystem.update(deltaTime); this.ui.update(this.player, deltaTime);
        this.world.updateAmbiance(deltaTime);
    }
    
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.world.draw(this.camera, this.player.isGhost);

        const objectsToDraw = [...this.entities, this.player];
        objectsToDraw.sort((a, b) => a.y - b.y);

        objectsToDraw.forEach(obj => {
            obj.draw(this.ctx, this.camera, this.player);
        });

        ParticleSystem.draw(this.camera);
    }

    createFloatingText(text, x, y, color, type = '') { this.ui.createFloatingText(text, x, y, color, this.camera, type); }
        setupUIInteractions() {
        if (this.isMobile) $("#mobile-controls").style.display = "block";
        $$('.sys-button').forEach(btn => btn.addEventListener('click', () => { const windowId = btn.dataset.window; if (windowId) { const win = $(`#${windowId}`); win.style.display = win.style.display === 'flex' ? 'none' : 'flex'; this.ui.updateAll(this.player); } }));
        $('#save-button').addEventListener('click', () => { this.saveGame(); this.createFloatingText("Game Saved!", this.player.x, this.player.y, 'gold'); });
        $$('.close-btn').forEach(btn => btn.addEventListener('click', (e) => { e.target.closest('.window').style.display = 'none'; this.ui.tooltip.style.display = 'none'; }));
        $$('.window').forEach(win => this.ui.makeDraggable(win));
        window.addEventListener('keydown', (e) => { if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; const keyMap = {c: '#character-window', i: '#inventory-window', l: '#quest-log-window', n: '#talent-window', p: '#spellbook-window', u: '#reputation-window', m: '#map-window'}; if(keyMap[e.key.toLowerCase()]){ const win = $(keyMap[e.key.toLowerCase()]); win.style.display = win.style.display === 'flex' ? 'none' : 'flex'; this.ui.updateAll(this.player); } });
        $('#release-spirit-button').addEventListener('click', () => this.player.releaseSpirit());
        window.addEventListener('mouseleave', () => { this.ui.tooltip.style.display = 'none'; });

        // --- NEW: HIDE TOOLTIP ON ANY CLICK ---
        window.addEventListener('mousedown', () => {
            if (this.ui && this.ui.tooltip) {
                this.ui.tooltip.style.display = 'none';
            }
        });
    }

    saveGame(isAutoSave = false) {
        if (!this.player || this.player.isDead || this.player.isGhost) return;
        const saveData = {
            player: {
                x: this.player.x, y: this.player.y,
                name: this.player.name, race: this.player.race,
                level: this.player.level, xp: this.player.xp,
                restedXp: this.player.restedXp, gold: this.player.gold,
                baseStats: { ...this.player.baseStats },
                stats: { health: this.player.stats.health, mana: this.player.stats.mana },
                inventory: this.player.inventory.map(item => item ? { id: item.id, quantity: item.quantity, durability: item.durability } : null),
                equipment: Object.entries(this.player.equipment).reduce((acc, [slot, item]) => { acc[slot] = item ? { id: item.id, durability: item.durability } : null; return acc; }, {}),
                hotbar: this.player.hotbar.map(slot => { if (!slot) return null; if (slot.type === 'ability') { return { type: 'ability', id: slot.ref.id }; } if (slot.type === 'item') { const invIndex = this.player.inventory.indexOf(slot.ref); return invIndex > -1 ? { type: 'item', invIndex: invIndex } : null; } return null; }),
                quests: this.player.quests.map(q => ({ id: q.id, progress: q.progress.map(p => p.current) })),
                recipes: this.player.recipes.map(r => r.id),
                spellbook: this.player.spellbook.map(a => a.id),
                talents: { ...this.player.talents },
                talentPoints: this.player.talentPoints,
                reputation: { ...this.player.reputation },
                professions: { ...this.player.professions },
                questCooldowns: Object.entries(this.player.questCooldowns).reduce((acc, [id, timeLeft]) => { acc[id] = Date.now() + timeLeft; return acc; }, {}),
            }
        };
        localStorage.setItem('miniWowSaveData', JSON.stringify(saveData));
        if (!isAutoSave) this.createFloatingText("Game Saved!", this.player.x, this.player.y, 'gold');
    }

    loadGame() {
        const savedJSON = localStorage.getItem('miniWowSaveData');
        if (!savedJSON) { console.log("No save data found."); return false; }
        try {
            const saveData = JSON.parse(savedJSON); const pData = saveData.player;
            this.spawnEntities();
            
            this.player.name = pData.name; this.player.race = pData.race; this.player.x = pData.x; this.player.y = pData.y; this.player.level = pData.level; this.player.xp = pData.xp; this.player.restedXp = pData.restedXp; this.player.gold = pData.gold; this.player.baseStats = { ...pData.baseStats }; this.player.talents = { ...pData.talents }; this.player.talentPoints = pData.talentPoints; this.player.reputation = { ...pData.reputation }; this.player.professions = { ...pData.professions }; this.player.nextLevelXp = GameData.XP_TABLE[this.player.level] || 99999;
            this.player.inventory = pData.inventory.map(itemData => { if (!itemData) return null; const baseItem = { ...GameData.ITEMS[itemData.id] }; baseItem.quantity = itemData.quantity; if (itemData.durability !== undefined) baseItem.durability = itemData.durability; return baseItem; });
            this.player.equipment = {}; for (const slot in pData.equipment) { const itemData = pData.equipment[slot]; this.player.equipment[slot] = itemData ? { ...GameData.ITEMS[itemData.id], durability: itemData.durability } : null; }
            this.player.quests = []; pData.quests.forEach(qData => { const questTemplate = GameData.QUESTS[qData.id]; const questGiver = this.entities.find(e => e instanceof QuestGiver && e.questIds.includes(qData.id)); if (questTemplate && questGiver) { this.player.quests.push({ ...questTemplate, progress: questTemplate.objectives.map((o, i) => ({ ...o, current: qData.progress[i] || 0 })), giver: questGiver }); } }); if (pData.spellbook) {
                this.player.spellbook = pData.spellbook.map(id => GameData.ABILITIES[id]);
            }
            
            this.player.recipes = pData.recipes.map(id => GameData.CRAFTING_RECIPES[id]);
            this.player.hotbar = pData.hotbar.map(slotData => { if (!slotData) return null; if (slotData.type === 'ability') { return { type: 'ability', ref: GameData.ABILITIES[slotData.id] }; } if (slotData.type === 'item' && slotData.invIndex !== undefined) { const item = this.player.inventory[slotData.invIndex]; return item ? { type: 'item', ref: item } : null; } return null; });
            this.player.questCooldowns = {}; for(const id in pData.questCooldowns) { const endTime = pData.questCooldowns[id]; const timeLeft = endTime - Date.now(); if (timeLeft > 0) this.player.questCooldowns[id] = timeLeft; }
            
            this.player.recalculateStats();
            this.player.stats.health = pData.stats.health;
            this.player.stats.mana = pData.stats.mana;
            this.ui.setupActionbar(this.player);
            console.log("Game loaded successfully!"); return true;
        } catch (e) { console.error("Failed to load save data. It might be corrupted.", e); localStorage.removeItem('miniWowSaveData'); return false; }
    }
}

class World {
    constructor(ctx, width, height) { this.ctx = ctx; this.width = width; this.height = height; this.bgColor = "#182c18"; this.regions = GameData.REGIONS; this.sparkles = []; this.generateAmbiance(); }
    generateAmbiance() { for (let i = 0; i < 500; i++) { this.sparkles.push({ x: Math.random() * this.width, y: Math.random() * this.height, size: Math.random() * 1.5 + 0.5, opacity: Math.random() * 0.5, opacityDir: 1 }); } }
    updateAmbiance(deltaTime) { this.sparkles.forEach(s => { s.opacity += 0.05 * s.opacityDir * (deltaTime / 16.67); if (s.opacity > 1 || s.opacity < 0) { s.opacityDir *= -1; s.opacity = Math.max(0, Math.min(1, s.opacity)); } }); }
    draw(camera, isGhost = false) {
        this.ctx.save();
        if (isGhost) { this.ctx.filter = 'grayscale(1) brightness(0.7) sepia(1) hue-rotate(180deg)'; }
        
        const currentRegion = this.regions.find(r => 
            camera.target.x >= r.x && camera.target.x < r.x + r.width &&
            camera.target.y >= r.y && camera.target.y < r.y + r.height
        ) || { bgColor: this.bgColor };

        this.ctx.fillStyle = currentRegion.bgColor;
        this.ctx.fillRect(0, 0, camera.width, camera.height);
        
        this.ctx.restore();
    }
}
class Camera {
    constructor(target, width, height) { this.target = target; this.width = width; this.height = height; this.x = 0; this.y = 0; }
    update() { if(!this.target || (this.target.isDead && !this.target.isGhost)) return; this.x = this.target.x - this.width / 2; this.y = this.target.y - this.height / 2; this.x = Math.max(0, Math.min(this.x, game.world.width - this.width)); this.y = Math.max(0, Math.min(this.y, game.world.height - this.height)); }
}
class Entity {
    constructor(x, y, size, color, icon) {
        this.x = x; this.y = y; this.size = size; this.color = color; this.icon = icon; this.isDead = false;
    }

    draw(ctx, camera, player) {
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;

        if (drawX + this.size < 0 || drawX - this.size > camera.width || drawY + this.size < 0 || drawY - this.size > camera.height) {
            return;
        }

        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath();
        ctx.ellipse(drawX, drawY + this.size / 2, this.size / 2, this.size / 4, 0, 0, 2 * Math.PI);
        ctx.fill();

        ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`;
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icon, drawX, drawY);
    }
    
    update(deltaTime, world, entities) {}
}
class Character extends Entity {
    constructor(x, y, size, color, icon, name) {
        super(x, y, size, color, icon);
        this.name = name;
        this.level = 1;
        this.baseStats = { strength: 5, agility: 5, stamina: 5, intellect: 5, spirit: 5, attackPower: 0, critChance: 0, dodgeChance: 0, armor: 0 };
        this.stats = { ...this.baseStats };
        this.target = null;
        this.buffs = [];
        this.threatTable = new Map();
        this.isRooted = false;
    }
    recalculateStats() {
        this.buffs.forEach(buff => {
            if (buff.stats) {
                for (const stat in buff.stats) {
                    this.statBonuses[stat] = (this.statBonuses[stat] || 0) + buff.stats[stat];
                }
            }
        });
    }
    update(deltaTime) {
        this.buffs.forEach(buff => {
            buff.duration -= deltaTime;
            if (buff.onTick) { buff.tickTimer = (buff.tickTimer || 0) + deltaTime; if (buff.tickTimer >= buff.tickRate) { buff.onTick(this); buff.tickTimer = 0; } }
        });
        const expiredBuffs = this.buffs.filter(b => b.duration <= 0);
        if (expiredBuffs.length > 0) {
            expiredBuffs.forEach(buff => { if(buff.onExpire) buff.onExpire(this); });
            this.buffs = this.buffs.filter(b => b.duration > 0);
            this.recalculateStats();
        }
    }
    addBuff(buff) {
        const existing = this.buffs.find(b => b.id === buff.id);
        if (existing) { existing.duration = buff.duration; return; }
        if (buff.onApply) buff.onApply(this);
        this.buffs.push({ ...buff, tickTimer: 0 });
        if (buff.stats) this.recalculateStats();
    }
    takeDamage(amount, type, source, isDot = false) {
        if (this.isDead) return;
        if (type === 'physical' && !isDot && Math.random() < this.stats.dodgeChance) { game.createFloatingText('Dodge', this.x, this.y, '#fff', 'miss'); return; }
        let isCrit = false;
        if (!isDot && source && source.stats.critChance && Math.random() < source.stats.critChance) { amount *= 2; isCrit = true; }
        let finalAmount = amount; if(type === 'physical') { const mitigation = 1 - (this.stats.armor / (this.stats.armor + 400 + 85 * this.level)); finalAmount = Math.max(1, amount * mitigation); }
        finalAmount = Math.round(finalAmount); this.stats.health = Math.max(0, this.stats.health - finalAmount);
        if (this instanceof Player) { game.ui.updatePlayerFrame(this); this.fiveSecondRuleTimer = 500; }
        if(source) { const currentThreat = this.threatTable.get(source) || 0; this.threatTable.set(source, currentThreat + finalAmount * (isCrit ? 1.5 : 1)); }
        const color = type === 'physical' ? '#fff' : '#87ceeb'; game.createFloatingText(finalAmount, this.x, this.y, color, isCrit ? 'crit' : '');
        if (this.stats.health <= 0) this.die(source);
    }
    heal(amount, source) {
        this.stats.health = Math.min(this.stats.maxHealth, this.stats.health + amount);
        if (this instanceof Player) { game.ui.updatePlayerFrame(this); }
        if(source && this.inCombatTimer > 0) { const healerThreat = this.threatTable.get(source) || 0; this.threatTable.set(source, healerThreat + amount * 0.5); }
        game.createFloatingText(amount, this.x, this.y, 'lightgreen');
    }
    die(killer) { if (this.isDead) return; this.isDead = true; ParticleSystem.create(this.x, this.y, '#777', 30, 0.5); }
    setTarget(entity) { if (this.target) this.target.isTargeted = false; this.target = entity; if (this.target) this.target.isTargeted = true; }
    getAttackDamage() { return this.stats.attackPower; }

    draw(ctx, camera, player) {
        super.draw(ctx, camera, player);
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;

        if (!this.isDead) {
            const barWidth = this.size * 1.5;
            const barHeight = 4;
            const barYpos = drawY + this.size / 2 + 5;

            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(drawX - barWidth / 2, barYpos, barWidth, barHeight);

            const healthPercent = this.stats.health / this.stats.maxHealth;
            const healthBarColor = (this === player) ? '#28a745' : '#dc3545';
            ctx.fillStyle = healthBarColor;
            
            if (healthPercent > 0) {
                ctx.fillRect(drawX - barWidth / 2, barYpos, barWidth * healthPercent, barHeight);
            }
        }
        
        if(this.isTargeted) {
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(drawX, drawY + this.size/2, this.size/1.5, this.size/3, 0, 0, 2*Math.PI);
            ctx.stroke();
        }
    }
}

class Player extends Character {
    constructor(x, y, input, name, race) {
        super(x, y, 30, '#ddd', '\uf007', name || 'Hero');
        this.race = race || 'Human';
        this.input = input; this.speed = 3.5; this.xp = 0; this.restedXp = 0;
        this.nextLevelXp = GameData.XP_TABLE[this.level]; this.gold = 5000;
        this.inventory = new Array(16).fill(null);
        this.equipment = { 'main-hand': null, 'off-hand': null, 'chest': null };
        this.baseStats = { ...this.baseStats }; this.statBonuses = {}; this.talentBonuses = {};
        this.talents = {}; this.talentPoints = 0;
        this.reputation = {}; Object.keys(GameData.FACTIONS).forEach(id => this.reputation[id] = GameData.FACTIONS[id].base);
        this.professions = { Herbalism: { level: 0, xp: 0 }, Mining: { level: 0, xp: 0 }, Woodworking: { level: 0, xp: 0 }, Lumberjacking: { level: 0, xp: 0 }, Blacksmithing: { level: 0, xp: 0 }, Alchemy: { level: 0, xp: 0 } };
        this.recipes = [];
        this.hotbar = new Array(10).fill(null);
        this.spellbook = [];
        
        this.addAbilityToSpellbook(1);
        if (this.race === 'Elf') {
            this.addAbilityToSpellbook(2);
            this.addAbilityToSpellbook(3);
        }
        
        this.cooldowns = {}; this.quests = []; this.autoAttackTimer = 0; this.attackSpeed = 2000;
        this.inCombatTimer = 0; this.fiveSecondRuleTimer = 0;
        this.isGhost = false; this.corpse = null; this.isResting = false;
        this.isAutoQuesting = false; this.autoQuest = null; this.autoMoveTarget = null;
        this.questCooldowns = {};

        this.addItem(1, 1); this.addItem(5, 3);
        this.recalculateStats();
        this.stats.health = this.stats.maxHealth;
        this.stats.mana = this.stats.maxMana;
    }
    autoSlotAbilities() {
        let nextSlot = 1; 
        this.spellbook.forEach(ability => {
            if (nextSlot < this.hotbar.length) {
                const alreadySlotted = this.hotbar.some(slot => slot && slot.type === 'ability' && slot.ref.id === ability.id);
                if (!alreadySlotted) {
                    this.hotbar[nextSlot] = { type: 'ability', ref: ability };
                    nextSlot++;
                }
            }
        });
    }
    update(deltaTime) {
        super.update(deltaTime); 
        if (this.isDead && !this.isGhost) return;

        for (const id in this.cooldowns) { this.cooldowns[id] -= deltaTime; if (this.cooldowns[id] <= 0) delete this.cooldowns[id]; }
        for (const id in this.questCooldowns) { this.questCooldowns[id] -= deltaTime; if (this.questCooldowns[id] <= 0) delete this.questCooldowns[id]; }
        if (this.inCombatTimer > 0) { this.inCombatTimer -= deltaTime; if(this.inCombatTimer <= 0) this.inCombatTimer = 0; }
        this.fiveSecondRuleTimer -= deltaTime;
        this.autoAttackTimer += deltaTime;

        this.updateAutoQuest(); 

        let moveVector = { x: 0, y: 0 };
        if (!this.isRooted) {
            if (this.isAutoQuesting && this.autoMoveTarget) {
                const angle = Math.atan2(this.autoMoveTarget.y - this.y, this.autoMoveTarget.x - this.x);
                if (distance(this, this.autoMoveTarget) > 5) {
                    moveVector.x = Math.cos(angle);
                    moveVector.y = Math.sin(angle);
                } else {
                    this.autoMoveTarget = null; 
                }
            } else if (!this.isAutoQuesting) {
                moveVector = this.input.getMoveVector();
            }
        }
        const isMoving = moveVector.x !== 0 || moveVector.y !== 0;

        if (isMoving) {
            let finalX = moveVector.x;
            let finalY = moveVector.y;
            if (finalX !== 0 && finalY !== 0) { 
                finalX *= 0.7071;
                finalY *= 0.7071;
            }
            const currentSpeed = this.speed * (this.isGhost ? 1.5 : 1) * (deltaTime / 16.67);
            this.x += finalX * currentSpeed;
            this.y += finalY * currentSpeed;
            this.x = Math.max(this.size/2, Math.min(this.x, game.world.width - this.size/2));
            this.y = Math.max(this.size/2, Math.min(this.y, game.world.height - this.size/2));
        }

        if (this.isGhost) {
            if (this.corpse && distance(this, this.corpse) < this.size) this.resurrectAtCorpse();
        } else {
            if (!this.isAutoQuesting) {
                for(let i = 0; i < 10; i++) {
                    if (this.input.keys[`${(i + 1) % 10}`]) {
                        this.useHotbarSlot(i);
                        this.input.keys[`${(i + 1) % 10}`] = false;
                    }
                }
            }
            if(this.target && this.target instanceof Enemy && !this.target.isDead && distance(this, this.target) <= 40) {
                if (this.autoAttackTimer >= this.attackSpeed) {
                    this.autoAttack();
                    this.autoAttackTimer = 0;
                }
            }
        }

        const inCombat = this.inCombatTimer > 0;
        
        const currentRegion = game.world.regions.find(r =>
            this.x >= r.x && this.x < r.x + r.width &&
            this.y >= r.y && this.y < r.y + r.height
        );
        
        this.isResting = currentRegion ? currentRegion.isRestZone : false;
        
        if (this.race === 'Elf') {
            if (!inCombat && this.stats.health < this.stats.maxHealth) {
                this.stats.health = Math.min(this.stats.maxHealth, this.stats.health + this.stats.spirit * 0.5 * (deltaTime / 1000));
            }
            if ((!inCombat || this.fiveSecondRuleTimer <= 0) && this.stats.mana < this.stats.maxMana) {
                this.stats.mana = Math.min(this.stats.maxMana, this.stats.mana + this.stats.spirit * 0.8 * (deltaTime / 1000));
            }
        }
        
        if (this.isResting && !inCombat && !isMoving) {
            this.restedXp += 0.5 * (deltaTime / 1000);
            this.restedXp = Math.min(this.restedXp, this.nextLevelXp * 1.5);
        }
    }
    toggleAutoQuest(quest) { if (!quest) return; if (this.isAutoQuesting && this.autoQuest && this.autoQuest.id === quest.id) { this.isAutoQuesting = false; this.autoQuest = null; this.autoMoveTarget = null; this.setTarget(null); } else { if(this.isAutoQuesting) this.toggleAutoQuest(this.autoQuest); this.isAutoQuesting = true; this.autoQuest = quest; this.autoMoveTarget = null; } game.ui.updateQuestLog(this); }
    getBestAbilityRange() { let maxRange = 40; this.hotbar.forEach(slot => { if (slot && slot.type === 'ability' && slot.ref.range > maxRange) { maxRange = slot.ref.range; } }); return maxRange * 0.9; }
    updateAutoQuest() {
        if (!this.isAutoQuesting || !this.autoQuest || this.isGhost) return;
        const isQuestComplete = this.autoQuest.progress.every(p => p.current >= p.count);
        if (isQuestComplete) { const giver = this.autoQuest.giver; if (giver) { this.autoMoveTarget = giver; if (distance(this, giver) < 100) { this.autoMoveTarget = null; giver.interact(this, true); } } } else {
            const objective = this.autoQuest.progress.find(p => p.current < p.count); if (!objective) { this.toggleAutoQuest(this.autoQuest); return; }
            if (objective.type === 'kill') {
                const targetMobType = objective.target; const currentTargetIsValid = this.target && this.target instanceof Enemy && !this.target.isDead && this.target.type.name.split(' ')[1].toUpperCase() === targetMobType; if (this.target && this.target.isDead) this.setTarget(null);
                if (this.target && currentTargetIsValid) { const bestRange = this.getBestAbilityRange(); this.autoMoveTarget = this.target; if (distance(this, this.target) <= bestRange) { this.autoMoveTarget = null; for (let i = 0; i < this.hotbar.length; i++) { const slotItem = this.hotbar[i]; if (slotItem && slotItem.type === 'ability') { const ability = slotItem.ref; if (!this.cooldowns[ability.id] && this.stats.mana >= ability.cost && distance(this, this.target) <= ability.range) { this.useHotbarSlot(i); break; } } } } } else {
                    this.autoMoveTarget = null; let closestMob = null; let minDistance = Infinity; for (const entity of game.entities) { if (entity instanceof Enemy && !entity.isDead && entity.type.name.split(' ')[1].toUpperCase() === targetMobType) { const d = distance(this, entity); if (d < minDistance) { minDistance = d; closestMob = entity; } } } if (closestMob) { this.setTarget(closestMob); this.autoMoveTarget = closestMob; } else { if (!this.autoMoveTarget) { this.autoMoveTarget = { x: this.x + (Math.random() * 800 - 400), y: this.y + (Math.random() * 800 - 400) }; } }
                }
            } else if (objective.type === 'gather') {
                const targetResourceNode = objective.target; const currentTargetIsValid = this.target && this.target instanceof ResourceNode && !this.target.depleted && this.target.type.name.toUpperCase() === targetResourceNode; if (this.target && this.target.depleted) this.setTarget(null);
                if (this.target && currentTargetIsValid) { this.autoMoveTarget = this.target; if (distance(this, this.target) < 100) { this.autoMoveTarget = null; this.target.interact(this); this.setTarget(null); } } else {
                    this.autoMoveTarget = null; let closestNode = null; let minDistance = Infinity; for (const entity of game.entities) { if (entity instanceof ResourceNode && !entity.depleted && entity.type.name.toUpperCase() === targetResourceNode) { const d = distance(this, entity); if (d < minDistance) { minDistance = d; closestNode = entity; } } } if (closestNode) { this.setTarget(closestNode); this.autoMoveTarget = closestNode; } else { if (!this.autoMoveTarget) { this.autoMoveTarget = { x: this.x + (Math.random() * 800 - 400), y: this.y + (Math.random() * 800 - 400) }; } }
                }
            }
        }
    }
    takeDamage(amount, type, source) { super.takeDamage(amount, type, source); if (!this.isDead) { this.inCombatTimer = 8000; this.fiveSecondRuleTimer = 500; } }
    die(killer) { if (this.isDead) return; super.die(killer); if (this.isAutoQuesting) { this.toggleAutoQuest(this.autoQuest); } game.ui.showDeathScreen(); Object.values(this.equipment).forEach(item => { if (item) item.durability = Math.max(0, item.durability - 10); }); this.corpse = new PlayerCorpse(this.x, this.y); game.entities.push(this.corpse); }
    releaseSpirit() { if (!this.isDead || this.isGhost) return; this.isGhost = true; this.x = GRAVEYARD_POINT.x; this.y = GRAVEYARD_POINT.y; this.setTarget(null); game.ui.hideDeathScreen(); }
    resurrectAtCorpse() {
        this.isDead = false;
        this.isGhost = false;
        this.recalculateStats(); 
        this.stats.health = this.stats.maxHealth * 0.5;
        this.stats.mana = this.stats.maxMana * 0.5;
        this.x = this.corpse.x;
        this.y = this.corpse.y;
        this.corpse.isDead = true;
        game.entities = game.entities.filter(e => e !== this.corpse);
        this.corpse = null;
        game.ui.updateAll(this);
    }
    resurrectAtHealer() { this.isDead = false; this.isGhost = false; this.x = this.x; this.y = this.y; this.addBuff({ id: 'res_sickness', name: 'Resurrection Sickness', icon: 'fa-skull', duration: 60000, isDebuff: true, stats: { strength: -10, agility: -10, stamina: -10, intellect: -10, spirit: -10 } }); Object.values(this.equipment).forEach(item => { if (item) item.durability = Math.max(0, item.durability - 15); }); this.recalculateStats(); this.stats.health = this.stats.maxHealth * 0.25; this.stats.mana = this.stats.maxMana * 0.25; game.ui.updateAll(this); }
    getWeaponDamage() {
        const weapon = this.equipment['main-hand'];
        if (weapon && weapon.weaponDamage) {
            const { min, max } = weapon.weaponDamage;
            // Calculate a random damage value within the weapon's range
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        // Return base unarmed damage if no weapon is equipped
        return Math.floor(Math.random() * 2) + 1; // 1-2 damage
    }
    autoAttack() { 
        if (!this.target) return; 
        ParticleSystem.create(this.target.x, this.target.y, 'white', 10, 0.1, 8); 
        // Use the new weapon damage for auto-attacks
        this.target.takeDamage(this.getWeaponDamage(), 'physical', this); 
        this.inCombatTimer = 8000; 
    }
    useHotbarSlot(index) { const slotItem = this.hotbar[index]; if (!slotItem || this.isGhost || this.isRooted) return; if(slotItem.type === 'ability') { const ability = slotItem.ref; if (this.cooldowns[ability.id] || !this.target || this.target.isDead) return; if(distance(this, this.target) > ability.range) { if(!this.isAutoQuesting) game.createFloatingText("Out of range", this.x, this.y, "yellow"); return; } if (this.stats.mana < ability.cost) { if(!this.isAutoQuesting) game.createFloatingText("Not enough mana", this.x, this.y, "blue"); return; } this.stats.mana -= ability.cost; ability.onUse(this, this.target); this.cooldowns[ability.id] = ability.cooldown; this.inCombatTimer = 8000; if(ability.cost > 0) this.fiveSecondRuleTimer = 500; game.ui.updatePlayerFrame(this); } else if (slotItem.type === 'item') { const item = slotItem.ref; if (item.slot === 'consumable' && item.onUse) { item.onUse(this); item.quantity--; if(item.quantity <= 0) { const invIndex = this.inventory.findIndex(i => i === item); if (invIndex > -1) this.inventory[invIndex] = null; this.hotbar[index] = null; } game.ui.updateInventory(this); game.ui.setupActionbar(this); } } }
    setHotbarSlot(hotbarIndex, source, sourceIdentifier) { let sourceItem = null; let type = ''; if (source === 'inventory') { const idx = parseInt(sourceIdentifier); if (!isNaN(idx) && this.inventory[idx]) { sourceItem = this.inventory[idx]; type = 'item'; } } else if (source === 'spellbook') { const idx = parseInt(sourceIdentifier); if (!isNaN(idx) && this.spellbook[idx]) { sourceItem = this.spellbook[idx]; type = 'ability'; } } if (sourceItem) { this.hotbar[hotbarIndex] = { type, ref: sourceItem }; } else { this.hotbar[hotbarIndex] = null; } game.ui.setupActionbar(this); }
    addXp(amount) { let bonusXp = 0; if (this.restedXp > 0) { bonusXp = Math.min(this.restedXp, amount); this.restedXp -= bonusXp; } const totalXp = amount + bonusXp; this.xp += totalXp; game.createFloatingText(`${amount} XP` + (bonusXp > 0 ? ` (+${bonusXp})` : ''), this.x, this.y - 20, bonusXp > 0 ? '#00bfff' : '#b636d1'); while(this.xp >= this.nextLevelXp && this.level < GameData.XP_TABLE.length -1) this.levelUp(); game.ui.updateXPBar(this); }
    levelUp() {
        this.xp -= this.nextLevelXp;
        this.level++;
        this.talentPoints++;
        this.nextLevelXp = GameData.XP_TABLE[this.level] || 99999;
        
        this.baseStats.strength += 2;
        this.baseStats.agility += 1;
        this.baseStats.stamina += 2;
        this.baseStats.intellect += 1;
        this.baseStats.spirit += 1;

        this.recalculateStats();

        this.stats.health = this.stats.maxHealth;
        this.stats.mana = this.stats.maxMana;
        
        game.createFloatingText('LEVEL UP!', this.x, this.y, 'gold', 'crit');
        ParticleSystem.create(this.x, this.y, 'gold', 50, 1.5, 30);
        
        game.ui.updateAll(this);
    }
    recalculateStats() {
        const newStats = { ...this.baseStats };
        this.statBonuses = {};

        Object.values(this.equipment).forEach(item => {
            if (item && item.stats) {
                for (const stat in item.stats) {
                    this.statBonuses[stat] = (this.statBonuses[stat] || 0) + item.stats[stat];
                }
            }
        });

        super.recalculateStats();

        for (const stat in this.statBonuses) {
            newStats[stat] = (newStats[stat] || 0) + this.statBonuses[stat];
        }

        // --- NEW: Calculate bonus damage from weapon ---
        let weaponDmgBonus = 0;
        const weapon = this.equipment['main-hand'];
        if (weapon && weapon.weaponDamage) {
            // Add the average weapon damage to Attack Power
            weaponDmgBonus = (weapon.weaponDamage.min + weapon.weaponDamage.max) / 2;
        }

        newStats.maxHealth = (newStats.stamina || 0) * 10;
        newStats.maxMana = (newStats.intellect || 0) * 10;
        // --- MODIFIED: Include weapon damage in Attack Power calculation ---
        newStats.attackPower = 5 + ((newStats.strength || 0) * 0.5) + weaponDmgBonus + (this.statBonuses.attackPower || 0);
        newStats.critChance = 0.05 + ((newStats.agility || 0) * 0.0025) + (this.statBonuses.critChance || 0);
        newStats.dodgeChance = 0.05 + ((newStats.agility || 0) * 0.0030) + (this.statBonuses.dodgeChance || 0);
        newStats.armor = (newStats.armor || 0) + (this.statBonuses.armor || 0);

        const oldHealth = this.stats ? this.stats.health : newStats.maxHealth;
        const oldMana = this.stats ? this.stats.mana : newStats.maxMana;
        
        this.stats = newStats;
        
        this.stats.health = Math.min(oldHealth, this.stats.maxHealth);
        this.stats.mana = Math.min(oldMana, this.stats.maxMana);
    }
    learnTalent(talentId) { 
        if(this.talentPoints <= 0) return; 
        const talentTreeKey = this.race === 'Elf' ? 'ELF_MAGE' : 'HUMAN_WARRIOR';
        const talentTree = GameData.TALENTS[talentTreeKey] || [];
        const talentData = talentTree.find(t => t.id === talentId); 
        if(!talentData) return; 
        const currentRank = this.talents[talentId] || 0; 
        if(currentRank >= talentData.maxRank) return; 
        this.talents[talentId] = currentRank + 1; 
        this.talentPoints--; 
        this.recalculateStats(); 
        game.ui.updateAll(this); 
    }
    addAbilityToSpellbook(abilityId) { const abilityData = GameData.ABILITIES[abilityId]; if (abilityData && !this.spellbook.find(a => a.id === abilityId)) this.spellbook.push(abilityData); }
    addRecipe(recipeId) { const recipeData = GameData.CRAFTING_RECIPES[recipeId]; if (recipeData && !this.recipes.find(r => r.id === recipeId)) { this.recipes.push(recipeData); game.createFloatingText(`New Recipe: ${recipeData.name}!`, this.x, this.y - 80, 'cyan'); } }
    addItem(itemId, quantity = 1) {
        const itemData = { ...GameData.ITEMS[itemId] };
        if (!itemData) return;

        let itemAdded = false;
        if (itemData.stackable) {
            const existingStack = this.inventory.find(item => item && item.id === itemId);
            if (existingStack) {
                existingStack.quantity += quantity;
                itemAdded = true;
            }
        }
        
        if (!itemAdded) {
            const emptySlotIndex = this.inventory.findIndex(slot => slot === null);
            if (emptySlotIndex !== -1) {
                this.inventory[emptySlotIndex] = { ...itemData, quantity };
                itemAdded = true;
            }
        }

        if (!itemAdded) {
            if (game) game.createFloatingText("Inventory Full", this.x, this.y, 'red');
            return;
        }

        if (itemId === 5) { 
            if (!this.hotbar[0]) {
                const potionStack = this.inventory.find(i => i && i.id === 5);
                if (potionStack) {
                    this.hotbar[0] = { type: 'item', ref: potionStack };
                    if (game && game.ui) game.ui.setupActionbar(this);
                }
            }
        }
    }
    removeItem(itemId, quantity = 1) { const itemIndex = this.inventory.findIndex(item => item && item.id === itemId && item.quantity >= quantity); if (itemIndex > -1) { const itemStack = this.inventory[itemIndex]; itemStack.quantity -= quantity; if (itemStack.quantity <= 0) { this.inventory[itemIndex] = null; this.hotbar.forEach((slot, idx) => { if (slot && slot.type === 'item' && slot.ref === itemStack) { this.hotbar[idx] = null; } }); } return true; } return false; }
    equipItem(inventoryIndex) {
        const item = this.inventory[inventoryIndex];
        if (!item || !item.slot || !this.equipment.hasOwnProperty(item.slot)) return;
        const currentlyEquipped = this.equipment[item.slot];
        this.equipment[item.slot] = item;
        this.inventory[inventoryIndex] = currentlyEquipped;
        
        this.recalculateStats();

        game.ui.updateCharacterSheet(this);
        game.ui.updateInventory(this);
    }
    unequipItem(slot) {
        const itemToUnequip = this.equipment[slot];
        if (!itemToUnequip) return;
        const emptyInvSlot = this.inventory.findIndex(i => i === null);
        if (emptyInvSlot === -1) {
            game.createFloatingText("Inventory is full!", this.x, this.y, 'red');
            return;
        }
        this.inventory[emptyInvSlot] = itemToUnequip;
        this.equipment[slot] = null;

        this.recalculateStats();

        game.ui.updateCharacterSheet(this);
        game.ui.updateInventory(this);
    }
    addReputation(factionId, value) { if (!this.reputation[factionId]) this.reputation[factionId] = GameData.FACTIONS[factionId].base; this.reputation[factionId] += value; const factionData = GameData.FACTIONS[factionId]; if (factionData && factionData.values) { this.reputation[factionId] = Math.max(factionData.values[0], Math.min(this.reputation[factionId], factionData.values[factionData.values.length - 1])); } game.createFloatingText(`${value > 0 ? '+' : ''}${value} ${GameData.FACTIONS[factionId].name} Rep`, this.x, this.y-60, value > 0 ? 'lightgreen' : 'red'); }
    getRepairCost() { let totalCost = 0; Object.values(this.equipment).forEach(item => { if (item) { const damage = item.maxDurability - item.durability; totalCost += damage * 5; } }); return totalCost; }
    repairAllItems() { Object.values(this.equipment).forEach(item => { if (item) item.durability = item.maxDurability; }); }
    addQuest(questId, giver) { if (this.questCooldowns[questId]) { game.createFloatingText("Quest on cooldown!", this.x, this.y, 'red'); return; } if(this.quests.find(q => q.id === questId)) return; const questData = GameData.QUESTS[questId]; const questState = { ...questData, progress: questData.objectives.map(o => ({ ...o, current: 0 })), giver: giver }; this.quests.push(questState); game.ui.updateQuestLog(); }
    updateQuestProgress(type, targetId, amount = 1) {
        this.quests.forEach(quest => {
            quest.progress.forEach(obj => {
                const targetMatch = (type === 'craft' && obj.itemId === targetId) || (type === 'kill' && obj.target === targetId);
                if (obj.type === type && targetMatch && obj.current < obj.count) {
                    obj.current += amount;
                    const targetName = (type === 'craft') ? GameData.ITEMS[targetId].name : targetId;
                    game.createFloatingText(`${targetName}: ${obj.current}/${obj.count}`, this.x, this.y - 40, '#ffd700');
                    game.ui.updateQuestLog();
                }
            });
        });
    }
    craftItem(recipeId) {
        const recipe = GameData.CRAFTING_RECIPES[recipeId]; if (!recipe) return false;
        const profession = this.professions[recipe.profession]; if (!profession || profession.level < recipe.skillRequired) { game.createFloatingText("Skill too low!", this.x, this.y, 'red'); return false; }
        let hasMaterials = true; for (const mat of recipe.materials) { const playerMat = this.inventory.find(item => item && item.id === mat.itemId); if (!playerMat || playerMat.quantity < mat.quantity) { hasMaterials = false; game.createFloatingText("Missing materials!", this.x, this.y, 'red'); break; } }
        if (!hasMaterials) return false;
        for (const mat of recipe.materials) { this.removeItem(mat.itemId, mat.quantity); }
        this.addItem(recipe.itemId, 1); game.createFloatingText(`Crafted: ${recipe.name}`, this.x, this.y, 'lightgreen');
        
        // --- NEW: Update quest progress on craft ---
        this.updateQuestProgress('craft', recipe.itemId);

        this.gainProfessionXp(recipe.profession, 10); game.ui.updateAll(this); return true;
    }
    gainProfessionXp(professionName, amount) {
        const profession = this.professions[professionName]; if (!profession) return;
        const professionData = GameData.PROFESSIONS[professionName]; if (!professionData) return;
        if (profession.level >= professionData.maxLevel) return;
        
        profession.xp += amount; 
        game.createFloatingText(`+${amount} ${professionName} XP`, this.x, this.y - 60, 'lightgray');
        
        if (profession.level === 0) profession.level = 1; // First skill up
        
        while (profession.xp >= professionData.nextLevelXp && profession.level < professionData.maxLevel) { 
            profession.xp -= professionData.nextLevelXp; 
            profession.level++; 
            professionData.nextLevelXp += 50; 
            game.createFloatingText(`${professionName} Level Up!`, this.x, this.y - 100, 'gold');

            // --- NEW: Check for newly unlocked quests at this skill level ---
            Object.values(GameData.QUESTS).forEach(quest => {
                // Check if the quest has requirements and the player doesn't already have it.
                if (quest.requirements && !this.quests.find(q => q.id === quest.id)) {
                    quest.requirements.forEach(req => {
                        // Check if the requirement is for the profession that just leveled up to the exact required level.
                        if (req.type === 'profession' && req.name === professionName && profession.level === req.level) {
                            
                            // Find the NPC who gives this quest.
                            let giverName = "a Quest Giver"; // Default name as a fallback.
                            for (const region of GameData.REGIONS) {
                                const giver = region.npcs.find(npc => npc.questIds && npc.questIds.includes(quest.id));
                                if (giver) {
                                    giverName = giver.name;
                                    break; // Stop searching once found.
                                }
                            }
                            
                            // Create the alert text for the player!
                            game.createFloatingText(`New Quest Available! Check ${giverName}.`, this.x, this.y - 80, 'gold');
                        }
                    });
                }
            });
        }
    }
    
    draw(ctx, camera, player) {
        Entity.prototype.draw.call(this, ctx, camera, player);

        if(this.isTargeted) {
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(drawX, drawY + this.size/2, this.size/1.5, this.size/3, 0, 0, 2*Math.PI);
            ctx.stroke();
        }
    }
}
class NPC extends Character {
    constructor(x, y, name, icon, color) { super(x, y, 28, color || '#00ff00', icon || '\uf0c0', name); this.isInteractable = true; }
    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        ctx.font = '14px Verdana'; 
        ctx.fillStyle = this.color; 
        ctx.textAlign = 'center'; 
        ctx.fillText(this.name, drawX, drawY - this.size); 
    }
    interact(player) {}
}

class GenericNPC extends NPC {
    constructor(x, y, type) { super(x, y, type.name, type.icon, type.color); this.interactType = type.interactType; this.sells = type.sells; this.buys = type.buys; this.baseInteraction = type.interaction; this.profession = type.profession; }
    interact(player) { if (player.isGhost) return; if (this.interactType === 'vendor') { game.ui.openVendorWindow(player, this); } else if (this.interactType === 'crafting_trainer') { if (this.baseInteraction) { this.baseInteraction(player); } } else { if (this.baseInteraction) { this.baseInteraction(player); } else { alert(`Hello, ${player.name}. I am ${this.name}.`); } } }
}

class CraftingStation extends Entity {
    constructor(x, y, typeData) { super(x, y, typeData.size || 30, typeData.color, typeData.icon); this.name = typeData.name; this.type = typeData.type; this.recipes = typeData.recipes; this.isInteractable = true; }
    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        ctx.font = '14px Verdana'; 
        ctx.fillStyle = this.color; 
        ctx.textAlign = 'center'; 
        ctx.fillText(this.name, drawX, drawY - this.size); 
    }
    interact(player) { if (player.isGhost) return; game.ui.openCraftingWindow(player, this); }
}

class PlayerCorpse extends Entity {
    constructor(x, y) { super(x, y, 30, '#ff4500', '\uf521'); this.isInteractable = false; }
    draw(ctx, camera, player) { 
        if (player.isGhost) { 
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.fillStyle = "rgba(255, 255, 0, 0.3)"; 
            ctx.beginPath(); 
            ctx.arc(drawX, drawY, 40, 0, 2*Math.PI); 
            ctx.fill(); 
        } 
        super.draw(ctx, camera, player); 
    }
}

class Scenery extends Entity {
    constructor(x, y, type) {
        super(x, y, type.size, type.color, type.icon);
        this.type = type;
        this.isInteractable = false;
    }
    
    draw(ctx, camera, player) {
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;

        if (drawX + this.size < 0 || drawX - this.size > camera.width || drawY + this.size < 0 || drawY - this.size > camera.height) {
            return;
        }

        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.ellipse(drawX, drawY + this.size / 2, this.size / 2.5, this.size / 5, 0, 0, 2 * Math.PI);
        ctx.fill();

        ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`;
        ctx.fillStyle = this.type.color; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icon, drawX, drawY);
    }
}


class ResourceNode extends Entity {
    constructor(x, y, type) { super(x, y, type.size, type.color, type.icon); this.type = type; this.isInteractable = true; this.depleted = false; }
    interact(player) {
        if (this.depleted || player.isGhost) return;
        if (player.professions[this.type.requiredSkill].level === 0) {
            player.professions[this.type.requiredSkill].level = 1;
            game.createFloatingText(`You learned ${this.type.requiredSkill}!`, player.x, player.y, 'gold');
        }
        
        this.depleted = true; this.icon = '\uf2d3'; this.color = '#555';
        player.addItem(this.type.itemId, 1); game.createFloatingText(`+1 ${this.type.name}`, player.x, player.y - 20, 'white');
        player.gainProfessionXp(this.type.requiredSkill, 5); game.ui.updateInventory(player);
        setTimeout(() => { this.depleted = false; this.icon = this.type.icon; this.color = this.type.color; }, this.type.respawnTime);
    }
    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        if (!this.depleted) { 
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.font = '12px Verdana'; 
            ctx.fillStyle = this.type.color; 
            ctx.textAlign = 'center'; 
            ctx.fillText(this.type.name, drawX, drawY - this.size); 
        } 
    }
}

class QuestGiver extends NPC {
    // --- MODIFIED CONSTRUCTOR ---
    constructor(x, y, name, questIds, npcType = null) {
        const typeData = GameData.NPC_TYPES[npcType];
        // Determine icon and color based on npcType, with fallbacks for generic quest givers
        const icon = typeData ? typeData.icon : '\uf0e7';
        const color = typeData ? typeData.color : '#ffd700';
        
        super(x, y, name, icon, color);
        this.questIds = questIds;
        this.npcType = npcType; // Store the npcType for later use in the interact method
    }

    getQuestStatus(player) {
        for (const questId of this.questIds) {
            const questData = GameData.QUESTS[questId];
            const playerQuest = player.quests.find(q => q.id === questId);

            if (playerQuest) { // Player has the quest
                if (playerQuest.progress.every(p => p.current >= p.count)) return 'complete';
            } else { // Player does not have the quest
                if (player.questCooldowns[questId]) continue; // Quest is on cooldown

                // Check requirements
                let meetsReqs = true;
                if (questData.requirements) {
                    for (const req of questData.requirements) {
                        if (req.type === 'profession' && player.professions[req.name].level < req.level) {
                            meetsReqs = false;
                            break;
                        }
                        // Add other requirement types here (e.g., level, reputation)
                    }
                }
                if (meetsReqs) return 'available';
            }
        }
        return 'none';
    }

    draw(ctx, camera, player) { 
        super.draw(ctx, camera, player); 
        if(player.isGhost) return; 
        const status = this.getQuestStatus(player); 
        let questIcon = ''; 
        let iconColor = '#ffd700'; 
        if (status === 'available') questIcon = '!'; 
        if (status === 'complete') { questIcon = '?'; iconColor = '#ffd700'; } 
        else if (player.quests.find(q => this.questIds.includes(q.id) && !q.progress.every(p => p.current >= p.count))) { 
            questIcon = '?'; iconColor = '#888'; 
        } 
        if (questIcon) { 
            const drawX = this.x - camera.x;
            const drawY = this.y - camera.y;
            ctx.font = 'bold 30px Arial'; 
            ctx.fillStyle = iconColor; 
            ctx.fillText(questIcon, drawX, drawY - this.size - 25); 
        } 
    }

    interact(player, isAutomatic = false) {
        if (player.isGhost) return;

        const npcTypeData = GameData.NPC_TYPES[this.npcType];
        if (npcTypeData && npcTypeData.interactType === 'crafting_trainer') {
            const professionName = npcTypeData.profession;
            const profession = player.professions[professionName];
            if (profession && profession.level === 0) {
                const doLearn = confirm(`Greetings. I can teach you the basics of ${professionName} for 5 gold. Would you like to learn?`);
                if (doLearn) {
                    if (player.gold >= 500) {
                        player.gold -= 500;
                        profession.level = 1;
                        alert(`You have learned ${professionName}!`);
                        game.ui.updateAll(player);
                    } else {
                        alert("You don't have enough gold.");
                    }
                }
                return; 
            }
        }

        const availableQuestId = this.questIds.find(qId => this.getQuestStatusForId(player, qId) === 'available');
        const completableQuestId = this.questIds.find(qId => this.getQuestStatusForId(player, qId) === 'complete');
        const questId = completableQuestId || availableQuestId;

        if (!questId) {
            if (!isAutomatic) { 
                alert(`Hello, ${player.name}. I have no tasks for you at the moment.`);
            }
            return;
        }

        const questData = GameData.QUESTS[questId];
        const playerQuestInstance = player.quests.find(q => q.id === questId);
        
        if (completableQuestId) {
            if (!isAutomatic) {
                alert(`Quest Complete: ${questData.title}\nYou receive your rewards.`);
            } else {
                game.createFloatingText(`Quest Complete: ${questData.title}`, player.x, player.y - 60, 'gold');
            }
            player.addXp(questData.rewards.xp);
            player.gold += questData.rewards.gold;
            if (questData.rewards.reputation) player.addReputation(questData.rewards.reputation.faction, questData.rewards.reputation.value);
            if (questData.rewards.items) { questData.rewards.items.forEach(item => player.addItem(item.id, item.quantity)); }
            if (questData.rewards.recipes) { questData.rewards.recipes.forEach(recipeId => player.addRecipe(recipeId)); }
            
            player.quests = player.quests.filter(q => q.id !== questId);
            if (questData.repeatable && questData.cooldown) {
                player.questCooldowns[questId] = questData.cooldown;
            }
            if (player.isAutoQuesting && player.autoQuest && player.autoQuest.id === questId) {
                player.toggleAutoQuest(player.autoQuest);
            }
            game.ui.updateAll(player);
        } else if (availableQuestId) {
            const doAccept = isAutomatic || confirm(`Quest: ${questData.title}\n\n${questData.description}\n\nAccept quest?`);
            if (doAccept) {
                player.addQuest(questId, this);
            }
        } else if (playerQuestInstance && !isAutomatic) {
            const objectivesText = playerQuestInstance.progress.map(obj => {
                const targetName = obj.type === 'craft' ? GameData.ITEMS[obj.itemId].name : obj.target;
                return `- ${targetName}: ${obj.current}/${obj.count}`;
            }).join('\n');
            alert(`You are currently on quest: ${playerQuestInstance.title}.\nProgress:\n${objectivesText}`);
        }
    }

    getQuestStatusForId(player, questId) {
        const questData = GameData.QUESTS[questId];
        const playerQuest = player.quests.find(q => q.id === questId);
        if (playerQuest) {
            return playerQuest.progress.every(p => p.current >= p.count) ? 'complete' : 'in_progress';
        }
        if (player.questCooldowns[questId]) return 'on_cooldown';
        let meetsReqs = true;
        if (questData.requirements) {
            for (const req of questData.requirements) {
                if (req.type === 'profession' && player.professions[req.name].level < req.level) {
                    meetsReqs = false;
                    break;
                }
            }
        }
        return meetsReqs ? 'available' : 'unavailable';
    }
}
class Enemy extends Character {
    constructor(x, y, type) { 
        super(x, y, type.size, type.color, type.icon, type.name); 
        this.type = type; 
        this.state = 'patrol'; 
        this.patrolTarget = { x: x + (Math.random()*200-100), y: y + (Math.random()*200-100) }; 
        this.stats.health = this.stats.maxHealth = type.health; 
        this.stats.attackPower = type.attack; 
        this.attackSpeed = type.attackSpeed; 
        this.autoAttackTimer = 0; 
        this.spawnPoint = {x, y}; 
    }
    update(deltaTime, world, entities, player) { if(this.isDead) return; super.update(deltaTime); this.autoAttackTimer += deltaTime; const distToPlayer = distance(this, player); switch(this.state) { case 'patrol': if(distToPlayer < this.type.aggroRadius && !player.isDead && !player.isGhost) { this.state = 'chase'; this.setTarget(player); this.threatTable.set(player, 1); } else { if (!this.isRooted) this.moveTowards(this.patrolTarget, deltaTime); if (distance(this, this.patrolTarget) < 10) this.patrolTarget = { x: this.spawnPoint.x + (Math.random()*200-100), y: this.spawnPoint.y + (Math.random()*200-100) }; } break; case 'chase': if (!this.target || this.target.isDead || this.target.isGhost || distance(this, this.spawnPoint) > this.type.aggroRadius * 2.5) { this.state = 'patrol'; this.setTarget(null); this.threatTable.clear(); this.stats.health = this.stats.maxHealth; this.patrolTarget = this.spawnPoint; } else if (distance(this, this.target) <= this.type.attackRange) { this.state = 'attack'; } else { if (!this.isRooted) this.moveTowards(this.target, deltaTime); } break; case 'attack': if (!this.target || this.target.isDead || this.target.isGhost) { this.state = 'patrol'; this.setTarget(null); return; } if (distance(this, this.target) > this.type.attackRange) { this.state = 'chase'; } else { if (this.autoAttackTimer >= this.attackSpeed) { if (this.type.onAttack) this.type.onAttack(this, this.target); else this.target.takeDamage(this.stats.attackPower, 'physical', this); this.autoAttackTimer = 0; } } break; } }
    moveTowards(target, deltaTime) { const angle = Math.atan2(target.y - this.y, target.x - this.x); this.x += Math.cos(angle) * this.type.speed * (deltaTime / 16.67); this.y += Math.sin(angle) * this.type.speed * (deltaTime / 16.67); }
    die(killer) { 
        super.die();
        if (killer instanceof Player) {
            killer.addXp(this.type.xp);
            killer.updateQuestProgress('kill', this.type.name.split(" ")[1].toUpperCase());
            if(this.type.reputation) killer.addReputation(this.type.reputation.faction, this.type.reputation.value);
            this.type.lootTable.forEach(item => { if(Math.random() < item.chance) { if(item.gold) { killer.gold += item.gold; game.createFloatingText(`+${UI.formatCurrency(item.gold)}`, this.x, this.y, 'gold'); } if(item.itemId) { const quantity = item.min ? Math.floor(Math.random() * (item.max - item.min + 1)) + item.min : 1; killer.addItem(item.itemId, quantity); const itemData = GameData.ITEMS[item.itemId]; game.createFloatingText(`+ ${itemData.name}`, this.x, this.y - 20, `var(--color-text-${itemData.quality})`); } } });
            game.ui.updateInventory(killer); game.ui.setupActionbar(killer);
        }
    }
}
class Particle {
    constructor(ctx, x, y, color, size, lifetime, speed, options = {}) {
        this.ctx = ctx; this.x = x; this.y = y; this.color = color;
        this.initialSize = size; this.size = size;
        this.lifetime = lifetime; this.initialLifetime = lifetime;
        const angle = Math.random() * Math.PI * 2;
        this.vx = options.vx !== undefined ? options.vx : Math.cos(angle) * speed * (Math.random() * 5);
        this.vy = options.vy !== undefined ? options.vy : Math.sin(angle) * speed * (Math.random() * 5);
        this.active = true;
    }
    update(deltaTime) {
        this.lifetime -= deltaTime;
        if (this.lifetime <= 0) { this.active = false; return; }
        this.x += this.vx * (deltaTime / 16.67);
        this.y += this.vy * (deltaTime / 16.67);
        this.size = this.initialSize * (this.lifetime / this.initialLifetime);
    }
    draw(ctx, camera) {
        if (!this.active) return;
        const drawX = this.x - camera.x;
        const drawY = this.y - camera.y;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(drawX, drawY, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

const ParticleSystem = {
    particles: [],
    init(ctx) { this.ctx = ctx; },
    create(x, y, color, count = 20, lifetime = 1, speed = 2, options = {}) {
        for (let i = 0; i < count; i++) {
            this.particles.push(new Particle(this.ctx, x, y, color, Math.random() * 5 + 2, lifetime * 1000, speed, options));
        }
    },
    update(deltaTime) {
        this.particles = this.particles.filter(p => p.active);
        this.particles.forEach(p => p.update(deltaTime));
    },
    draw(camera) {
        this.ctx.save();
        this.ctx.globalCompositeOperation = 'lighter';
        this.particles.forEach(p => {
            p.draw(this.ctx, camera);
        });
        this.ctx.restore();
    }
};

class InputHandler {
    constructor(isMobile) { this.keys = {}; this.mouse = { x: 0, y: 0, clicked: false }; this.isMobile = isMobile; isMobile ? this.setupMobileControls() : this.setupDesktopControls(); }
    setupDesktopControls() { window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true); window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false); window.addEventListener('mousedown', (e) => { if(e.target.id === 'game-canvas') this.mouse.clicked = true; }); window.addEventListener('mousemove', (e) => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; }); }
    setupMobileControls() { const joystickArea = $('#joystick-area'); const joystickThumb = $('#joystick-thumb'); this.joystickVector = {x: 0, y: 0}; const handleTouch = (e) => { e.preventDefault(); const joystickRect = joystickArea.getBoundingClientRect(); const centerX = joystickRect.width / 2; const centerY = joystickRect.height / 2; const touch = e.touches[0]; let x = touch.clientX - joystickRect.left - centerX; let y = touch.clientY - joystickRect.top - centerY; const dist = Math.sqrt(x*x + y*y); const maxDist = centerX - joystickThumb.offsetWidth / 2; if (dist > maxDist) { x = (x / dist) * maxDist; y = (y / dist) * maxDist; } joystickThumb.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`; this.joystickVector = { x: x / maxDist, y: y / maxDist }; }; joystickArea.addEventListener('touchstart', handleTouch, { passive: false }); joystickArea.addEventListener('touchmove', handleTouch, { passive: false }); joystickArea.addEventListener('touchend', () => { joystickThumb.style.transform = `translate(-50%, -50%)`; this.joystickVector = { x: 0, y: 0 }; }); $('#game-canvas').addEventListener('touchstart', (e) => { const touch = e.touches[0]; if (touch.clientX > 200 && touch.clientY < window.innerHeight - 100) { this.mouse.x = touch.clientX; this.mouse.y = touch.clientY; this.mouse.clicked = true; } }); }
    getMoveVector() { if(this.isMobile) return this.joystickVector; let vector = { x: 0, y: 0 }; if (this.keys['w']) vector.y -= 1; if (this.keys['s']) vector.y += 1; if (this.keys['a']) vector.x -= 1; if (this.keys['d']) vector.x += 1; return vector; }
}
class UI {
    constructor(game) { 
        this.game = game; 
        this.minimapCanvas = $("#minimap-canvas"); 
        
        this.minimapCanvas.width = 150;
        this.minimapCanvas.height = 150;
        
        this.mCtx = this.minimapCanvas.getContext("2d");
        this.mapCanvas = $("#map-canvas"); 
        this.mapCtx = this.mapCanvas.getContext("2d"); 
        this.tooltip = $('#tooltip'); 
        this.needsVendorUpdate = true; 
        this.needsCraftingUpdate = true; 
        this.mapCacheCanvas = document.createElement('canvas');
        this.mapCacheCtx = this.mapCacheCanvas.getContext('2d');
        this.mapNeedsRedraw = true;

        this.setupActionbar(game.player);
        if (game.isMobile) this.setupMobileActionButtons(game.player);
        this.setupTooltips();
        this.setupDragAndDrop(game.player);
        window.addEventListener('resize', () => { this.mapNeedsRedraw = true; });
    }
    update(player, deltaTime) {
        this.updatePlayerFrame(player);
        if (!player.isDead) {
            this.updateTargetFrame(player.target);
            this.updateXPBar(player);
            this.updateCooldowns(player);
            if (this.game.isMobile) this.updateMobileCooldowns(player);
        } else {
            this.updateTargetFrame(null);
        }
        
        this.drawMinimap(player, game.entities);
        this.updateQuestTracker(player);

        $('#res-sickness-overlay').style.display = player.buffs.some(b => b.id === 'res_sickness') ? 'block' : 'none';
        
        if ($('#vendor-window').style.display === 'flex') {
            const vendor = game.entities.find(e => e.isTargeted && e.interactType === 'vendor');
            if (vendor) {
                if (this.needsVendorUpdate) {
                    this.updateVendorWindow(player, vendor);
                    this.needsVendorUpdate = false;
                }
            } else {
                $('#vendor-window').style.display = 'none';
            }
        }
        if ($('#crafting-window').style.display === 'flex') {
            const station = game.entities.find(e => e.isTargeted && e instanceof CraftingStation);
            if (station) {
                if(this.needsCraftingUpdate) {
                    this.updateCraftingWindow(player, station);
                    this.needsCraftingUpdate = false;
                }
            } else {
                $('#crafting-window').style.display = 'none';
            }
        }
        if ($('#map-window').style.display === 'flex') {
            this.updateMap();
        }
    }
    updateAll(player) { this.updatePlayerFrame(player); this.updateTargetFrame(player.target); this.updateCharacterSheet(player); this.updateInventory(player); this.updateXPBar(player); this.updateQuestLog(player); this.updateTalentWindow(player); this.updateSpellbook(player); this.updateReputationWindow(player); if (this.game.isMobile) this.setupMobileActionButtons(player); this.updateMap(player); }
    updatePlayerFrame(player) { $('#player-name').textContent = player.name; $('#player-level').textContent = `Lvl ${player.level}`; $('#player-health-text').textContent = `${Math.ceil(player.stats.health)} / ${player.stats.maxHealth}`; $('#player-health-fill').style.width = `${(player.stats.health / player.stats.maxHealth) * 100}%`; $('#player-mana-bar').style.display = player.race === 'Elf' ? 'block' : 'none'; if (player.race === 'Elf') { $('#player-mana-text').textContent = `${Math.ceil(player.stats.mana)} / ${player.stats.maxMana}`; $('#player-mana-fill').style.width = `${(player.stats.mana / player.stats.maxMana) * 100}%`; } this.updateBuffs(player, 'player-buffs'); }
    updateTargetFrame(target) { const frame = $('#target-frame'); if (target && target instanceof Character && !target.isDead) { frame.style.display = 'flex'; $('#target-portrait').innerHTML = `<i class="fas ${target.icon.substring(1)}"></i>`; $('#target-portrait').style.color = target.color; $('#target-name').textContent = target.name; $('#target-level').textContent = `Lvl ${target.level}`; $('#target-health-text').textContent = `${Math.ceil(target.stats.health)} / ${target.stats.maxHealth}`; $('#target-health-fill').style.width = `${(target.stats.health / target.stats.maxHealth) * 100}%`; this.updateBuffs(target, 'target-buffs'); } else if (target && !(target instanceof Character)) { frame.style.display = 'flex'; $('#target-portrait').innerHTML = `<i class="fas ${target.icon.substring(1)}"></i>`; $('#target-portrait').style.color = target.color; $('#target-name').textContent = target.name; $('#target-level').textContent = ''; $('#target-health-text').textContent = ''; $('#target-health-fill').style.width = `0%`; this.updateBuffs(target, 'target-buffs'); } else { frame.style.display = 'none'; } }
    updateXPBar(player) { const xpPercent = (player.xp / player.nextLevelXp) * 100; const restedPercent = (player.restedXp / player.nextLevelXp) * 100; $('#xp-bar-fill').style.width = `${xpPercent}%`; $('#xp-bar-rested-fill').style.width = `${Math.min(100 - xpPercent, restedPercent)}%`; $('#xp-bar').title = `XP: ${player.xp} / ${player.nextLevelXp}\nRested: ${Math.floor(player.restedXp)}`; }
    setupActionbar(player) { const bar = $('#action-bar'); bar.innerHTML = ''; for (let i = 0; i < 10; i++) { const slotItem = player.hotbar[i]; const slot = document.createElement('div'); slot.className = 'action-slot'; slot.dataset.index = i; slot.dataset.dropTarget = 'hotbar'; if (slotItem && slotItem.ref) { const ref = slotItem.ref; slot.innerHTML = `<i class="fas ${ref.icon} quality-${ref.quality || 'common'}"></i><div class="action-keybind">${(i+1)%10}</div>`; if(slotItem.type === 'ability') slot.innerHTML += `<div class="cooldown-overlay" data-ability-id="${ref.id}"></div>`; if(slotItem.type === 'item' && ref.quantity > 1) slot.innerHTML += `<div class="hotbar-item-count">${ref.quantity}</div>`; slot.addEventListener('click', () => player.useHotbarSlot(i)); } else { slot.innerHTML = `<div class="action-keybind">${(i+1)%10}</div>`; } bar.appendChild(slot); } if (this.game.isMobile) this.setupMobileActionButtons(player); }
    updateCooldowns(player) { $$('.cooldown-overlay').forEach(overlay => { const id = overlay.dataset.abilityId; const hotbarItem = player.hotbar.find(h => h && h.type === 'ability' && h.ref.id == id); if(hotbarItem && player.cooldowns[id]) { const remaining = player.cooldowns[id]; const percentage = (remaining / hotbarItem.ref.cooldown) * 100; overlay.style.height = `${percentage}%`; overlay.textContent = (remaining / 1000).toFixed(1); } else { overlay.style.height = '0%'; overlay.textContent = ''; } }); }
    drawMinimap(player, entities) {
        const size = 150;
        const range = 400;
        this.mCtx.clearRect(0, 0, size, size);
        this.mCtx.fillStyle = '#182c18';
        this.mCtx.fillRect(0, 0, size, size);

        const allEntities = [...entities, player];
        allEntities.sort((a,b) => a.y - b.y);

        allEntities.forEach(entity => {
            if (entity instanceof ResourceNode && entity.depleted) {
                return;
            }

            const dx = entity.x - player.x;
            const dy = entity.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            const isImportant = entity instanceof QuestGiver || entity instanceof GenericNPC || entity instanceof PlayerCorpse || entity instanceof CraftingStation;

            if (dist > range && !isImportant) {
                return;
            }

            let mapX, mapY;

            if (dist > range) {
                const clampRadius = (size / 2) - 5;
                mapX = (size / 2) + (dx / dist) * clampRadius;
                mapY = (size / 2) + (dy / dist) * clampRadius;
            } else {
                mapX = (size / 2) + (dx / range) * (size / 2);
                mapY = (size / 2) + (dy / range) * (size / 2);
            }

            let color = 'gray';
            let radius = 3;
            if (entity instanceof Player) {
                color = player.isResting ? 'cyan' : 'white';
                radius = 4;
            } else if (entity instanceof Enemy) color = 'red';
            else if (entity instanceof QuestGiver) { color = 'yellow'; radius = 4; }
            else if (entity instanceof GenericNPC) color = '#bbb';
            else if (entity instanceof ResourceNode) color = entity.type.color;
            else if (entity instanceof PlayerCorpse) { color = '#ff4500'; radius = 4; }
            else if (entity instanceof CraftingStation) { color = entity.color; radius = 4; }
            else if (entity instanceof Scenery) {
                color = entity.type.color;
                radius = entity.type.size / 20;
            }
            
            this.mCtx.fillStyle = color;
            this.mCtx.beginPath();
            this.mCtx.arc(mapX, mapY, radius, 0, 2 * Math.PI);
            this.mCtx.fill();
        });
    }
    updateMap() {
        if (!game || !game.player || $('#map-window').style.display !== 'flex') {
            return;
        }

        const canvas = this.mapCanvas;
        if (canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            this.mapNeedsRedraw = true;
        }
        
        if (this.mapNeedsRedraw && canvas.width > 0) {
            this.drawStaticMapToCache();
            this.mapNeedsRedraw = false;
        }

        this.mapCtx.clearRect(0, 0, canvas.width, canvas.height);
        if (this.mapCacheCanvas.width > 0) {
            this.mapCtx.drawImage(this.mapCacheCanvas, 0, 0);
        }
        this.drawDynamicMapElements();
    }

    drawStaticMapToCache() {
        const regions = GameData.REGIONS;
        const cacheCanvas = this.mapCacheCanvas;
        const cacheCtx = this.mapCacheCtx;
        
        cacheCanvas.width = this.mapCanvas.width;
        cacheCanvas.height = this.mapCanvas.height;
        if (cacheCanvas.width === 0) return;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        regions.forEach(r => {
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
        });

        const padding = 5000;
        minX -= padding; minY -= padding; maxX += padding; maxY += padding;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        const worldToMap = (worldX, worldY) => ({
            x: ((worldX - minX) / contentWidth) * cacheCanvas.width,
            y: ((worldY - minY) / contentHeight) * cacheCanvas.height
        });

        cacheCtx.fillStyle = "#0A0A0A";
        cacheCtx.fillRect(0, 0, cacheCanvas.width, cacheCanvas.height);

        regions.forEach(region => {
            const start = worldToMap(region.x, region.y);
            const end = worldToMap(region.x + region.width, region.y + region.height);
            const w = end.x - start.x;
            const h = end.y - start.y;

            cacheCtx.fillStyle = region.bgColor;
            cacheCtx.globalAlpha = 0.6;
            cacheCtx.fillRect(start.x, start.y, w, h);
            cacheCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            cacheCtx.lineWidth = 1;
            cacheCtx.strokeRect(start.x, start.y, w, h);

            cacheCtx.globalAlpha = 1.0;
            cacheCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            cacheCtx.font = 'bold 14px Verdana';
            cacheCtx.textAlign = 'center';
            cacheCtx.textBaseline = 'middle';
            cacheCtx.shadowColor = "black";
            cacheCtx.shadowBlur = 4;
            cacheCtx.fillText(region.name, start.x + w / 2, start.y + h / 2);
            cacheCtx.shadowBlur = 0;
        });
    }

    drawDynamicMapElements() {
        const player = game.player;
        const entities = game.entities;
        const regions = GameData.REGIONS;
        const ctx = this.mapCtx;
        const canvasWidth = this.mapCanvas.width;
        const canvasHeight = this.mapCanvas.height;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        regions.forEach(r => { minX = Math.min(minX, r.x); minY = Math.min(minY, r.y); maxX = Math.max(maxX, r.x + r.width); maxY = Math.max(maxY, r.y + r.height); });
        const padding = 5000;
        minX -= padding; minY -= padding; maxX += padding; maxY += padding;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        const worldToMap = (worldX, worldY) => ({
            x: ((worldX - minX) / contentWidth) * canvasWidth,
            y: ((worldY - minY) / contentHeight) * canvasHeight
        });

        const dynamicEntities = [player, ...entities.filter(e => e instanceof QuestGiver || e instanceof GenericNPC || e instanceof CraftingStation)];
        
        dynamicEntities.forEach(entity => {
            const pos = worldToMap(entity.x, entity.y);

            if (entity instanceof Player) {
                ctx.save();
                ctx.translate(pos.x, pos.y);
                const moveVector = game.input.getMoveVector();
                const angle = (moveVector.x === 0 && moveVector.y === 0) ? -Math.PI / 2 : Math.atan2(moveVector.y, moveVector.x);
                ctx.rotate(angle + Math.PI / 2);

                ctx.fillStyle = '#3498db'; ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -8); ctx.lineTo(6, 6); ctx.lineTo(-6, 6);
                ctx.closePath();
                ctx.fill(); ctx.stroke();
                ctx.restore();

            } else if (entity instanceof QuestGiver) {
                const status = entity.getQuestStatus(player);
                let icon = '', iconColor = 'yellow';
                if (status === 'available') icon = '!';
                else if (status === 'complete') { icon = '?'; iconColor = 'yellow'; }
                else if (player.quests.find(q => entity.questIds.includes(q.id))) { icon = '?'; iconColor = '#888'; }

                if (icon) {
                    ctx.font = 'bold 24px Arial'; ctx.fillStyle = iconColor; ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; ctx.strokeStyle = 'black'; ctx.lineWidth = 4;
                    ctx.strokeText(icon, pos.x, pos.y); ctx.fillText(icon, pos.x, pos.y);
                }
            } else if (entity instanceof GenericNPC || entity instanceof CraftingStation) {
                ctx.fillStyle = entity.color || 'white'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            }
        });
    }
    createFloatingText(text, worldX, worldY, color, camera, type = '') { const textElement = document.createElement('div'); textElement.className = `floating-text ${type}`; textElement.textContent = text; textElement.style.color = color; textElement.style.left = `${worldX - camera.x}px`; textElement.style.top = `${worldY - camera.y}px`; $('#floating-text-container').appendChild(textElement); setTimeout(() => textElement.remove(), 1500); }
    updateCharacterSheet(player) {
        player.recalculateStats(); const content = $('#character-content');
        content.innerHTML = `<div id="character-sheet-container"><div id="equipment-slots"></div><div id="stats-column"></div></div>`;
        const statsCol = $('#stats-column'); let statsHtml = `<div class="stat-line"><span>Health</span><span>${Math.ceil(player.stats.health)} / ${player.stats.maxHealth}</span></div>`;
        if (player.race === 'Elf') statsHtml += `<div class="stat-line"><span>Mana</span><span>${Math.ceil(player.stats.mana)} / ${player.stats.maxMana}</span></div>`;
        statsHtml += `<hr><div class="stat-line"><span>Strength</span><span>${Math.floor(player.stats.strength)}</span></div> <div class="stat-line"><span>Agility</span><span>${Math.floor(player.stats.agility)}</span></div> <div class="stat-line"><span>Stamina</span><span>${Math.floor(player.stats.stamina)}</span></div>`;
        if (player.race === 'Elf') statsHtml += `<div class="stat-line"><span>Intellect</span><span>${Math.floor(player.stats.intellect)}</span></div>`;
        statsHtml += `<div class="stat-line"><span>Spirit</span><span>${Math.floor(player.stats.spirit)}</span></div><hr> <div class="stat-line"><span>Attack Power</span><span>${player.stats.attackPower.toFixed(1)}</span></div> <div class="stat-line"><span>Crit Chance</span><span>${(player.stats.critChance * 100).toFixed(2)}%</span></div> <div class="stat-line"><span>Dodge Chance</span><span>${(player.stats.dodgeChance * 100).toFixed(2)}%</span></div> <div class="stat-line"><span>Armor</span><span>${player.stats.armor}</span></div>`;
        statsCol.innerHTML = statsHtml;
        const equipCol = $('#equipment-slots'); equipCol.innerHTML = '';
        for (const slotName in player.equipment) { const slot = document.createElement('div'); slot.className = 'equipment-slot'; slot.dataset.slot = slotName; const item = player.equipment[slotName]; if (item) { slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`; slot.draggable = true; slot.dataset.source = 'equipment'; } slot.innerHTML += `<div class="equipment-slot-name">${slotName.replace('-', ' ')}</div>`; equipCol.appendChild(slot); }
        let professionsHtml = '<hr><h3>Professions</h3>'; for (const profName in player.professions) { const prof = player.professions[profName]; if(prof.level > 0) { const profData = GameData.PROFESSIONS[profName]; professionsHtml += `<div class="stat-line"><span>${profName}</span><span>${prof.level} / ${profData.maxLevel}</span></div>`; } } statsCol.innerHTML += professionsHtml;
    }
    updateInventory(player) { const grid = $('#inventory-grid'); grid.innerHTML = ''; player.inventory.forEach((item, index) => { const slot = document.createElement('div'); slot.className = 'inventory-slot'; slot.dataset.index = index; slot.dataset.source = 'inventory'; if (item) { slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`; if(item.stackable && item.quantity > 1) slot.innerHTML += `<div class="item-count">${item.quantity}</div>`; slot.dataset.itemId = item.id; slot.draggable = true; slot.addEventListener('click', (e) => { const currentVendor = game.entities.find(entity => entity.isTargeted && entity.interactType === 'vendor'); if (currentVendor) { this.sellItemFromInventory(player, item, index, currentVendor); } }); } grid.appendChild(slot); }); $('#currency').innerHTML = UI.formatCurrency(player.gold, true); }
    static formatCurrency(amount, useIcons = false) { const gold = Math.floor(amount / 10000); const silver = Math.floor((amount % 10000) / 100); const copper = amount % 100; if(useIcons) { return `<div class="currency-item">${gold} <div class="currency-icon gold"></div></div> <div class="currency-item">${silver} <div class="currency-icon silver"></div></div> <div class="currency-item">${copper} <div class="currency-icon copper"></div></div>`; } return `${gold}g ${silver}s ${copper}c`; }
    setupDragAndDrop(player) { document.body.addEventListener('dragstart', (e) => { const slot = e.target.closest('[draggable="true"]'); if (slot) { e.dataTransfer.setData('text/plain', `${slot.dataset.source},${slot.dataset.index || slot.dataset.slot}`); e.dataTransfer.effectAllowed = 'move'; } }); document.body.addEventListener('dragover', (e) => { e.preventDefault(); const targetSlot = e.target.closest('.action-slot, .equipment-slot, .inventory-slot'); if (targetSlot) { $$('.drag-over').forEach(el => el.classList.remove('drag-over')); targetSlot.classList.add('drag-over'); } }); document.body.addEventListener('dragleave', (e) => { const targetSlot = e.target.closest('.action-slot, .equipment-slot, .inventory-slot'); if(targetSlot) targetSlot.classList.remove('drag-over'); }); document.body.addEventListener('drop', (e) => { e.preventDefault(); $$('.drag-over').forEach(el => el.classList.remove('drag-over')); const targetSlot = e.target.closest('.action-slot, .equipment-slot, .inventory-slot'); if (!targetSlot) return; const [sourceType, sourceIdentifier] = e.dataTransfer.getData('text/plain').split(','); if (targetSlot.matches('.equipment-slot')) { if (sourceType === 'inventory') { player.equipItem(parseInt(sourceIdentifier)); } } else if (targetSlot.matches('.inventory-slot')) { if (sourceType === 'equipment') { player.unequipItem(sourceIdentifier); } } else if (targetSlot.matches('.action-slot')) { const hotbarIndex = targetSlot.dataset.index; player.setHotbarSlot(hotbarIndex, sourceType, sourceIdentifier); } }); }
    updateQuestLog(player = this.game.player) {
        const content = $('#quest-log-content'); content.innerHTML = ''; if (player.quests.length === 0) { content.innerHTML = 'You have no active quests.'; }
        player.quests.forEach(quest => { const item = document.createElement('div'); item.className = 'quest-item'; const details = document.createElement('div'); let objectivesHtml = ''; quest.progress.forEach(obj => { if (obj.type === 'kill') { objectivesHtml += `<div class="quest-objective">- ${obj.target} slain: ${obj.current} / ${obj.count}</div>`; } else if (obj.type === 'gather') { objectivesHtml += `<div class="quest-objective">- ${obj.target} gathered: ${player.inventory.filter(i => i && i.name.toUpperCase() === obj.target).reduce((sum, i) => sum + i.quantity, 0)} / ${obj.count}</div>`; } }); details.innerHTML = `<div class="quest-title">${quest.title}</div>${objectivesHtml}`; const button = document.createElement('button'); button.className = 'auto-quest-btn'; if (player.isAutoQuesting && player.autoQuest && player.autoQuest.id === quest.id) { button.textContent = 'Stop'; button.classList.add('active'); } else { button.textContent = 'Auto'; } button.addEventListener('click', (e) => { e.stopPropagation(); player.toggleAutoQuest(quest); }); item.appendChild(details); item.appendChild(button); content.appendChild(item); });
        const cooldownsDiv = document.createElement('div'); cooldownsDiv.style.marginTop = '10px'; cooldownsDiv.innerHTML = '<h3>Quest Cooldowns</h3>'; let hasCooldowns = false; for (const questId in player.questCooldowns) { const remainingTime = player.questCooldowns[questId]; if (remainingTime > 0) { const questData = GameData.QUESTS[questId]; const minutes = Math.floor(remainingTime / 60000); const seconds = Math.floor((remainingTime % 60000) / 1000); cooldownsDiv.innerHTML += `<div class="stat-line"><span>${questData.title}</span><span>${minutes}m ${seconds}s</span></div>`; hasCooldowns = true; } } if (hasCooldowns) { content.appendChild(cooldownsDiv); } else if (player.quests.length === 0) { content.innerHTML = 'You have no active quests or quests on cooldown.'; }
    }
    setupTooltips() {
        document.body.addEventListener('mouseover', (e) => {
            let itemRef;
            const slot = e.target.closest('.inventory-slot, .action-slot, .spellbook-slot, .buff-icon, .talent, .vendor-item-slot, .crafting-recipe-slot, .equipment-slot');
            if (!slot) return;

            if(slot.matches('.talent')) {
                const talentId = slot.dataset.talentId;
                const talentTreeKey = game.player.race === 'Elf' ? 'ELF_MAGE' : 'HUMAN_WARRIOR';
                const talentTree = GameData.TALENTS[talentTreeKey] || [];
                itemRef = talentTree.find(t => t.id === talentId);
            } 
            else if(slot.matches('.inventory-slot[data-item-id], .action-slot')) {
                let hotbarItem;
                if(slot.dataset.itemId) {
                    const invIndex = slot.dataset.index;
                    itemRef = game.player.inventory[invIndex];
                } else if (slot.dataset.index && (hotbarItem = game.player.hotbar[slot.dataset.index])) {
                    if(hotbarItem) itemRef = hotbarItem.ref;
                }
            } else if (slot.matches('.equipment-slot')) {
                const slotName = slot.dataset.slot;
                itemRef = game.player.equipment[slotName];
            } else if(slot.matches('.spellbook-slot')) {
                const spellIndex = slot.dataset.index;
                itemRef = game.player.spellbook[spellIndex];
            } else if(slot.matches('.buff-icon')) {
                const buffId = slot.dataset.buffId;
                const parentFrame = slot.closest('.unit-frame').id;
                const unit = parentFrame === 'player-frame' ? game.player : game.player.target;
                if(unit) itemRef = unit.buffs.find(b => b.id === buffId);
            } else if(slot.matches('.vendor-item-slot')) {
                const itemId = slot.dataset.itemId;
                itemRef = GameData.ITEMS[itemId];
            } else if (slot.matches('.crafting-recipe-slot')) {
                const recipeId = slot.dataset.recipeId;
                itemRef = GameData.CRAFTING_RECIPES[recipeId];
            }
            
            if (!itemRef) return;

            let statsHtml = '';
            
            // --- NEW: Display Weapon Damage ---
            if (itemRef.weaponDamage) {
                statsHtml += `<div class="stats"><div>${itemRef.weaponDamage.min} - ${itemRef.weaponDamage.max} Damage</div></div>`;
            }

            if (itemRef.stats) {
                statsHtml += '<div class="stats">';
                for(const stat in itemRef.stats) statsHtml += `<div style="color: lightgreen">+${itemRef.stats[stat]} ${stat.charAt(0).toUpperCase() + stat.slice(1)}</div>`;
                statsHtml += '</div>';
            }
            if (itemRef.cost) statsHtml += `<div class="stats"><div>Mana Cost: ${itemRef.cost}</div><div>Cooldown: ${itemRef.cooldown/1000}s</div></div>`;
            if (itemRef.durability !== undefined) statsHtml += `<div class="durability">Durability: ${itemRef.durability} / ${itemRef.maxDurability}</div>`;
            if (itemRef.materials) {
                statsHtml += '<div class="stats">Required:<ul>';
                for (const mat of itemRef.materials) {
                    const matData = GameData.ITEMS[mat.itemId];
                    statsHtml += `<li>${mat.quantity}x ${matData.name}</li>`;
                }
                statsHtml += '</ul></div>';
            }
            
            let description = itemRef.slot || (itemRef.range ? `Range: ${itemRef.range}` : itemRef.description || '');
            
            if (slot.matches('.talent')) {
                const currentRank = game.player.talents[itemRef.id] || 0;
                description = `Rank ${currentRank} / ${itemRef.maxRank}<br><br>${itemRef.description}`;
            }

            this.tooltip.innerHTML = `<div class="name quality-${itemRef.quality || 'common'}">${itemRef.name}</div><div class="description">${description}</div>${statsHtml}`;
            this.tooltip.style.display = 'block';
        });

        document.body.addEventListener('mousemove', (e) => {
            if (this.tooltip.style.display === 'block') {
                let x = e.clientX + 15;
                let y = e.clientY + 15;
                if (x + this.tooltip.offsetWidth > window.innerWidth) x = e.clientX - this.tooltip.offsetWidth - 15;
                if (y + this.tooltip.offsetHeight > window.innerHeight) y = e.clientY - this.tooltip.offsetHeight - 15;
                this.tooltip.style.left = `${x}px`;
                this.tooltip.style.top = `${y}px`;
            }
        });

        document.body.addEventListener('mouseout', (e) => {
            const slot = e.target.closest('.inventory-slot, .action-slot, .spellbook-slot, .buff-icon, .talent, .vendor-item-slot, .crafting-recipe-slot, .equipment-slot');
            if (slot) this.tooltip.style.display = 'none';
        });
    }
    makeDraggable(element) { let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; const header = element.querySelector('.window-header'); const dragMouseDown = (e) => { e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; }; const elementDrag = (e) => { e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; element.style.top = (element.offsetTop - pos2) + "px"; element.style.left = (element.offsetLeft - pos1) + "px"; }; const closeDragElement = () => { document.onmouseup = null; document.onmousemove = null; }; if (header) header.onmousedown = dragMouseDown; else element.onmousedown = dragMouseDown; }
    showDeathScreen() { $('#death-screen').style.display = 'flex'; }
    hideDeathScreen() { $('#death-screen').style.display = 'none'; }
    updateTalentWindow(player) { 
        $('#talent-points-display').textContent = `Talent Points: ${player.talentPoints}`; 
        const tree = $('#talent-tree'); 
        tree.innerHTML = ''; 
        const talentTreeKey = player.race === 'Elf' ? 'ELF_MAGE' : 'HUMAN_WARRIOR';
        const talentTree = GameData.TALENTS[talentTreeKey] || [];
        talentTree.forEach(talent => { 
            const currentRank = player.talents[talent.id] || 0; 
            const div = document.createElement('div'); 
            div.className = 'talent'; 
            div.dataset.talentId = talent.id; 
            if (currentRank >= talent.maxRank) div.classList.add('maxed'); 
            if (player.talentPoints === 0 && currentRank < talent.maxRank) div.classList.add('locked'); 
            div.innerHTML = `<div class="talent-icon"><i class="fas ${talent.icon}"></i></div><div class="talent-name">${talent.name}</div><div class="talent-rank">${currentRank} / ${talent.maxRank}</div>`; 
            if (!div.classList.contains('locked') && !div.classList.contains('maxed')) { 
                div.addEventListener('click', () => player.learnTalent(talent.id)); 
            } 
            tree.appendChild(div); 
        }); 
    }
    updateSpellbook(player) { const grid = $('#spellbook-grid'); grid.innerHTML = ''; player.spellbook.forEach((ability, index) => { const slot = document.createElement('div'); slot.className = 'spellbook-slot'; slot.dataset.index = index; slot.dataset.source = 'spellbook'; slot.draggable = true; slot.innerHTML = `<i class="fas ${ability.icon}"></i>`; grid.appendChild(slot); }); if (player.recipes.length > 0) { const recipeSection = document.createElement('div'); recipeSection.innerHTML = '<hr><h3>Recipes</h3><div id="spellbook-recipes-grid" class="spellbook-grid"></div>'; grid.appendChild(recipeSection); const recipeGrid = $('#spellbook-recipes-grid'); player.recipes.forEach((recipe, index) => { const slot = document.createElement('div'); slot.className = 'spellbook-slot'; slot.dataset.index = index; slot.dataset.source = 'recipe'; slot.draggable = false; slot.innerHTML = `<i class="fas ${recipe.icon}"></i>`; recipeGrid.appendChild(slot); }); } }
    updateReputationWindow(player) { const content = $('#reputation-content'); content.innerHTML = ''; for (const factionId in GameData.FACTIONS) { const faction = GameData.FACTIONS[factionId]; const playerRep = player.reputation[factionId] || faction.base; let currentTier = faction.tiers[0]; for (let i = 0; i < faction.tiers.length; i++) { if (playerRep >= faction.values[i]) { currentTier = faction.tiers[i]; } else { break; } } let nextTierValue = ''; const currentTierIndex = faction.tiers.indexOf(currentTier); if (currentTierIndex < faction.tiers.length - 1) { nextTierValue = ` / ${faction.values[currentTierIndex + 1]}`; } content.innerHTML += `<div class="reputation-line"><span>${faction.name} (${currentTier})</span><span>${playerRep}${nextTierValue}</span></div>`; } }
    updateBuffs(character, containerId) { const container = $(`#${containerId}`); container.innerHTML = ''; if(!character || !character.buffs) return; character.buffs.forEach(buff => { const div = document.createElement('div'); div.className = 'buff-icon'; if (buff.isDebuff) div.classList.add('debuff'); div.dataset.buffId = buff.id; div.innerHTML = `<i class="fas ${buff.icon}"></i><div class="buff-duration">${(buff.duration/1000).toFixed(0)}</div>`; container.appendChild(div); }); }
    openVendorWindow(player, vendor) { this.needsVendorUpdate = true; $('#vendor-window').style.display = 'flex'; player.setTarget(vendor); }
    sellItemFromInventory(player, item, index, vendor) { if (!item || !item.sellPrice || !vendor.buys.includes(item.slot)) { game.createFloatingText("Vendor doesn't buy that!", player.x, player.y, 'red'); return; } this.needsVendorUpdate = true; player.gold += item.sellPrice; player.removeItem(item.id, 1); game.createFloatingText(`+${UI.formatCurrency(item.sellPrice)}`, player.x, player.y, 'gold'); this.updateInventory(player); }
    buyItemFromVendor(player, itemData, price, quantity) { if (player.gold < price) { game.createFloatingText("Not enough gold!", player.x, player.y, 'red'); return; } if (player.inventory.filter(s => s === null).length === 0 && (!itemData.stackable || !player.inventory.some(i => i && i.id === itemData.id))) { game.createFloatingText("Inventory full!", player.x, player.y, 'red'); return; } this.needsVendorUpdate = true; player.gold -= price; player.addItem(itemData.id, quantity); game.createFloatingText(`-${UI.formatCurrency(price)}`, player.x, player.y, 'red'); game.createFloatingText(`+ ${itemData.name}`, player.x, player.y - 20, 'white'); this.updateInventory(player); }
    openCraftingWindow(player, station) { $('#crafting-window').style.display = 'flex'; this.updateCraftingWindow(player, station); player.setTarget(station); this.activeCraftingStation = station; this.selectedRecipe = null; $('#craft-button').removeEventListener('click', this.boundCraftingHandler); this.boundCraftingHandler = () => player.craftItem(this.selectedRecipe.id); $('#craft-button').addEventListener('click', this.boundCraftingHandler); }
    updateVendorWindow(player, vendor) { const playerInventoryGrid = $('#vendor-player-inventory'); const vendorSellsGrid = $('#vendor-sells-grid'); $('#vendor-player-gold').innerHTML = UI.formatCurrency(player.gold, true); playerInventoryGrid.innerHTML = ''; player.inventory.forEach((item, index) => { if (item && vendor.buys.includes(item.slot)) { const slot = document.createElement('div'); slot.className = 'vendor-item-slot inventory-slot'; slot.dataset.index = index; slot.dataset.itemId = item.id; slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`; if(item.stackable && item.quantity > 1) slot.innerHTML += `<div class="item-count">${item.quantity}</div>`; if(item.sellPrice) slot.innerHTML += `<div class="vendor-item-price">${UI.formatCurrency(item.sellPrice, true)}</div>`; slot.addEventListener('click', () => this.sellItemFromInventory(player, item, index, vendor)); playerInventoryGrid.appendChild(slot); } }); vendorSellsGrid.innerHTML = ''; if (vendor.sells) { vendor.sells.forEach((itemDef, index) => { const itemData = GameData.ITEMS[itemDef.itemId]; if (itemData) { const slot = document.createElement('div'); slot.className = 'vendor-item-slot'; slot.dataset.itemId = itemData.id; slot.innerHTML = `<i class="fas ${itemData.icon} quality-${itemData.quality}"></i>`; if (itemDef.quantity > 1) slot.innerHTML += `<div class="item-count">${itemDef.quantity}</div>`; slot.innerHTML += `<div class="vendor-item-price">${UI.formatCurrency(itemDef.price, true)}</div>`; slot.addEventListener('click', () => { this.buyItemFromVendor(player, itemData, itemDef.price, itemDef.quantity); this.needsVendorUpdate = true; }); vendorSellsGrid.appendChild(slot); } }); } }
    setupMobileActionButtons(player) { const container = $('#mobile-action-buttons'); container.innerHTML = ''; const numButtons = 3; for (let i = 0; i < numButtons; i++) { const slotItem = player.hotbar[i]; const button = document.createElement('div'); button.className = 'mobile-action-button'; if (slotItem) { const ref = slotItem.ref; button.innerHTML = `<i class="fas ${ref.icon}"></i><div class="cooldown-overlay" data-ability-id="${ref.id}"></div>`; button.addEventListener('touchstart', (e) => { e.preventDefault(); player.useHotbarSlot(i); }); } else { button.innerHTML = ``; } container.appendChild(button); } }
    updateMobileCooldowns(player) { $$('#mobile-action-buttons .cooldown-overlay').forEach((overlay, index) => { const id = overlay.dataset.abilityId; const hotbarItem = player.hotbar[index]; if(hotbarItem && player.cooldowns[id]) { const remaining = player.cooldowns[id]; const percentage = (remaining / hotbarItem.ref.cooldown) * 100; overlay.style.height = `${percentage}%`; overlay.textContent = (remaining / 1000).toFixed(1); } else { overlay.style.height = '0%'; overlay.textContent = ''; } }); }
    updateCraftingWindow(player, station) {
        const recipesGrid = $('#crafting-recipes-grid'); const materialsDisplay = $('#crafting-materials-display'); const craftButton = $('#craft-button'); recipesGrid.innerHTML = ''; materialsDisplay.innerHTML = ''; craftButton.disabled = true;
        const availableRecipes = player.recipes.filter(r => station.recipes.includes(r.id));
        if (availableRecipes.length === 0) { recipesGrid.innerHTML = '<p>You have no recipes for this station.</p>'; return; }
        availableRecipes.forEach(recipe => { const slot = document.createElement('div'); slot.className = 'crafting-recipe-slot'; slot.dataset.recipeId = recipe.id; slot.innerHTML = `<i class="fas ${recipe.icon} quality-${recipe.quality || 'common'}"></i>`; slot.innerHTML += `<div class="crafting-recipe-cost">${recipe.name}</div>`; if(this.selectedRecipe && this.selectedRecipe.id === recipe.id) { slot.style.borderColor = 'gold'; } slot.addEventListener('click', () => { this.selectedRecipe = recipe; this.needsCraftingUpdate = true; }); recipesGrid.appendChild(slot); });
        if (this.selectedRecipe) {
            materialsDisplay.innerHTML = `<h3>${this.selectedRecipe.name} Requirements:</h3><ul>`; let canCraft = true;
            const profession = player.professions[this.selectedRecipe.profession]; const hasSkill = profession && profession.level >= this.selectedRecipe.skillRequired; if(!hasSkill) canCraft = false;
            for (const mat of this.selectedRecipe.materials) { const playerMat = player.inventory.find(item => item && item.id === mat.itemId); const hasEnough = playerMat && playerMat.quantity >= mat.quantity; const matData = GameData.ITEMS[mat.itemId]; materialsDisplay.innerHTML += `<li style="color: ${hasEnough ? 'lightgreen' : 'red'};">${mat.quantity}x ${matData.name} (${playerMat ? playerMat.quantity : 0} owned)</li>`; if (!hasEnough) canCraft = false; }
            materialsDisplay.innerHTML += `<li style="color: ${hasSkill ? 'lightgreen' : 'red'};">Requires ${this.selectedRecipe.profession} (${this.selectedRecipe.skillRequired})</li>`;
            materialsDisplay.innerHTML += '</ul>'; craftButton.disabled = !canCraft; craftButton.textContent = `Craft ${this.selectedRecipe.name}`;
        }
    }
    updateQuestTracker(player) {
        const tracker = $('#quest-tracker');
        if (!player || player.quests.length === 0) {
            tracker.style.display = 'none';
            return;
        }

        tracker.style.display = 'block';
        let html = '<h3>Quest Log</h3>';

        player.quests.forEach(quest => {
            if (quest.progress.every(p => p.current >= p.count)) return;

            html += `<div class="tracker-quest-title">${quest.title}</div>`;
            quest.progress.forEach(obj => {
                html += `<div class="tracker-quest-objective">- ${obj.target} slain: ${obj.current} / ${obj.count}</div>`;
            });
        });
        
        if (html === '<h3>Quest Log</h3>') {
            tracker.style.display = 'none';
        } else {
            tracker.innerHTML = html;
        }
    }
}

function showMainMenu() {
    $('#main-menu').style.display = 'flex';
    $('#character-creation-screen').style.display = 'none';
    $('#game-container').style.display = 'none';
    
    const hasSave = localStorage.getItem('miniWowSaveData');
    $('#continue-button').disabled = !hasSave;
}

function initGame(playerOptions = null) {
    $('#main-menu').style.display = 'none';
    $('#character-creation-screen').style.display = 'none';
    $('#game-container').style.display = 'block';
    
    game = new Game(playerOptions);
    window.game = game;
}

document.addEventListener('DOMContentLoaded', () => {
    showMainMenu();

    $('#continue-button').addEventListener('click', () => {
        initGame();
    });

    $('#new-char-button').addEventListener('click', () => {
        $('#main-menu').style.display = 'none';
        $('#character-creation-screen').style.display = 'flex';
    });
    
    let selectedRace = null;
    $$('.race-option').forEach(el => {
        el.addEventListener('click', () => {
            $$('.race-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
            selectedRace = el.dataset.race;
        });
    });

    $('#start-game-button').addEventListener('click', () => {
        const name = $('#char-name-input').value.trim();
        if (!name) { alert("Please enter a name for your hero."); return; }
        if (!selectedRace) { alert("Please select a race."); return; }
        
        localStorage.removeItem('miniWowSaveData');
        
        initGame({ name, race: selectedRace });
    });
});

</script>
</body>
</html>
