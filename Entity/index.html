<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Evolution Simulation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;400;700&display=swap" rel="stylesheet">
        <link rel="manifest" href="manifest.json">
    <!-- Theme color for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#00ffff">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* VISUAL ENHANCEMENT: Animated Grid Background */
        @keyframes subtle-scroll {
            from { background-position: 0 0; }
            to { background-position: -256px 0; }
        }

        /* Basic Resets & Body Styles */
        body {
            margin: 0;
            background-color: #01040a; /* Fallback */
            background-image:
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 32px 32px;
            animation: subtle-scroll 10s linear infinite;
            font-family: 'Exo 2', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden;
        }

        /* Canvas Styles */
        canvas {
            display: block;
            width: 100%;
            flex-grow: 1;
            background-color: transparent;
            cursor: crosshair;
        }
        canvas.dragging {
            cursor: grabbing;
        }

        /* UI Panel (God Panel) Styles */
        #ui-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.4), 0 0 20px rgba(0, 255, 255, 0.2);
            max-width: 300px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 0.9em;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(0);
            opacity: 1;
        }
        #ui-panel.hidden {
            transform: translateX(110%);
            opacity: 0;
            pointer-events: none;
        }
        #ui-panel h2, #nn-visualization-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 700;
        }
        #ui-panel h2 {
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* NEW: Section sub-headers in God Panel */
        .panel-subheader {
            color: #0ff;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 5px;
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 1.05em;
        }


        .param-group { display: flex; flex-direction: column; gap: 5px; }
        .param-group label { display: flex; justify-content: space-between; align-items: center; color: #ccc; }
        .param-group input[type="range"] {
            width: 100%; -webkit-appearance: none; height: 8px; border-radius: 5px;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 100, 100, 0.2) 100%);
            outline: none; opacity: 0.7; transition: opacity .2s; border: 1px solid rgba(0, 255, 255, 0.1);
        }
        .param-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: #0ff; cursor: pointer; box-shadow: 0 0 8px #0ff, 0 0 12px rgba(0,255,255,0.7);
            border: 2px solid #fff;
        }
        .param-group input[type="range"]::-moz-range-thumb {
            width: 16px; height: 16px; border-radius: 50%; background: #0ff; cursor: pointer;
            box-shadow: 0 0 8px #0ff, 0 0 12px rgba(0,255,255,0.7); border: 2px solid #fff;
        }
        .ui-button {
            padding: 10px 15px; font-size: 1em; font-weight: bold; font-family: 'Exo 2', sans-serif;
            background-image: linear-gradient(45deg, rgba(0, 123, 255, 0.8) 0%, rgba(0, 200, 255, 0.8) 100%);
            color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.5), inset 0 0 5px rgba(255,255,255,0.2); text-align: center;
        }
        .ui-button:hover { transform: translateY(-2px); box-shadow: 0 0 12px rgba(0, 180, 255, 0.8), inset 0 0 8px rgba(255,255,255,0.3); }
        .ui-button:active { transform: translateY(0); box-shadow: 0 0 5px rgba(0, 123, 255, 0.5), inset 0 0 10px rgba(0,0,0,0.3); }
        #start-pause-button, #toggle-panel-button { margin-top: 10px; }
        
        #top-entities-panel {
            background-color: rgba(10, 10, 15, 0.5); padding: 8px; display: flex; justify-content: center;
            align-items: center; gap: 15px; flex-wrap: wrap; box-shadow: inset 0 2px 10px rgba(0,0,0,0.4);
            border-top: 1px solid rgba(0, 255, 255, 0.1); border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            flex-shrink: 0; width: 100%; box-sizing: border-box;
        }
        .top-entity-group { display: flex; gap: 8px; align-items: center; }
        .top-entity-group strong { font-size: 0.9em; text-shadow: 1px 1px 2px #000; }
        .top-entity-button {
            padding: 5px 10px; font-size: 0.8em; border-radius: 5px; transition: transform 0.1s ease, box-shadow 0.2s ease;
            cursor: pointer; border: 1px solid rgba(255, 255, 255, 0.3); font-weight: bold;
        }
        .top-entity-button:hover { transform: translateY(-1px); }
        .prey-btn { background-color: #0f0; color: #000; box-shadow: 0 0 5px #0f0; }
        .predator-btn { background-color: #f00; color: #fff; box-shadow: 0 0 5px #f00; }
        .hunter-btn { background-color: #f0f; color: #fff; box-shadow: 0 0 5px #f0f; }
        
        #nn-visualization-panel {
            position: fixed; top: 20px; left: 20px; background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 10px; padding: 15px;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.4), 0 0 20px rgba(0, 255, 0, 0.2);
            width: 350px; max-width: 90vw; z-index: 10; display: flex; flex-direction: column; gap: 10px;
            border: 1px solid rgba(0, 255, 0, 0.3); transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(0); opacity: 1;
        }
        #nn-visualization-panel.hidden { transform: translateX(-110%); opacity: 0; pointer-events: none; }
        #nn-visualization-panel h3 { color: #0f0; text-shadow: 0 0 5px #0f0; }
        #toggle-nn-panel-button {
            position: fixed; top: 20px; left: 20px; z-index: 9; opacity: 0;
            transform: translateX(-100%); transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #toggle-nn-panel-button.visible { opacity: 1; transform: translateX(0); }

        #zoom-controls {
            position: fixed; bottom: 20px; right: 20px; background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 10px; padding: 10px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); z-index: 9; display: flex; gap: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3); transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(110%); opacity: 0; pointer-events: none;
        }
        #zoom-controls.visible { transform: translateX(0); opacity: 1; pointer-events: auto; }
        #zoom-controls .ui-button { font-size: 1.5em; padding: 8px 15px; min-width: 45px; line-height: 1; }

        #show-panel-button {
            position: fixed; top: 20px; right: 20px; z-index: 9; background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px; box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); border: 1px solid rgba(0, 255, 255, 0.3);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; transform: translateX(110%);
            opacity: 0; pointer-events: none; padding: 12px 20px;
        }
        #show-panel-button.visible { transform: translateX(0); opacity: 1; pointer-events: auto; }

        #stats-panel {
            position: static; background-color: rgba(15, 5, 25, 0.8); backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px); border-radius: 10px; padding: 15px;
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.4), 0 0 20px rgba(255, 0, 255, 0.2);
            z-index: 1; display: flex; flex-wrap: wrap; justify-content: space-around; gap: 5px 20px;
            border: 1px solid rgba(255, 0, 255, 0.3); font-size: 0.9em; width: calc(100% - 20px);
            max-width: 900px; margin: 10px auto; box-sizing: border-box; flex-shrink: 0;
        }
        #stats-panel div { display: flex; justify-content: space-between; color: #ccc; gap: 10px; }
        #stats-panel strong { color: #fff; text-shadow: 0 0 5px #fff, 0 0 8px rgba(255, 0, 255, 0.7); }
        #game-over-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px); z-index: 20; display: flex; flex-direction: column; justify-content: center;
            align-items: center; color: #fff; text-shadow: 0 0 10px #f00; font-size: 1.2em; text-align: center;
            pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        #game-over-overlay.visible { opacity: 1; pointer-events: auto; }
        #game-over-overlay h1 { color: #f00; font-size: 4em; font-weight: 700; margin-bottom: 20px; text-shadow: 0 0 15px #f00, 0 0 30px #f00, 0 0 50px #f00; }
        #game-over-overlay p { margin: 5px 0; font-size: 1.1em; color: #ccc; }
        #game-over-overlay .final-stats { margin-top: 20px; padding: 20px; background-color: rgba(0, 0, 0, 0.5); border-radius: 8px; box-shadow: 0 0 10px rgba(255, 0, 255, 0.5); max-width: 80%; display: inline-block; border: 1px solid rgba(255, 0, 255, 0.4); }
        #game-over-overlay .final-stats strong { color: #0ff; }
        #game-over-overlay button { margin-top: 30px; padding: 15px 30px; font-size: 1.5em; background-image: linear-gradient(45deg, #00cc00, #00ff00); box-shadow: 0 0 15px rgba(0, 255, 0, 0.7), inset 0 0 5px rgba(255,255,255,0.3); color: #000; font-weight: 700; border: 1px solid rgba(255,255,255,0.4); }
        #game-over-overlay button:hover { box-shadow: 0 0 25px rgba(0, 255, 0, 1), inset 0 0 8px rgba(255,255,255,0.4); }
        #follow-indicator {
            position: absolute; top: 0; left: 0; border: 2px solid rgba(0, 255, 255, 0.8); border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.9), 0 0 20px rgba(0, 255, 255, 0.6);
            pointer-events: none; z-index: 5; transition: width 0.2s ease, height 0.2s ease, transform 0.05s linear, opacity 0.3s ease;
            opacity: 0; will-change: transform, opacity;
        }
        #follow-indicator.visible { opacity: 1; }
        #follow-status {
            position: fixed; bottom: 20px; left: 20px; background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px); border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 8px;
            padding: 8px 15px; z-index: 9; font-size: 0.9em; color: #0ff; text-shadow: 0 0 5px #0ff;
            opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none;
        }
        #follow-status.visible { opacity: 1; transform: translateY(0); }

        @media (max-width: 768px) {
            body { overflow: auto; }
            #ui-panel, #nn-visualization-panel { top: auto; bottom: 10px; left: 10px; right: 10px; max-width: unset; max-height: 40vh; padding: 10px; width: auto; }
            #ui-panel.hidden, #nn-visualization-panel.hidden { transform: translateY(110%); opacity: 0; }
            #nn-visualization-panel { bottom: 50vh; }
            #ui-panel h2 { font-size: 1.2em; margin-bottom: 10px; }
            .ui-button { padding: 10px 15px; font-size: 1em; }
            #zoom-controls { top: 10px; bottom: auto; left: auto; right: 10px; transform: translateX(110%); }
            #zoom-controls.visible { transform: translateX(0); }
            #show-panel-button { top: 70px; right: 10px; }
            #toggle-nn-panel-button { top: 70px; left: 10px; }
            #stats-panel, #top-entities-panel { width: calc(100% - 20px); margin: 10px; padding: 10px; justify-content: flex-start; }
            #game-over-overlay h1 { font-size: 2.5em; }
            #game-over-overlay p { font-size: 1em; }
            #game-over-overlay button { padding: 10px 20px; font-size: 1.2em; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="top-entities-panel">
        <div class="top-entity-group">
            <strong>Prey:</strong>
            <div id="top-prey-list"></div>
        </div>
        <div class="top-entity-group">
            <strong>Predators:</strong>
            <div id="top-predators-list"></div>
        </div>
        <div class="top-entity-group">
            <strong>Hunters:</strong>
            <div id="top-hunters-list"></div>
        </div>
    </div>
    
    <div id="follow-indicator"></div>
    <div id="follow-status"></div>

    <div id="stats-panel">
        <div>Prey: <strong id="preyCount">0</strong></div>
        <div>Predators: <strong id="predatorCount">0</strong></div>
        <div>Hunters: <strong id="hunterCount">0</strong></div>
        <div>Food: <strong id="foodCount">0</strong></div>
        <div>Prey Survival: <strong id="totalPreySurvivalTime">00:00:00</strong></div>
        <div>Predator Survival: <strong id="totalPredatorSurvivalTime">00:00:00</strong></div>
        <div>Hunter Survival: <strong id="totalHunterSurvivalTime">00:00:00</strong></div>
        <div>Births: <strong id="totalBirths">0</strong></div>
        <div>Mutations: <strong id="totalGeneticMutations">0</strong></div>
        <div>Ticks: <strong id="simulationTicks">0</strong></div>
    </div>

    <div id="ui-panel">
        <h2>Ecosystem God Panel</h2>
        <button id="start-pause-button" class="ui-button">Start Simulation</button>
        <button id="toggle-panel-button" class="ui-button">Hide Panel</button>
        
        <!-- NEW: Genetic / NN Controls -->
        <div class="panel-subheader">Genetic Controls</div>
        <div class="param-group">
            <label for="hiddenLayerSize">Brain Complexity: <span id="hiddenLayerSizeValue"></span></label>
            <input type="range" id="hiddenLayerSize" min="4" max="20" step="1">
        </div>
        <div class="param-group">
            <label for="mutationRate">Mutation Rate: <span id="mutationRateValue"></span></label>
            <input type="range" id="mutationRate" min="0.001" max="0.1" step="0.001">
        </div>

        <!-- NEW: Social Behavior Controls -->
        <div class="panel-subheader">Social Behavior</div>
        <div class="param-group">
            <label for="alignmentForce">Alignment: <span id="alignmentForceValue"></span></label>
            <input type="range" id="alignmentForce" min="0" max="2" step="0.1">
        </div>
        <div class="param-group">
            <label for="cohesionForce">Cohesion: <span id="cohesionForceValue"></span></label>
            <input type="range" id="cohesionForce" min="0" max="2" step="0.1">
        </div>
        <div class="param-group">
            <label for="separationForce">Separation: <span id="separationForceValue"></span></label>
            <input type="range" id="separationForce" min="0" max="3" step="0.1">
        </div>
        
        <div class="panel-subheader">World & Population</div>
        <div class="param-group">
            <label for="timeScale">World Speed: <span id="timeScaleValue"></span></label>
            <input type="range" id="timeScale" min="0.1" max="5" step="0.1">
        </div>
        <div class="param-group">
            <label for="foodSpawnRate">Food Spawn Rate: <span id="foodSpawnRateValue"></span></label>
            <input type="range" id="foodSpawnRate" min="0.1" max="2" step="0.1">
        </div>
        <div class="param-group">
            <label for="foodEnergy">Food Energy: <span id="foodEnergyValue"></span></label>
            <input type="range" id="foodEnergy" min="10" max="200" step="5">
        </div>
        <div class="param-group">
            <label for="preyTargetPopulation">Prey Target Pop: <span id="preyTargetPopulationValue"></span></label>
            <input type="range" id="preyTargetPopulation" min="50" max="500" step="10">
        </div>
        <div class="param-group">
            <label for="predatorTargetPopulation">Predator Target Pop: <span id="predatorTargetPopulationValue"></span></label>
            <input type="range" id="predatorTargetPopulation" min="10" max="100" step="5">
        </div>
        <div class="param-group">
            <label for="hunterTargetPopulation">Hunter Target Pop: <span id="hunterTargetPopulationValue"></span></label>
            <input type="range" id="hunterTargetPopulation" min="0" max="50" step="5">
        </div>
    </div>
    
    <div id="nn-visualization-panel">
        <h3>Genetic Improvement (Avg. Age)</h3>
        <canvas id="nnChartCanvas"></canvas>
        <button id="hide-nn-panel-button" class="ui-button">Hide Chart</button>
    </div>
    <button id="toggle-nn-panel-button" class="ui-button">Show Chart</button>

    <div id="zoom-controls">
        <button id="zoom-in-button" class="ui-button">+</button>
        <button id="zoom-out-button" class="ui-button">-</button>
    </div>

    <button id="show-panel-button" class="ui-button">Show Panel</button>

    <div id="game-over-overlay">
        <h1>GAME OVER</h1>
        <p>Prey population has gone extinct!</p>
        <div class="final-stats">
            <p>Total Ticks: <strong><span id="finalTicks">0</span></strong></p>
            <p>Total Prey Survival Ticks: <strong><span id="finalPreySurvival">0</span></strong></p>
            <p>Total Predator Survival Ticks: <strong><span id="finalPredatorSurvival">0</span></strong></p>
            <p>Total Hunter Survival Ticks: <strong><span id="finalHunterSurvival">0</span></strong></p>
            <p>Total Births: <strong><span id="finalBirths">0</span></strong></p>
            <p>Total Mutations: <strong><span id="finalMutations">0</span></strong></p>
        </div>
        <button id="restart-game-button" class="ui-button">Restart Simulation</button>
    </div>

    <script>
        // --- Game Configuration and Global Variables ---
        const config = {
            worldWidth: 2000, worldHeight: 1500, tileSize: 32,
            biomeColors: { water: 'hsl(200, 70%, 25%)', forest: 'hsl(80, 50%, 20%)', desert: 'hsl(40, 60%, 40%)' },
            noise: { scale: 0.005, octaves: 4, persistence: 0.5, waterLevel: -0.3, forestLevel: 0.2, waterBiasStrength: 0.5 },
            
            timeScale: 1.0, zoomLevel: 1.0,
            foodSpawnRate: 0.5, foodEnergy: 50,
            preyTargetPopulation: 200, predatorTargetPopulation: 50, hunterTargetPopulation: 10,
            
            // NEW: Genetic & Social Behavior Controls
            hiddenLayerSize: 10,        // Number of neurons in the NN hidden layer. Affects new creatures.
            mutationRate: 0.01,         
            mutationColorRange: 20,     
            alignmentForce: 1.0,        // Strength of steering towards neighbors' average heading
            cohesionForce: 0.8,         // Strength of steering towards neighbors' average position
            separationForce: 1.5,       // Strength of steering away from very close neighbors
            separationDistance: 20,     // The radius within which creatures will actively avoid each other
            
            // MODIFIED: Creature stats for slower pacing
            creatureSize: 8,
            preyMaxHealth: 100, predatorMaxHealth: 150, hunterMaxHealth: 200,
            
            // MODIFIED: Reproduction thresholds increased significantly to slow down breeding
            preyReproductionThreshold: 95, 
            predatorReproductionThreshold: 140,
            hunterReproductionThreshold: 180,
            
            // MODIFIED: Energy consumption reduced by ~33% to slow down death rate
            preyEnergyConsumption: 0.07,
            predatorEnergyConsumption: 0.12,
            hunterEnergyConsumption: 0.18,
            
            // MODIFIED: Reproduction cost increased to make breeding a bigger investment
            reproductionCost: 75,
            
            visionRange: 150, // General vision range used for social behaviors
            
            quadtreeCapacity: 4, maxEntities: 1000
        };

        let canvas, ctx, simulationPaused = true, lastFrameTime = 0, entities = [], quadtree, entityIdCounter = 0;
        let cameraX = 0, cameraY = 0, isDragging = false, lastMouseX = 0, lastMouseY = 0;
        let followedEntity = null, targetZoom = 1.0, targetCameraX = 0, targetCameraY = 0;
        const CAMERA_LERP_SPEED = 0.08;
        let nnChart, chartLabels = [], avgPreyAgeData = [], avgPredatorAgeData = [], avgHunterAgeData = [];
        const CHART_UPDATE_INTERVAL = 120, MAX_CHART_POINTS = 100;
        let currentPreyCount = 0, currentPredatorCount = 0, currentHunterCount = 0, currentFoodCount = 0;
        let totalPreySurvivalTicks = 0, totalPredatorSurvivalTicks = 0, totalHunterSurvivalTicks = 0;
        let totalBirths = 0, totalGeneticMutations = 0, simulationTicks = 0, gameOver = false;
        
        // --- Perlin Noise, Utility, and other classes are minified for brevity ---
        // --- They are functionally identical to the previous version ---
        const P = new Array(512); const permutation = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,178,243,109,86,242,102,220,83,208,82,60,204,244,196,174,251,193,249,173,192,205,124,150,89,147,48,206,231,38,1,101,163,179,113,228,207,209,17,9,47,61,106,73,202,238,145,155,186,171,154,210,100,211,166,20,230,24,64,104,16,246,250,116,218,114,63,76,181,28,200,12,66,105,107,59,18,65,110,253,254,255,127,199,198,164,180,74,201,141,123,97,25,126,134,138,111,175,98,187,189,248,115,55,135,212,125,146,161,162,176,168,144,226,143,188,93,14,133,121,167,46,108,169,130,172,165,136,191,213,232,156,239,170,39,183,119,112,100,52,29,19,132,122,227,27,253,139,67,100,34,81,185,100,217,215,221,80,214,245,68,2,78,140,241,70,10,235,172,50,49,159,157,177,44,153,195,129,58,77,222,174,182,184,236,195,216,224,197];
        function fade(t) { return t*t*t*(t*(t*6-15)+10); } function lerp(t,a,b){return a+t*(b-a);} function grad(h,x,y){const u=h<8?x:y,v=h<4?y:h===12||h===14?x:0;return((h&1)===0?u:-u)+((h&2)===0?v:-v);}
        class PerlinNoise { constructor(s=Date.now()){this.seed=s;this._initPermutation();} _initPermutation(){for(let i=0;i<256;i++)P[i]=P[i+256]=permutation[i];let c=this.seed;function r(){c=(c*9301+49297)%233280;return c/233280;}for(let i=0;i<256;i++){const j=Math.floor(r()*256);[P[i],P[j]]=[P[j],P[i]];P[i+256]=P[i];P[j+256]=P[j];}} noise(x,y){const X=Math.floor(x)&255,Y=Math.floor(y)&255;x-=Math.floor(x);y-=Math.floor(y);const u=fade(x),v=fade(y),A=P[X]+Y,AA=P[A],AB=P[A+1],B=P[X+1]+Y,BA=P[B],BB=P[B+1];return lerp(v,lerp(u,grad(P[AA],x,y),grad(P[BA],x-1,y)),lerp(u,grad(P[AB],x,y-1),grad(P[BB],x-1,y-1)));}}
        let perlinNoise; function getLayeredNoise(x,y){let t=0,f=config.noise.scale,a=1,m=0;for(let i=0;i<config.noise.octaves;i++){t+=perlinNoise.noise(x*f,y*f)*a;m+=a;a*=config.noise.persistence;f*=2;}return t/m;}
        class Vector { constructor(x=0,y=0){this.x=x;this.y=y} add(o){return new Vector(this.x+o.x,this.y+o.y)} sub(o){return new Vector(this.x-o.x,this.y-o.y)} mult(s){return new Vector(this.x*s,this.y*s)} div(s){return new Vector(this.x/s,this.y/s)} mag(){return Math.sqrt(this.x*this.x+this.y*this.y)} normalize(){const m=this.mag();return m>0?this.div(m):new Vector(0,0)} setMag(m){return this.normalize().mult(m)} limit(m){if(this.mag()>m){return this.setMag(m)} return this} dist(o){return this.sub(o).mag()} angle(){return Math.atan2(this.y,this.x)} static random2D(){const a=Math.random()*Math.PI*2;return new Vector(Math.cos(a),Math.sin(a))} copy(){return new Vector(this.x,this.y)} }
        class Rectangle { constructor(x,y,w,h){this.x=x;this.y=y;this.w=w;this.h=h} contains(p){return(p.x>=this.x-this.w&&p.x<=this.x+this.w&&p.y>=this.y-this.h&&p.y<=this.y+this.h)} intersects(r){return!(r.x-r.w>this.x+this.w||r.x+r.w<this.x-this.w||r.y-r.h>this.y+this.h||r.y+r.h<this.y-this.h)} }
        class QuadTree { constructor(b,c){this.boundary=b;this.capacity=c;this.entities=[];this.divided=!1} subdivide(){let x=this.boundary.x,y=this.boundary.y,w=this.boundary.w/2,h=this.boundary.h/2;this.northeast=new QuadTree(new Rectangle(x+w,y-h,w,h),this.capacity);this.northwest=new QuadTree(new Rectangle(x-w,y-h,w,h),this.capacity);this.southeast=new QuadTree(new Rectangle(x+w,y+h,w,h),this.capacity);this.southwest=new QuadTree(new Rectangle(x-w,y+h,w,h),this.capacity);this.divided=!0;for(let e of this.entities){this.insert(e)} this.entities=[]} insert(e){return this.boundary.contains(e.position)?this.entities.length<this.capacity&&!this.divided?(this.entities.push(e),!0):(!this.divided&&this.subdivide(),!this.northeast.insert(e)&&!this.northwest.insert(e)&&!this.southeast.insert(e)&&!this.southwest.insert(e)?!1:!0):!1} query(r,f=[]){if(!this.boundary.intersects(r)){return f} for(let e of this.entities){r.contains(e.position)&&f.push(e)} return this.divided&&(this.northwest.query(r,f),this.northeast.query(r,f),this.southwest.query(r,f),this.southeast.query(r,f)),f} clear(){this.entities=[];this.divided=!1;this.northeast=null;this.northwest=null;this.southeast=null;this.southwest=null} }
        
        // MODIFIED: NeuralNetwork class now reads hidden layer size from config
        class NeuralNetwork {
            static INPUT_SIZE = 1 + (2 * 5); // Health + 5 types (dist, angle)
            static OUTPUT_SIZE = 2;

            constructor(...layerSizes) {
                this.layerSizes = layerSizes.length ? layerSizes : [NeuralNetwork.INPUT_SIZE, config.hiddenLayerSize, NeuralNetwork.OUTPUT_SIZE];
                this.weights = [];
                this.biases = [];
                for (let i = 0; i < this.layerSizes.length - 1; i++) {
                    const rows = this.layerSizes[i + 1], cols = this.layerSizes[i];
                    this.weights.push(Array.from({ length: rows }, () => Array.from({ length: cols }, () => Math.random() * 2 - 1)));
                    this.biases.push(Array.from({ length: rows }, () => Math.random() * 2 - 1));
                }
            }
            static tanh(x){return Math.tanh(x);}
            feedForward(inputs){if(inputs.length!==this.layerSizes[0]){console.error(`Input size mismatch. Expected ${this.layerSizes[0]}, got ${inputs.length}.`);const p=inputs.slice(0,this.layerSizes[0]);while(p.length<this.layerSizes[0])p.push(0);inputs=p;} let c=inputs;for(let i=0;i<this.weights.length;i++){const n=[],w=this.weights[i],b=this.biases[i];for(let r=0;r<w.length;r++){let s=0;for(let l=0;l<w[r].length;l++)s+=c[l]*w[r][l];n.push(NeuralNetwork.tanh(s+b[r]));}c=n;}return c;}
            copy(){const n=new NeuralNetwork(...this.layerSizes);n.weights=this.weights.map(m=>m.map(r=>[...r]));n.biases=this.biases.map(b=>[...b]);return n;}
            mutate(rate){let m=0;for(let i=0;i<this.weights.length;i++)for(let r=0;r<this.weights[i].length;r++)for(let c=0;c<this.weights[i][r].length;c++)if(Math.random()<rate){this.weights[i][r][c]+=(Math.random()*2-1)*0.5;m++;}for(let i=0;i<this.biases.length;i++)for(let r=0;r<this.biases[i].length;r++)if(Math.random()<rate){this.biases[i][r]+=(Math.random()*2-1)*0.5;m++;}return m;}
            static crossover(n1,n2){if(n1.layerSizes.join('-')!==n2.layerSizes.join('-'))throw new Error("Cannot crossover NNs with different architectures.");const c=new NeuralNetwork(...n1.layerSizes);for(let i=0;i<n1.weights.length;i++){const r=Math.floor(Math.random()*n1.weights[i].length),l=Math.floor(Math.random()*n1.weights[i][0].length);for(let o=0;o<n1.weights[i].length;o++)for(let s=0;s<n1.weights[i][o].length;s++)c.weights[i][o][s]=o<r||o===r&&s<l?n1.weights[i][o][s]:n2.weights[i][o][s];}for(let i=0;i<n1.biases.length;i++){const r=Math.floor(Math.random()*n1.biases[i].length);for(let o=0;o<n1.biases[i].length;o++)c.biases[i][o]=o<r?n1.biases[i][o]:n2.biases[i][o];}return c;}
        }

        class Entity { constructor(x,y,c,s,w){this.position=new Vector(x,y);this.color=c;this.size=s;this.world=w;this.id=entityIdCounter++;this.isDead=!1;this.trail=[];this.maxTrailLength=5} update(){this.trail.unshift(this.position.copy());this.trail.length>this.maxTrailLength&&this.trail.pop()} draw(ctx){} }
        
        // MODIFIED: Creature class now includes flocking behavior
        class Creature extends Entity {
            constructor(x, y, color, size, world, nn, maxHealth, reproductionThreshold, energyConsumption, maxSpeed) {
                super(x, y, color, size, world);
                this.velocity = Vector.random2D().setMag(Math.random() * maxSpeed);
                this.acceleration = new Vector(0, 0);
                this.maxSpeed = maxSpeed;
                this.maxHealth = maxHealth;
                this.health = maxHealth;
                this.reproductionThreshold = reproductionThreshold;
                this.energyConsumption = energyConsumption;
                this.nn = nn;
                this.visionRange = config.visionRange;
                this.age = 0;
            }

            _addNormalizedInputs(inputs,{entity,dist}){if(entity){inputs.push(dist/this.visionRange);let a=entity.position.sub(this.position).angle(),r=a-this.velocity.angle();r=Math.atan2(Math.sin(r),Math.cos(r));inputs.push(r/Math.PI)}else{inputs.push(1);inputs.push(0)}}
            
            // NEW: Calculates flocking forces (alignment, cohesion, separation)
            calculateFlocking(neighbors) {
                let alignmentSum = new Vector(0, 0);
                let cohesionSum = new Vector(0, 0);
                let separationSum = new Vector(0, 0);
                let a_count = 0, c_count = 0, s_count = 0;

                for (const other of neighbors) {
                    if (other.id === this.id) continue;
                    let d = this.position.dist(other.position);

                    // Alignment & Cohesion (all neighbors in vision range)
                    if (d > 0 && d < this.visionRange) {
                        alignmentSum = alignmentSum.add(other.velocity);
                        a_count++;
                        cohesionSum = cohesionSum.add(other.position);
                        c_count++;
                    }
                    // Separation (only very close neighbors)
                    if (d > 0 && d < config.separationDistance) {
                        let diff = this.position.sub(other.position);
                        diff = diff.normalize().div(d); // Weight by distance
                        separationSum = separationSum.add(diff);
                        s_count++;
                    }
                }

                let steer = new Vector(0,0);
                if (a_count > 0) {
                    alignmentSum = alignmentSum.div(a_count).normalize().mult(this.maxSpeed);
                    let alignmentSteer = alignmentSum.sub(this.velocity).limit(0.2);
                    steer = steer.add(alignmentSteer.mult(config.alignmentForce));
                }
                if (c_count > 0) {
                    cohesionSum = cohesionSum.div(c_count);
                    let desired = cohesionSum.sub(this.position).normalize().mult(this.maxSpeed);
                    let cohesionSteer = desired.sub(this.velocity).limit(0.1);
                    steer = steer.add(cohesionSteer.mult(config.cohesionForce));
                }
                if (s_count > 0) {
                    separationSum = separationSum.div(s_count).normalize().mult(this.maxSpeed);
                    let separationSteer = separationSum.sub(this.velocity).limit(0.3);
                    steer = steer.add(separationSteer.mult(config.separationForce));
                }
                return steer;
            }

            think(nearbyEntities) {
                // Goal-seeking with NN
                let closestFood={e:null,d:Infinity},closestPrey={e:null,d:Infinity},closestPredator={e:null,d:Infinity},closestHunter={e:null,d:Infinity},closestMate={e:null,d:Infinity};
                for(let e of nearbyEntities){if(e.id===this.id||e.isDead)continue;const d=this.position.dist(e.position);if(d<this.visionRange){if(e instanceof Food){d<closestFood.d&&(closestFood={entity:e,dist:d})}else if(this instanceof Prey){if(e instanceof Predator&&d<closestPredator.d)closestPredator={entity:e,dist:d};if(e instanceof Hunter&&d<closestHunter.d)closestHunter={entity:e,dist:d};}else if(this instanceof Predator){if(e instanceof Prey&&d<closestPrey.d)closestPrey={entity:e,dist:d};if(e instanceof Hunter&&d<closestHunter.d)closestHunter={entity:e,dist:d};}else if(this instanceof Hunter){if(e instanceof Prey&&d<closestPrey.d)closestPrey={entity:e,dist:d};if(e instanceof Predator&&d<closestPredator.d)closestPredator={entity:e,dist:d};} if(this.constructor===e.constructor&&e.health>e.reproductionThreshold*0.8&&d<closestMate.d)closestMate={entity:e,dist:d};}}
                const inputs=[];inputs.push(this.health/this.maxHealth);
                if(this instanceof Prey){ this._addNormalizedInputs(inputs, closestFood); this._addNormalizedInputs(inputs, {entity: null, dist: Infinity}); this._addNormalizedInputs(inputs, closestPredator); this._addNormalizedInputs(inputs, closestHunter); this._addNormalizedInputs(inputs, closestMate); }
                else if(this instanceof Predator){ this._addNormalizedInputs(inputs, {entity: null, dist: Infinity}); this._addNormalizedInputs(inputs, closestPrey); this._addNormalizedInputs(inputs, {entity: null, dist: Infinity}); this._addNormalizedInputs(inputs, closestHunter); this._addNormalizedInputs(inputs, closestMate); }
                else if(this instanceof Hunter){ this._addNormalizedInputs(inputs, closestFood); this._addNormalizedInputs(inputs, closestPrey); this._addNormalizedInputs(inputs, closestPredator); this._addNormalizedInputs(inputs, {entity: null, dist: Infinity}); this._addNormalizedInputs(inputs, closestMate); }
                
                const outputs=this.nn.feedForward(inputs),accelerationMag=(outputs[0]+1)/2,turnStrength=outputs[1];
                const currentHeading=this.velocity.angle(),desiredHeading=currentHeading+turnStrength*(Math.PI/8);
                const nnAcceleration = new Vector(Math.cos(desiredHeading),Math.sin(desiredHeading)).setMag(accelerationMag*0.2);

                // Flocking Behavior
                const allies = nearbyEntities.filter(e => e.constructor === this.constructor);
                const flockingForce = this.calculateFlocking(allies);

                // Combine forces
                this.acceleration = this.acceleration.add(nnAcceleration).add(flockingForce);
            }

            move(){this.velocity=this.velocity.add(this.acceleration).limit(this.maxSpeed);this.position=this.position.add(this.velocity.mult(config.timeScale));this.acceleration=new Vector(0,0);if(this.position.x<0)this.position.x=this.world.width;if(this.position.x>this.world.width)this.position.x=0;if(this.position.y<0)this.position.y=this.world.height;if(this.position.y>this.world.height)this.position.y=0;}
            updateHealth(){this.health-=this.energyConsumption*config.timeScale;if(this.health<=0)this.isDead=true;}
            reproduce(mateNN=null){if(this.health>=this.reproductionThreshold){const childNN=mateNN?NeuralNetwork.crossover(this.nn,mateNN):this.nn.copy(),mutations=childNN.mutate(config.mutationRate);totalGeneticMutations+=mutations;let childColor=this.color;if(mutations>0){childColor=(this.color+(Math.random()*2*config.mutationColorRange-config.mutationColorRange));childColor=(childColor%360+360)%360;} const offset=Vector.random2D().mult(this.size*2),child=new(this.constructor)(this.position.x+offset.x,this.position.y+offset.y,this.world,childNN,childColor);this.health-=config.reproductionCost;totalBirths++;return child;}return null;}
            eat(target,energy){this.health+=energy;this.health=Math.min(this.health,this.maxHealth);target.isDead=true;}
            
            update(){
                super.update(); this.age+=config.timeScale; this.updateHealth(); if(this.isDead)return;
                const searchRange=new Rectangle(this.position.x,this.position.y,this.visionRange/2,this.visionRange/2),nearby=quadtree.query(searchRange);
                for(let e of nearby){if(e.id===this.id||e.isDead)continue;const d=this.position.dist(e.position);if(d<this.size/2+e.size/2){if(this instanceof Prey&&e instanceof Food)this.eat(e,config.foodEnergy);else if(this instanceof Predator&&e instanceof Prey)this.eat(e,e.maxHealth*0.5);else if(this instanceof Hunter){if(e instanceof Prey)this.eat(e,e.maxHealth*0.75);else if(e instanceof Predator)this.eat(e,e.maxHealth*1.0)}}}
                this.think(nearby); this.move();
                if(this.health>=this.reproductionThreshold){const mate=nearby.find(e=>e.constructor===this.constructor&&e.id!==this.id&&!e.isDead&&e.health>e.reproductionThreshold*0.8&&this.position.dist(e.position)<this.size*2);if(mate){const child=this.reproduce(mate.nn);if(child&&entities.length<config.maxEntities)entities.push(child);}}
            }
            draw(ctx){const h=this.health/this.maxHealth,b=Math.max(0.2,Math.min(1.0,h*1.2)),a=Math.max(0.1,Math.min(0.8,h*0.7+0.1));if(this.trail.length>0){ctx.beginPath();ctx.moveTo(this.position.x,this.position.y);for(let i=0;i<this.trail.length;i++){const p=this.trail[i],s=a*(1-i/this.maxTrailLength);ctx.strokeStyle=`hsla(${this.color}, 100%, 50%, ${s})`;ctx.lineWidth=this.size*(1-i/this.maxTrailLength)/2;ctx.lineTo(p.x,p.y)} ctx.stroke()} ctx.shadowBlur=this.size*1.5;ctx.shadowColor=`hsla(${this.color}, 100%, 50%, ${a})`;ctx.fillStyle=`hsla(${this.color}, 100%, ${b*100}%, ${a})`;ctx.beginPath();if(this instanceof Prey){ctx.arc(this.position.x,this.position.y,this.size/2,0,Math.PI*2)}else if(this instanceof Predator){const an=this.velocity.angle(),tX=this.position.x+Math.cos(an)*this.size/2,tY=this.position.y+Math.sin(an)*this.size/2,bA1=an+2*Math.PI/3,bA2=an-2*Math.PI/3,bX1=this.position.x+Math.cos(bA1)*this.size/2,bY1=this.position.y+Math.sin(bA1)*this.size/2,bX2=this.position.x+Math.cos(bA2)*this.size/2,bY2=this.position.y+Math.sin(bA2)*this.size/2;ctx.moveTo(tX,tY);ctx.lineTo(bX1,bY1);ctx.lineTo(bX2,bY2);ctx.closePath()}else if(this instanceof Hunter){const an=this.velocity.angle(),hS=this.size*0.7,s2=Math.sqrt(2),p1=new Vector(this.position.x+Math.cos(an)*hS*s2,this.position.y+Math.sin(an)*hS*s2),p2=new Vector(this.position.x+Math.cos(an+Math.PI/2)*hS,this.position.y+Math.sin(an+Math.PI/2)*hS),p3=new Vector(this.position.x+Math.cos(an+Math.PI)*hS*s2,this.position.y+Math.sin(an+Math.PI)*hS*s2),p4=new Vector(this.position.x+Math.cos(an-Math.PI/2)*hS,this.position.y+Math.sin(an-Math.PI/2)*hS);ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);ctx.lineTo(p3.x,p3.y);ctx.lineTo(p4.x,p4.y);ctx.closePath()} ctx.fill();ctx.shadowBlur=0;ctx.shadowColor='transparent';ctx.lineWidth=1}
        }

        class Prey extends Creature { constructor(x,y,w,nn=null,c=120){super(x,y,c,config.creatureSize,w,nn||new NeuralNetwork(),config.preyMaxHealth,config.preyReproductionThreshold,config.preyEnergyConsumption,3.5);}}
        class Predator extends Creature { constructor(x,y,w,nn=null,c=0){super(x,y,c,config.creatureSize+2,w,nn||new NeuralNetwork(),config.predatorMaxHealth,config.predatorReproductionThreshold,config.predatorEnergyConsumption,4.0);}}
        class Hunter extends Creature { constructor(x,y,w,nn=null,c=280){super(x,y,c,config.creatureSize+4,w,nn||new NeuralNetwork(),config.hunterMaxHealth,config.hunterReproductionThreshold,config.hunterEnergyConsumption,4.5);}}
        class Food extends Entity { constructor(x,y,w){const h=240,s=config.creatureSize/2+(Math.random()*2-1)*(config.creatureSize/8);super(x,y,h,s,w)} draw(ctx){ctx.shadowBlur=this.size*2;ctx.shadowColor=`hsla(${this.color}, 100%, 70%, 0.5)`;ctx.fillStyle=`hsla(${this.color}, 100%, 80%, 0.8)`;ctx.beginPath();ctx.arc(this.position.x,this.position.y,this.size/2,0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;ctx.shadowColor='transparent'} }

        // --- All management, UI, and drawing functions are functionally identical but minified for brevity ---
        // --- except for the addition of the new sliders in setupUI ---
        function formatTime(t){const s=Math.floor(t/60),h=Math.floor(s/3600),m=Math.floor((s%3600)/60),c=s%60,p=n=>String(n).padStart(2,'0');return`${p(h)}:${p(m)}:${p(c)}`}
        function initSimulation(){canvas=document.getElementById('gameCanvas');ctx=canvas.getContext('2d');perlinNoise=new PerlinNoise(Date.now());setupUI();resizeCanvas();window.addEventListener('resize',resizeCanvas);const b=new Rectangle(config.worldWidth/2,config.worldHeight/2,config.worldWidth/2,config.worldHeight/2);quadtree=new QuadTree(b,config.quadtreeCapacity);setupCanvasEvents();generateInitialPopulation();initNNChart();drawSimulation();}
        function handleEntityClick(e){const r=canvas.getBoundingClientRect(),cX=e.clientX-r.left,cY=e.clientY-r.top,wX=(cX/config.zoomLevel)+cameraX,wY=(cY/config.zoomLevel)+cameraY,cP=new Vector(wX,wY);let cE=null,mD=Infinity;const sR=50/config.zoomLevel,sA=new Rectangle(wX,wY,sR,sR),nE=quadtree.query(sA);for(const E of nE){if(E instanceof Food)continue;const d=cP.dist(E.position);if(d<E.size*1.5&&d<mD){mD=d;cE=E;}} if(cE){if(followedEntity===cE)followedEntity=null;else{followedEntity=cE;targetZoom=1.8;}}else{followedEntity=null;}}
        function setupCanvasEvents(){let d=!1;canvas.addEventListener('mousedown',e=>{if(e.button===0){isDragging=!0;d=!1;lastMouseX=e.clientX;lastMouseY=e.clientY;if(!followedEntity)canvas.classList.add('dragging');}});canvas.addEventListener('mousemove',e=>{if(isDragging){const x=e.clientX-lastMouseX,y=e.clientY-lastMouseY;if(Math.abs(x)>3||Math.abs(y)>3)d=!0;if(!followedEntity){targetCameraX-=x/config.zoomLevel;targetCameraY-=y/config.zoomLevel;lastMouseX=e.clientX;lastMouseY=e.clientY;}}});canvas.addEventListener('mouseup',e=>{if(e.button===0){if(!d)handleEntityClick(e);isDragging=!1;canvas.classList.remove('dragging');}});canvas.addEventListener('mouseleave',()=>{isDragging=!1;canvas.classList.remove('dragging');});canvas.addEventListener('touchstart',e=>{if(e.touches.length===1){isDragging=!0;d=!1;lastMouseX=e.touches[0].clientX;lastMouseY=e.touches[0].clientY;if(!followedEntity)canvas.classList.add('dragging');}},{passive:!0});canvas.addEventListener('touchmove',e=>{if(isDragging&&e.touches.length===1){const x=e.touches[0].clientX-lastMouseX,y=e.touches[0].clientY-lastMouseY;if(Math.abs(x)>5||Math.abs(y)>5)d=!0;if(!followedEntity){targetCameraX-=x/config.zoomLevel;targetCameraY-=y/config.zoomLevel;lastMouseX=e.touches[0].clientX;lastMouseY=e.touches[0].clientY;}}},{passive:!0});canvas.addEventListener('touchend',e=>{if(!d&&e.changedTouches.length>0)handleEntityClick(e.changedTouches[0]);isDragging=!1;canvas.classList.remove('dragging');});canvas.addEventListener('contextmenu',e=>e.preventDefault());}
        function updateCamera(){if(followedEntity){if(followedEntity.isDead)followedEntity=null;else{targetCameraX=followedEntity.position.x-(canvas.width/targetZoom/2);targetCameraY=followedEntity.position.y-(canvas.height/targetZoom/2);}} config.zoomLevel+=(targetZoom-config.zoomLevel)*CAMERA_LERP_SPEED;cameraX+=(targetCameraX-cameraX)*CAMERA_LERP_SPEED;cameraY+=(targetCameraY-cameraY)*CAMERA_LERP_SPEED;clampCamera();}
        function clampCamera(){const w=canvas.width/config.zoomLevel,h=canvas.height/config.zoomLevel,mX=config.worldWidth-w,mY=config.worldHeight-h;targetCameraX=Math.max(0,Math.min(targetCameraX,mX<0?0:mX));targetCameraY=Math.max(0,Math.min(targetCameraY,mY<0?0:mY));cameraX=Math.max(0,Math.min(cameraX,mX<0?0:mX));cameraY=Math.max(0,Math.min(cameraY,mY<0?0:mY));}
        function generateInitialPopulation(){entities=[];totalBirths=0;totalGeneticMutations=0;simulationTicks=0;totalPreySurvivalTicks=0;totalPredatorSurvivalTicks=0;totalHunterSurvivalTicks=0;gameOver=!1;followedEntity=null;chartLabels=[];avgPreyAgeData=[];avgPredatorAgeData=[];avgHunterAgeData=[];if(nnChart)nnChart.update();const fZE=config.worldWidth*0.4;for(let i=0;i<config.preyTargetPopulation;i++)entities.push(new Prey(Math.random()*fZE,Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));const cSMX=config.worldWidth*0.2,cSMaX=config.worldWidth*0.8;for(let i=0;i<config.predatorTargetPopulation;i++)entities.push(new Predator(cSMX+Math.random()*(cSMaX-cSMX),Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));const hSMX=config.worldWidth*0.4,hSMaX=config.worldWidth*0.6;for(let i=0;i<config.hunterTargetPopulation;i++)entities.push(new Hunter(hSMX+Math.random()*(hSMaX-hSMX),Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));for(let i=0;i<config.preyTargetPopulation*2;i++)entities.push(new Food(Math.random()*fZE,Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));updateEntityCounts();}
        function updateSimulation(){if(simulationPaused||gameOver)return;simulationTicks++;quadtree.clear();for(let e of entities)if(!e.isDead)quadtree.insert(e);let nE=[];for(let e of entities){if(!e.isDead){if(e instanceof Prey)totalPreySurvivalTicks+=config.timeScale;else if(e instanceof Predator)totalPredatorSurvivalTicks+=config.timeScale;else if(e instanceof Hunter)totalHunterSurvivalTicks+=config.timeScale;e.update();if(!e.isDead)nE.push(e);}}entities=nE;updateEntityCounts();if(simulationTicks%60===0)updateTopEntitiesPanel();if(simulationTicks%CHART_UPDATE_INTERVAL===0)updateNNChartData();if(currentPreyCount===0&&!gameOver){endGame();return;} const fZE=config.worldWidth*0.4,pDS=config.worldWidth*0.6,hSMX=config.worldWidth*0.4,hSMaX=config.worldWidth*0.6;if(Math.random()<config.foodSpawnRate*config.timeScale&&entities.length<config.maxEntities)entities.push(new Food(Math.random()*fZE,Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));if(currentPreyCount<config.preyTargetPopulation&&entities.length<config.maxEntities)entities.push(new Prey(Math.random()*fZE,Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));if(currentPredatorCount<config.predatorTargetPopulation&&entities.length<config.maxEntities)entities.push(new Predator(pDS+Math.random()*(config.worldWidth-pDS),Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));if(currentHunterCount<config.hunterTargetPopulation&&entities.length<config.maxEntities)entities.push(new Hunter(hSMX+Math.random()*(hSMaX-hSMX),Math.random()*config.worldHeight,{width:config.worldWidth,height:config.worldHeight}));}
        function updateTopEntitiesPanel(){const lists={'prey':{entities:[],container:document.getElementById('top-prey-list'),class:'prey-btn'},'predators':{entities:[],container:document.getElementById('top-predators-list'),class:'predator-btn'},'hunters':{entities:[],container:document.getElementById('top-hunters-list'),class:'hunter-btn'}};for(const e of entities){if(e instanceof Prey)lists.prey.entities.push(e);else if(e instanceof Predator)lists.predators.entities.push(e);else if(e instanceof Hunter)lists.hunters.entities.push(e);} for(const k in lists){const l=lists[k],t=l.entities.sort((a,b)=>b.age-a.age).slice(0,3);l.container.innerHTML='';if(t.length===0)l.container.textContent="None";else t.forEach(e=>{const b=document.createElement('button');b.className=`top-entity-button ${l.class}`;b.textContent=`#${e.id} (Age: ${Math.floor(e.age/60)})`;b.title=`Click to follow ${e.constructor.name} #${e.id}`;b.addEventListener('click',()=>{followedEntity=e;targetZoom=1.8;});l.container.appendChild(b);});}}
        function updateNNChartData(){if(!nnChart)return;let pA=0,rA=0,hA=0;entities.forEach(e=>{if(e instanceof Prey)pA+=e.age;else if(e instanceof Predator)rA+=e.age;else if(e instanceof Hunter)hA+=e.age;});const aP=currentPreyCount>0?(pA/currentPreyCount)/60:0,aR=currentPredatorCount>0?(rA/currentPredatorCount)/60:0,aH=currentHunterCount>0?(hA/currentHunterCount)/60:0;chartLabels.push(simulationTicks);avgPreyAgeData.push(aP);avgPredatorAgeData.push(aR);avgHunterAgeData.push(aH);if(chartLabels.length>MAX_CHART_POINTS){chartLabels.shift();avgPreyAgeData.shift();avgPredatorAgeData.shift();avgHunterAgeData.shift();}nnChart.update('none');}
        function updateEntityCounts(){currentPreyCount=0;currentPredatorCount=0;currentHunterCount=0;currentFoodCount=0;for(const e of entities){if(e instanceof Prey)currentPreyCount++;else if(e instanceof Predator)currentPredatorCount++;else if(e instanceof Hunter)currentHunterCount++;else if(e instanceof Food)currentFoodCount++;}}
        function endGame(){simulationPaused=!0;gameOver=!0;document.getElementById('start-pause-button').textContent='Restart Simulation';displayGameOverStats();}
        function displayGameOverStats(){const o=document.getElementById('game-over-overlay');o.querySelector('#finalTicks').textContent=simulationTicks;o.querySelector('#finalPreySurvival').textContent=formatTime(totalPreySurvivalTicks);o.querySelector('#finalPredatorSurvival').textContent=formatTime(totalPredatorSurvivalTicks);o.querySelector('#finalHunterSurvival').textContent=formatTime(totalHunterSurvivalTicks);o.querySelector('#finalBirths').textContent=totalBirths;o.querySelector('#finalMutations').textContent=totalGeneticMutations;o.classList.add('visible');}
        function hideGameOverStats(){document.getElementById('game-over-overlay').classList.remove('visible');}
        function drawLandscape(ctx){const t=config.tileSize,wX=cameraX,wY=cameraY,wW=canvas.width/config.zoomLevel,wH=canvas.height/config.zoomLevel,sX=Math.floor(wX/t),eX=Math.ceil((wX+wW)/t),sY=Math.floor(wY/t),eY=Math.ceil((wY+wH)/t);for(let x=sX;x<eX;x++)for(let y=sY;y<eY;y++){const wx=x*t,wy=y*t;if(wx>=config.worldWidth||wy>=config.worldHeight||wx<0||wy<0)continue;let h=getLayeredNoise(wx,wy);const d=Math.sqrt(Math.pow(wx+t/2-config.worldWidth/2,2)+Math.pow(wy+t/2-config.worldHeight/2,2)),r=Math.min(config.worldWidth,config.worldHeight)*0.3;if(d<r){let b=1-d/r;h+=fade(b)*-config.noise.waterBiasStrength;}let c;if(h<config.noise.waterLevel)c=config.biomeColors.water;else if(h<config.noise.forestLevel)c=config.biomeColors.forest;else c=config.biomeColors.desert;ctx.fillStyle=c;ctx.fillRect(wx,wy,t,t);}}
        function drawSimulation(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='hsl(240, 50%, 5%)';ctx.fillRect(0,0,canvas.width,canvas.height);ctx.save();ctx.translate(-cameraX*config.zoomLevel,-cameraY*config.zoomLevel);ctx.scale(config.zoomLevel,config.zoomLevel);drawLandscape(ctx);for(let e of entities)e.draw(ctx);ctx.restore();const ind=document.getElementById('follow-indicator'),fs=document.getElementById('follow-status');if(followedEntity&&!followedEntity.isDead){const sX=(followedEntity.position.x-cameraX)*config.zoomLevel,sY=(followedEntity.position.y-cameraY)*config.zoomLevel,iS=followedEntity.size*2*config.zoomLevel;if(sX>-iS&&sX<canvas.width+iS&&sY>-iS&&sY<canvas.height+iS){ind.style.width=`${iS}px`;ind.style.height=`${iS}px`;ind.style.transform=`translate(${sX-iS/2}px, ${sY-iS/2}px)`;ind.classList.add('visible');}else ind.classList.remove('visible');const eT=followedEntity.constructor.name;fs.textContent=`Following ${eT} #${followedEntity.id}`;fs.classList.add('visible');}else{ind.classList.remove('visible');fs.classList.remove('visible');} document.getElementById('preyCount').textContent=currentPreyCount;document.getElementById('predatorCount').textContent=currentPredatorCount;document.getElementById('hunterCount').textContent=currentHunterCount;document.getElementById('foodCount').textContent=currentFoodCount;document.getElementById('totalPreySurvivalTime').textContent=formatTime(totalPreySurvivalTicks);document.getElementById('totalPredatorSurvivalTime').textContent=formatTime(totalPredatorSurvivalTicks);document.getElementById('totalHunterSurvivalTime').textContent=formatTime(totalHunterSurvivalTicks);document.getElementById('totalBirths').textContent=totalBirths;document.getElementById('totalGeneticMutations').textContent=totalGeneticMutations;document.getElementById('simulationTicks').textContent=simulationTicks;}
        function gameLoop(c){lastFrameTime=c;updateCamera();updateSimulation();drawSimulation();requestAnimationFrame(gameLoop);}
        function resizeCanvas(){canvas.width=window.innerWidth;const sP=document.getElementById('stats-panel'),tEP=document.getElementById('top-entities-panel'),pH=(sP?sP.offsetHeight:0)+(tEP?tEP.offsetHeight:0),pM=20;canvas.height=window.innerHeight-(pH+pM);if(canvas.height<0)canvas.height=0;const sX=canvas.width/config.worldWidth,sY=canvas.height/config.worldHeight;config.zoomLevel=Math.min(sX,sY);config.zoomLevel=Math.max(config.zoomLevel,0.1);targetZoom=config.zoomLevel;cameraX=(config.worldWidth-canvas.width/config.zoomLevel)/2;cameraY=(config.worldHeight-canvas.height/config.zoomLevel)/2;targetCameraX=cameraX;targetCameraY=cameraY;clampCamera();quadtree=new QuadTree(new Rectangle(config.worldWidth/2,config.worldHeight/2,config.worldWidth/2,config.worldHeight/2),config.quadtreeCapacity);drawSimulation();}
        function initNNChart(){const c=document.getElementById('nnChartCanvas').getContext('2d');nnChart=new Chart(c,{type:'line',data:{labels:chartLabels,datasets:[{label:'Prey Avg Age',data:avgPreyAgeData,borderColor:'hsl(120, 100%, 50%)',backgroundColor:'hsla(120, 100%, 50%, 0.2)',borderWidth:2,tension:0.3,pointRadius:0},{label:'Predator Avg Age',data:avgPredatorAgeData,borderColor:'hsl(0, 100%, 50%)',backgroundColor:'hsla(0, 100%, 50%, 0.2)',borderWidth:2,tension:0.3,pointRadius:0},{label:'Hunter Avg Age',data:avgHunterAgeData,borderColor:'hsl(280, 100%, 60%)',backgroundColor:'hsla(280, 100%, 60%, 0.2)',borderWidth:2,tension:0.3,pointRadius:0}]},options:{responsive:!0,maintainAspectRatio:!0,scales:{x:{ticks:{color:'#ccc'},grid:{color:'rgba(255,255,255,0.1)'}},y:{beginAtZero:!0,ticks:{color:'#ccc'},grid:{color:'rgba(255,255,255,0.1)'},title:{display:!0,text:'Avg. Age (sec)',color:'#ccc'}}},plugins:{legend:{labels:{color:'#eee'}}}}});}
        
        function setupUI() {
            const startPauseButton = document.getElementById('start-pause-button'), togglePanelButton = document.getElementById('toggle-panel-button'), uiPanel = document.getElementById('ui-panel'), zoomControls = document.getElementById('zoom-controls'), zoomInButton = document.getElementById('zoom-in-button'), zoomOutButton = document.getElementById('zoom-out-button'), showPanelButton = document.getElementById('show-panel-button'), restartGameButton = document.getElementById('restart-game-button'), nnPanel = document.getElementById('nn-visualization-panel'), hideNNButton = document.getElementById('hide-nn-panel-button'), showNNButton = document.getElementById('toggle-nn-panel-button');
            
            // NEW: Added sliders for NN and flocking
            const sliders = [
                { id: 'timeScale', prop: 'timeScale', valueSpan: 'timeScaleValue', precision: 1 },
                { id: 'mutationRate', prop: 'mutationRate', valueSpan: 'mutationRateValue', precision: 3 },
                { id: 'foodSpawnRate', prop: 'foodSpawnRate', valueSpan: 'foodSpawnRateValue', precision: 1 },
                { id: 'foodEnergy', prop: 'foodEnergy', valueSpan: 'foodEnergyValue', precision: 0 },
                { id: 'preyTargetPopulation', prop: 'preyTargetPopulation', valueSpan: 'preyTargetPopulationValue', precision: 0 },
                { id: 'predatorTargetPopulation', prop: 'predatorTargetPopulation', valueSpan: 'predatorTargetPopulationValue', precision: 0 },
                { id: 'hunterTargetPopulation', prop: 'hunterTargetPopulation', valueSpan: 'hunterTargetPopulationValue', precision: 0 },
                { id: 'hiddenLayerSize', prop: 'hiddenLayerSize', valueSpan: 'hiddenLayerSizeValue', precision: 0 },
                { id: 'alignmentForce', prop: 'alignmentForce', valueSpan: 'alignmentForceValue', precision: 1 },
                { id: 'cohesionForce', prop: 'cohesionForce', valueSpan: 'cohesionForceValue', precision: 1 },
                { id: 'separationForce', prop: 'separationForce', valueSpan: 'separationForceValue', precision: 1 },
            ];

            sliders.forEach(s=>{const el=document.getElementById(s.id),vs=document.getElementById(s.valueSpan);el.value=config[s.prop];vs.textContent=parseFloat(config[s.prop]).toFixed(s.precision);el.addEventListener('input',e=>{config[s.prop]=parseFloat(e.target.value);vs.textContent=config[s.prop].toFixed(s.precision);});});
            startPauseButton.addEventListener('click',()=>{if(gameOver){hideGameOverStats();generateInitialPopulation();simulationPaused=!1;startPauseButton.textContent='Pause Simulation';lastFrameTime=performance.now();}else{simulationPaused=!simulationPaused;startPauseButton.textContent=simulationPaused?'Resume Simulation':'Pause Simulation';if(!simulationPaused)lastFrameTime=performance.now();}});
            togglePanelButton.addEventListener('click',()=>{const h=uiPanel.classList.toggle('hidden');zoomControls.classList.toggle('visible',h);showPanelButton.classList.toggle('visible',h);});
            showPanelButton.addEventListener('click',()=>{uiPanel.classList.remove('hidden');zoomControls.classList.remove('visible');showPanelButton.classList.remove('visible');});
            const tglNN=()=>{const h=nnPanel.classList.toggle('hidden');showNNButton.classList.toggle('visible',h);};
            hideNNButton.addEventListener('click',tglNN);showNNButton.addEventListener('click',tglNN);
            zoomInButton.addEventListener('click',()=>{followedEntity=null;targetZoom=Math.min(targetZoom*1.25,5.0);});
            zoomOutButton.addEventListener('click',()=>{followedEntity=null;targetZoom=Math.max(targetZoom*0.8,0.1);});
            restartGameButton.addEventListener('click',()=>{hideGameOverStats();generateInitialPopulation();simulationPaused=!1;document.getElementById('start-pause-button').textContent='Pause Simulation';lastFrameTime=performance.now();});
        }

        document.addEventListener('DOMContentLoaded', () => { initSimulation(); lastFrameTime = performance.now(); requestAnimationFrame(gameLoop); });
    </script>
    <!-- Add this script block just before your closing </body> tag -->

    <script>
      // Register the Service Worker
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js')
            .then((registration) => {
              console.log('Service Worker registered successfully with scope:', registration.scope);
            })
            .catch((error) => {
              console.error('Service Worker registration failed:', error);
            });
        });
      }
    </script>
</body>
</html>