<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Mini-RPG</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        :root {
            --color-health: #28a745;
            --color-mana: #007bff;
            --color-xp: #9370db;
            --color-enemy-health: #dc3545;
            --color-bg-dark: #1a1a1a;
            --color-bg-medium: #2a2a2e;
            --color-bg-light: #3a3a40;
            --color-border: #4f4f58;
            --color-text: #f0f0f0;
            --color-text-muted: #888;
            --color-text-quest: #ffd700;
            --color-text-magic: #87ceeb;
            --color-text-rare: #0070dd;
            --color-text-epic: #a335ee;
            --color-cooldown: rgba(0, 0, 0, 0.75);
            --font-main: 'Verdana', sans-serif;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--color-bg-dark);
            font-family: var(--font-main); color: var(--color-text);
            user-select: none; -webkit-user-select: none;
        }
        #game-container { position: relative; width: 100%; height: 100%; }
        #game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        .unit-frame {
            position: absolute; top: 20px; width: 250px; background-color: var(--color-bg-medium);
            border: 1px solid var(--color-border); border-radius: 5px; padding: 5px;
            display: flex; gap: 10px; align-items: center; pointer-events: all;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #player-frame { left: 20px; }
        #target-frame { left: 290px; display: none; }
        .portrait {
            width: 50px; height: 50px; background: var(--color-bg-dark);
            border: 2px solid var(--color-border); border-radius: 5px;
            display: flex; justify-content: center; align-items: center; font-size: 30px;
        }
        .unit-info { flex-grow: 1; }
        .name-level { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .resource-bar {
            width: 100%; height: 15px; background-color: var(--color-bg-dark);
            border-radius: 3px; overflow: hidden; margin-top: 2px; position: relative;
        }
        .resource-bar .bar-fill { height: 100%; transition: width 0.2s ease-out; }
        .resource-bar .bar-text {
            position: absolute; width: 100%; text-align: center;
            font-size: 10px; line-height: 15px; color: white; text-shadow: 1px 1px 1px black;
        }
        #player-health-fill { background-color: var(--color-health); }
        #player-mana-fill { background-color: var(--color-mana); }
        #target-health-fill { background-color: var(--color-enemy-health); }

        /* --- Bottom Bar Area --- */
        #bottom-ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column-reverse; /* Puts action bar at the very bottom */
            align-items: center;
            gap: 2px;
        }
        #action-bar {
            position: relative;
            bottom: 0; left: 0;
            transform: none; /* Reset transform as it's now in a container */
            display: flex; background-color: var(--color-bg-medium);
            padding: 5px; border-radius: 5px; border: 1px solid var(--color-border);
            pointer-events: all;
        }
        .action-slot {
            width: 50px; height: 50px; background-color: var(--color-bg-dark);
            border: 1px solid var(--color-border); margin: 2px; position: relative;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; cursor: pointer;
        }
        .action-slot:hover { border-color: #fff; }
        .action-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        .action-slot i { color: #ccc; pointer-events: none; /* Clicks go to parent */ }
        .action-keybind {
            position: absolute; top: 2px; left: 2px; font-size: 10px; color: var(--color-text-muted);
        }
        .hotbar-item-count {
            position: absolute; bottom: 2px; right: 2px; font-size: 14px;
            color: white; text-shadow: 1px 1px 2px black;
        }
        .cooldown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 0;
            background-color: var(--color-cooldown); pointer-events: none;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; color: white; overflow: hidden;
        }

        #xp-bar {
            position: relative; /* Now positioned within the container */
            bottom: 0; left: 0; transform: none;
            width: 80vw; /* --- CHANGE: Widen XP Bar --- */
            max-width: 544px; /* Maintain max width to match action bar */
            height: 8px; background-color: rgba(0,0,0,0.5);
            border: 1px solid var(--color-border); pointer-events: none;
        }
        #xp-bar-fill { width: 0%; height: 100%; background-color: var(--color-xp); transition: width 0.5s ease-in-out; }

        /* Other UI elements... */
        #minimap { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; border-radius: 50%; border: 3px solid var(--color-border); background-color: var(--color-bg-dark); overflow: hidden; pointer-events: all; }
        #minimap-canvas { width: 100%; height: 100%; }
        .window { position: absolute; width: 350px; background: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; box-shadow: 0 0 15px rgba(0,0,0,0.7); display: none; flex-direction: column; pointer-events: all; }
        .window-header { padding: 8px; background: var(--color-bg-light); cursor: move; display: flex; justify-content: space-between; align-items: center; }
        .window-header .close-btn { cursor: pointer; }
        .window-content { padding: 10px; max-height: 400px; overflow-y: auto; }
        #character-window { top: 150px; left: 100px; }
        #inventory-window { top: 150px; left: 500px; }
        #quest-log-window { top: 100px; right: 200px; }
        #inventory-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .inventory-slot { width: 60px; height: 60px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 28px; position: relative; }
        .inventory-slot[draggable="true"] { cursor: grab; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; text-shadow: 1px 1px 1px black; }
        .quality-common { color: var(--color-text); }
        .quality-magic { color: var(--color-text-magic); }
        .quality-rare { color: var(--color-text-rare); }
        .quality-epic { color: var(--color-text-epic); }
        .stat-line { display: flex; justify-content: space-between; padding: 4px 0; }
        .quest-item { padding: 8px; border-bottom: 1px solid var(--color-border); }
        .quest-title { font-weight: bold; color: var(--color-text-quest); }
        .quest-objective { font-size: 14px; padding-left: 15px; }
        .floating-text { position: absolute; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; animation: floatUp 1.5s ease-out forwards; pointer-events: none; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-60px); opacity: 0; } }
        #tooltip { position: absolute; background: var(--color-bg-dark); border: 1px solid var(--color-border); padding: 10px; border-radius: 5px; display: none; max-width: 250px; pointer-events: none; z-index: 10000; }
        #tooltip .name { font-weight: bold; margin-bottom: 5px; }
        #tooltip .description { font-size: 14px; color: var(--color-text-muted); }
        #tooltip .stats { margin-top: 8px; font-size: 14px; }
        #mobile-controls { position: absolute; bottom: 10px; left: 10px; width: 150px; height: 150px; display: none; pointer-events: all; }
        #joystick-area { position: relative; width: 100%; height: 100%; background: rgba(50, 50, 50, 0.4); border-radius: 50%; }
        #joystick-thumb { position: absolute; width: 60px; height: 60px; background: rgba(120, 120, 120, 0.7); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #system-menu { position: absolute; bottom: 20px; right: 20px; display: flex; pointer-events: all; gap: 2px; }
        .sys-button { width: 30px; height: 30px; background: var(--color-bg-light); border: 1px solid var(--color-border); cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .sys-button:hover { background: var(--color-bg-medium); }
        #death-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; flex-direction: column; color: #dc3545; text-align: center; font-size: 3em; text-shadow: 2px 2px 4px black; pointer-events: all; z-index: 20000; }
        #respawn-button { padding: 15px 30px; font-size: 1.2em; color: var(--color-text); background-color: var(--color-bg-light); border: 2px solid var(--color-border); border-radius: 5px; cursor: pointer; margin-top: 20px; }
        #respawn-button:hover { border-color: #fff; background-color: var(--color-bg-medium); }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="player-frame" class="unit-frame">
                <div class="portrait"><i class="fas fa-user"></i></div>
                <div class="unit-info">
                    <div class="name-level"><span id="player-name">Player</span><span id="player-level">Lvl 1</span></div>
                    <div class="resource-bar"><div id="player-health-fill" class="bar-fill"></div><div id="player-health-text" class="bar-text">100 / 100</div></div>
                    <div class="resource-bar"><div id="player-mana-fill" class="bar-fill"></div><div id="player-mana-text" class="bar-text">100 / 100</div></div>
                </div>
            </div>
            <div id="target-frame" class="unit-frame">
                <div class="portrait" id="target-portrait"></div>
                <div class="unit-info">
                    <div class="name-level"><span id="target-name"></span><span id="target-level"></span></div>
                    <div class="resource-bar"><div id="target-health-fill" class="bar-fill"></div><div id="target-health-text" class="bar-text"></div></div>
                </div>
            </div>
            
            <div id="bottom-ui-container">
                <div id="action-bar"></div>
                <div id="xp-bar"><div id="xp-bar-fill"></div></div>
            </div>
            
            <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
            <div id="floating-text-container"></div>
            <div id="tooltip"></div>

            <div id="character-window" class="window">
                <div class="window-header"><span>Character</span><i class="fas fa-times close-btn"></i></div><div class="window-content" id="character-content"></div>
            </div>
            <div id="inventory-window" class="window">
                <div class="window-header"><span>Inventory</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="inventory-grid"></div><div id="currency" style="margin-top: 10px; text-align: right;">Gold: 0</div></div>
            </div>
            <div id="quest-log-window" class="window">
                <div class="window-header"><span>Quest Log</span><i class="fas fa-times close-btn"></i></div><div class="window-content" id="quest-log-content"></div>
            </div>

            <div id="mobile-controls"><div id="joystick-area"><div id="joystick-thumb"></div></div></div>
            <div id="system-menu">
                <button class="sys-button" data-window="character-window" title="Character (C)"><i class="fas fa-user-circle"></i></button>
                <button class="sys-button" data-window="inventory-window" title="Inventory (I)"><i class="fas fa-briefcase"></i></button>
                <button class="sys-button" data-window="quest-log-window" title="Quest Log (L)"><i class="fas fa-book-open"></i></button>
            </div>
            <div id="death-screen"><p>You have died.</p><button id="respawn-button">Respawn</button></div>
        </div>
    </div>

<script type="module">
const $ = (selector) => document.querySelector(selector);
const $$ = (selector) => document.querySelectorAll(selector);
const distance = (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
const RESPAWN_POINT = { x: 5000, y: 5000 };

const GameData = {
    ITEMS: {
        1: { id: 1, name: "Rusty Sword", icon: "fa-glaive-sharp", slot: "main-hand", quality: "common", stats: { attack: 2 } },
        2: { id: 2, name: "Worn Leather Vest", icon: "fa-shirt", slot: "chest", quality: "common", stats: { armor: 5 } },
        3: { id: 3, name: "Spider Silk", icon: "fa-spider-web", slot: "material", quality: "common", stackable: true },
        4: { id: 4, name: "Wolf Fang", icon: "fa-tooth", slot: "material", quality: "common", stackable: true },
        5: { id: 5, name: "Minor Healing Potion", icon: "fa-prescription-bottle", slot: "consumable", quality: "common", stackable: true, onUse: (player) => player.heal(50) },
        101: { id: 101, name: "Goblin-Forged Blade", icon: "fa-glaive-sharp", slot: "main-hand", quality: "magic", stats: { attack: 5, strength: 2 } },
        102: { id: 102, name: "Enchanted Robes", icon: "fa-hat-wizard", slot: "chest", quality: "magic", stats: { armor: 8, intellect: 3 } },
    },
    ABILITIES: {
        1: { id: 1, name: "Slash", icon: "fa-glaive-sharp", cost: 20, cooldown: 3000, range: 40, onUse: (caster, target) => { ParticleSystem.create(target.x, target.y, 'red', 15, 0.1, 10); const damage = caster.getAttackDamage() * 1.5; target.takeDamage(damage, 'physical'); }},
        2: { id: 2, name: "Fireball", icon: "fa-fire-alt", cost: 30, cooldown: 5000, range: 200, onUse: (caster, target) => { ParticleSystem.create(target.x, target.y, 'orange', 25, 0.2, 15); const damage = (caster.stats.intellect * 2) + 10; target.takeDamage(damage, 'magic'); }},
    },
    ENEMY_TYPES: {
        'WOLF': { name: "Dire Wolf", icon: "\uf6f0", color: "#a9a9a9", size: 28, speed: 1.5, health: 80, attack: 5, aggroRadius: 150, attackRange: 40, attackSpeed: 2000, xp: 15, lootTable: [{itemId: 4, chance: 0.8, min: 1, max: 2}, {gold: 1, chance: 1.0}] },
        'SPIDER': { name: "Forest Spider", icon: "\uf717", color: "#654321", size: 25, speed: 1.2, health: 60, attack: 4, aggroRadius: 120, attackRange: 35, attackSpeed: 1800, xp: 10, lootTable: [{itemId: 3, chance: 0.9, min: 1, max: 3}, {gold: 1, chance: 1.0}] },
        'GOBLIN': { name: "Goblin Thug", icon: "\uf6a0", color: "#2E8B57", size: 22, speed: 1.8, health: 120, attack: 8, aggroRadius: 180, attackRange: 45, attackSpeed: 2200, xp: 25, lootTable: [{itemId: 101, chance: 0.1}, {gold: 5, chance: 0.5}] }
    },
    QUESTS: { 1: { id: 1, title: "A Tangled Web", description: "The forest path is overrun with spiders. Clear out 5 of them so travelers can pass safely.", objectives: [{ type: 'kill', target: 'SPIDER', count: 5 }], rewards: { xp: 100, gold: 10, items: [{id: 2, quantity: 1}] }}},
    XP_TABLE: [0, 100, 250, 500, 1000, 2000]
};

class Game {
    constructor() {
        this.canvas = $("#game-canvas"); this.ctx = this.canvas.getContext("2d");
        this.lastTime = 0; this.entities = []; this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        this.input = new InputHandler(this.isMobile);
        // --- CHANGE: Doubled world size ---
        this.world = new World(this.ctx, 10000, 10000);
        ParticleSystem.init(this.ctx);
        this.player = new Player(RESPAWN_POINT.x, RESPAWN_POINT.y, this.input);
        this.entities.push(this.player);
        this.ui = new UI(this);
        this.camera = new Camera(this.player, this.canvas.width, this.canvas.height);
        this.spawnEntities(); this.ui.updateAll(this.player);
        this.setupUIInteractions(); this.gameLoop(0);
    }
    resizeCanvas() {
        this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight;
        if(this.camera) { this.camera.width = this.canvas.width; this.camera.height = this.canvas.height; }
    }
    spawnEntities() {
        // --- CHANGE: Quest giver closer to spawn ---
        this.entities.push(new QuestGiver(RESPAWN_POINT.x + 100, RESPAWN_POINT.y - 50, "Old Man Willow", [1]));
        const safeRadius = 600;

        for(let i = 0; i < 40; i++) { // More enemies for larger world
            let x, y, dist;
            do { // Keep generating coords until they are outside the safe zone
                x = Math.random() * this.world.width; y = Math.random() * this.world.height;
                dist = distance({x, y}, RESPAWN_POINT);
            } while (dist < safeRadius);
            
            const type = Math.random() > 0.5 ? 'WOLF' : 'SPIDER';
            this.entities.push(new Enemy(x, y, GameData.ENEMY_TYPES[type]));
        }
        for(let i = 0; i < 10; i++) {
            let x, y, dist;
            do {
                x = Math.random() * this.world.width; y = Math.random() * this.world.height;
                dist = distance({x, y}, RESPAWN_POINT);
            } while (dist < safeRadius);
            this.entities.push(new Enemy(x, y, GameData.ENEMY_TYPES['GOBLIN']));
        }
    }
    gameLoop(timestamp) { const deltaTime = timestamp - this.lastTime; this.lastTime = timestamp; this.update(deltaTime); this.draw(); requestAnimationFrame((ts) => this.gameLoop(ts)); }
    update(deltaTime) {
        if (!deltaTime) return;
        if (this.input.mouse.clicked) {
            let clickedOnSomething = false; const clickWorldPos = { x: this.input.mouse.x + this.camera.x, y: this.input.mouse.y + this.camera.y };
            const sortedEntities = [...this.entities].sort((a, b) => b.y - a.y);
            for (const entity of sortedEntities) {
                if (entity !== this.player && distance(clickWorldPos, entity) < entity.size) {
                    if (entity.isInteractable && distance(this.player, entity) < 100) entity.interact(this.player);
                    else this.player.setTarget(entity);
                    clickedOnSomething = true; break;
                }
            }
            if (!clickedOnSomething) this.player.setTarget(null);
            this.input.mouse.clicked = false;
        }
        this.entities.forEach(entity => entity.update(deltaTime, this.world, this.entities, this.player));
        const deadNPCs = this.entities.filter(e => e.isDead && e !== this.player);
        if(deadNPCs.length > 0) {
            deadNPCs.forEach(dead => { if (dead === this.player.target) this.player.setTarget(null); });
            this.entities = this.entities.filter(e => !deadNPCs.includes(e));
        }
        this.camera.update(); ParticleSystem.update(deltaTime); this.ui.update(this.player, deltaTime);
    }
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.save();
        this.ctx.translate(-this.camera.x, -this.camera.y);
        this.world.draw(this.camera);
        const sortedEntities = [...this.entities].sort((a, b) => a.y - b.y);
        sortedEntities.forEach(entity => entity.draw(this.ctx, this.camera, this.player));
        ParticleSystem.draw(this.camera); this.ctx.restore();
    }
    createFloatingText(text, x, y, color) { this.ui.createFloatingText(text, x, y, color, this.camera); }
    setupUIInteractions() {
        if (this.isMobile) $("#mobile-controls").style.display = "block";
        $$('.sys-button').forEach(btn => btn.addEventListener('click', () => { const windowId = btn.dataset.window; $(`#${windowId}`).style.display = $(`#${windowId}`).style.display === 'flex' ? 'none' : 'flex'; }));
        $$('.close-btn').forEach(btn => btn.addEventListener('click', (e) => e.target.closest('.window').style.display = 'none'));
        $$('.window').forEach(win => this.ui.makeDraggable(win));
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (e.key.toLowerCase() === 'c') $('#character-window').style.display = $('#character-window').style.display === 'flex' ? 'none' : 'flex';
            if (e.key.toLowerCase() === 'i') $('#inventory-window').style.display = $('#inventory-window').style.display === 'flex' ? 'none' : 'flex';
            if (e.key.toLowerCase() === 'l') $('#quest-log-window').style.display = $('#quest-log-window').style.display === 'flex' ? 'none' : 'flex';
        });
        $('#respawn-button').addEventListener('click', () => this.player.respawn());
    }
}

class World {
    constructor(ctx, width, height) { this.ctx = ctx; this.width = width; this.height = height; this.bgColor = "#182c18"; this.decorations = []; this.generateDecorations(); }
    generateDecorations() {
        for (let i = 0; i < 1000; i++) this.decorations.push({ x: Math.random() * this.width, y: Math.random() * this.height, type: 'grass', char: ['"', ',', "`"][Math.floor(Math.random()*3)], color: `rgba(144, 238, 144, ${Math.random() * 0.4 + 0.2})`, size: Math.random() * 8 + 12 });
        for (let i = 0; i < 300; i++) this.decorations.push({ x: Math.random() * this.width, y: Math.random() * this.height, type: 'tree', char: '\uf1bb', color: `rgba(0, 100, 0, ${Math.random() * 0.3 + 0.5})`, size: Math.random() * 30 + 20 });
    }
    draw(camera) {
        this.ctx.fillStyle = this.bgColor; this.ctx.fillRect(camera.x, camera.y, camera.width, camera.height);
        this.decorations.forEach(d => {
            if (d.x > camera.x - d.size && d.x < camera.x + camera.width + d.size && d.y > camera.y - d.size && d.y < camera.y + camera.height + d.size) {
                this.ctx.font = `${d.size}px "Font Awesome 6 Free"`; this.ctx.fillStyle = d.color;
                if(d.type === 'grass') this.ctx.font = `${d.size}px "Verdana"`;
                this.ctx.fillText(d.char, d.x, d.y);
            }
        });
    }
}
class Camera {
    constructor(target, width, height) { this.target = target; this.width = width; this.height = height; this.x = 0; this.y = 0; }
    update() {
        if(this.target.isDead) return;
        this.x = this.target.x - this.width / 2; this.y = this.target.y - this.height / 2;
        this.x = Math.max(0, Math.min(this.x, game.world.width - this.width));
        this.y = Math.max(0, Math.min(this.y, game.world.height - this.height));
    }
}
class Entity {
    constructor(x, y, size, color, icon) { this.x = x; this.y = y; this.size = size; this.color = color; this.icon = icon; this.isDead = false; }
    draw(ctx, camera, player) {
        if(this.isDead && this instanceof Player) ctx.globalAlpha = 0.5;
        ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.ellipse(this.x, this.y + this.size/2, this.size/2, this.size/4, 0, 0, 2*Math.PI); ctx.fill();
        ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`; ctx.fillStyle = this.color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.icon, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
    update(deltaTime, world, entities) {}
}
class Character extends Entity {
    constructor(x, y, size, color, icon, name) { super(x, y, size, color, icon); this.name = name; this.level = 1; this.stats = { strength: 5, agility: 5, stamina: 5, intellect: 5, health: 100, maxHealth: 100, mana: 100, maxMana: 100, attack: 5, armor: 0 }; this.target = null; }
    takeDamage(amount, type) {
        let finalAmount = amount; if(type === 'physical') { const mitigation = 1 - (this.stats.armor / (this.stats.armor + 400 + 85 * this.level)); finalAmount = Math.max(1, amount * mitigation); }
        finalAmount = Math.round(finalAmount); this.stats.health = Math.max(0, this.stats.health - finalAmount);
        const color = type === 'physical' ? '#fff' : '#87ceeb'; game.createFloatingText(finalAmount, this.x, this.y, color);
        if (this.stats.health === 0) this.die();
    }
    heal(amount) { this.stats.health = Math.min(this.stats.maxHealth, this.stats.health + amount); game.createFloatingText(amount, this.x, this.y, 'lightgreen'); }
    die() { if (this.isDead) return; this.isDead = true; ParticleSystem.create(this.x, this.y, '#777', 30, 0.5); }
    setTarget(entity) { if (this.target) this.target.isTargeted = false; this.target = entity; if (this.target) this.target.isTargeted = true; }
    getAttackDamage() { return this.stats.attack + (this.stats.strength * 0.5); }
    draw(ctx, camera, player) {
        super.draw(ctx, camera, player);
        if (this.stats.health < this.stats.maxHealth || this.isTargeted) {
            const barWidth = this.size * 2; const barHeight = 5; const barY = this.y + this.size / 2 + 10;
            ctx.fillStyle = '#333'; ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight);
            const healthPercent = this.stats.health / this.stats.maxHealth;
            ctx.fillStyle = this instanceof Player ? '#28a745' : '#dc3545';
            ctx.fillRect(this.x - barWidth / 2, barY, barWidth * healthPercent, barHeight);
        }
        if(this.isTargeted) { ctx.strokeStyle = '#ffc107'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(this.x, this.y + this.size/2, this.size/1.5, this.size/3, 0, 0, 2*Math.PI); ctx.stroke(); }
    }
}
class Player extends Character {
    constructor(x, y, input) {
        super(x, y, 30, '#ddd', '\uf007', 'Hero');
        this.input = input; this.speed = 3.5; this.xp = 0; this.nextLevelXp = GameData.XP_TABLE[this.level]; this.gold = 0;
        this.inventory = new Array(16).fill(null); this.equipment = { 'main-hand': null, 'chest': null };
        // --- CHANGE: Renamed 'abilities' to 'hotbar' for clarity ---
        this.hotbar = new Array(10).fill(null);
        this.hotbar[0] = { type: 'ability', ref: GameData.ABILITIES[1] };
        this.hotbar[1] = { type: 'ability', ref: GameData.ABILITIES[2] };
        this.cooldowns = {}; this.quests = []; this.autoAttackTimer = 0; this.attackSpeed = 2000;
        this.addItem(1, 1); this.addItem(5, 3); this.recalculateStats();
    }
    update(deltaTime) {
        if (this.isDead) return;
        const moveVector = this.input.getMoveVector();
        if (moveVector.x !== 0 || moveVector.y !== 0) {
            this.x += moveVector.x * this.speed * (deltaTime / 16.67); this.y += moveVector.y * this.speed * (deltaTime / 16.67);
            this.x = Math.max(this.size/2, Math.min(this.x, game.world.width - this.size/2));
            this.y = Math.max(this.size/2, Math.min(this.y, game.world.height - this.size/2));
        }
        for (const id in this.cooldowns) { this.cooldowns[id] -= deltaTime; if (this.cooldowns[id] <= 0) delete this.cooldowns[id]; }
        for(let i = 0; i < 10; i++) { if (this.input.keys[`${(i + 1) % 10}`]) { this.useHotbarSlot(i); this.input.keys[`${(i + 1) % 10}`] = false; } }
        this.autoAttackTimer += deltaTime;
        if(this.target && !this.target.isDead && distance(this, this.target) <= 40) { if (this.autoAttackTimer >= this.attackSpeed) { this.autoAttack(); this.autoAttackTimer = 0; } }
    }
    die() { super.die(); game.ui.showDeathScreen(); }
    respawn() { this.isDead = false; this.x = RESPAWN_POINT.x; this.y = RESPAWN_POINT.y; this.stats.health = this.stats.maxHealth; this.stats.mana = this.stats.maxMana; this.setTarget(null); game.ui.hideDeathScreen(); game.ui.updatePlayerFrame(this); }
    autoAttack() { if (!this.target) return; ParticleSystem.create(this.target.x, this.target.y, 'white', 10, 0.1, 8); this.target.takeDamage(this.getAttackDamage(), 'physical'); }
    useHotbarSlot(index) {
        const slotItem = this.hotbar[index];
        if (!slotItem) return;

        if(slotItem.type === 'ability') {
            const ability = slotItem.ref;
            if (this.cooldowns[ability.id] || !this.target || this.target.isDead) return;
            if(distance(this, this.target) > ability.range) { game.createFloatingText("Out of range", this.x, this.y, "yellow"); return; }
            if (this.stats.mana < ability.cost) { game.createFloatingText("Not enough mana", this.x, this.y, "blue"); return; }
            this.stats.mana -= ability.cost; ability.onUse(this, this.target); this.cooldowns[ability.id] = ability.cooldown;
        } else if (slotItem.type === 'item') {
            const item = slotItem.ref;
            if (item.slot === 'consumable' && item.onUse) {
                item.onUse(this);
                item.quantity--;
                if(item.quantity <= 0) {
                    const invIndex = this.inventory.findIndex(i => i && i.id === item.id);
                    if (invIndex > -1) this.inventory[invIndex] = null;
                    this.hotbar[index] = null;
                }
                game.ui.updateInventory(this);
                game.ui.setupActionbar(this);
            }
        }
    }
    setHotbarSlot(hotbarIndex, inventoryIndex) {
        const item = this.inventory[inventoryIndex];
        if (item && item.slot === 'consumable') {
            this.hotbar[hotbarIndex] = { type: 'item', ref: item };
            game.ui.setupActionbar(this);
        }
    }
    addXp(amount) { this.xp += amount; game.createFloatingText(`${amount} XP`, this.x, this.y - 20, '#b636d1'); while(this.xp >= this.nextLevelXp && this.level < GameData.XP_TABLE.length -1) this.levelUp(); game.ui.updateXPBar(this); }
    levelUp() { this.xp -= this.nextLevelXp; this.level++; this.nextLevelXp = GameData.XP_TABLE[this.level] || 99999; this.stats.strength += 2; this.stats.agility += 1; this.stats.stamina += 2; this.stats.intellect += 1; this.recalculateStats(); this.stats.health = this.stats.maxHealth; this.stats.mana = this.stats.maxMana; game.createFloatingText('LEVEL UP!', this.x, this.y, 'gold'); ParticleSystem.create(this.x, this.y, 'gold', 50, 1.5, 30); }
    recalculateStats() { this.stats.maxHealth = this.stats.stamina * 10; this.stats.maxMana = this.stats.intellect * 10; this.stats.attack = 5; this.stats.armor = 0; for (const slot in this.equipment) { const item = this.equipment[slot]; if (item && item.stats) { for (const stat in item.stats) { this.stats[stat] = (this.stats[stat] || 0) + item.stats[stat]; } } } }
    addItem(itemId, quantity = 1) { const itemData = GameData.ITEMS[itemId]; if (!itemData) return; if(itemData.stackable) { const existingStack = this.inventory.find(item => item && item.id === itemId); if (existingStack) { existingStack.quantity += quantity; return; } } const emptySlotIndex = this.inventory.findIndex(slot => slot === null); if (emptySlotIndex !== -1) { this.inventory[emptySlotIndex] = { ...itemData, quantity }; } else { game.createFloatingText("Inventory Full", this.x, this.y, 'red'); } }
    addQuest(questId) { if(this.quests.find(q => q.id === questId)) return; const questData = GameData.QUESTS[questId]; const questState = { ...questData, progress: questData.objectives.map(o => ({ ...o, current: 0 })) }; this.quests.push(questState); game.ui.updateQuestLog(); }
    updateQuestProgress(type, target) { this.quests.forEach(quest => { quest.progress.forEach(obj => { if (obj.type === type && obj.target === target && obj.current < obj.count) { obj.current++; game.createFloatingText(`${obj.target}: ${obj.current}/${obj.count}`, this.x, this.y - 40, '#ffd700'); game.ui.updateQuestLog(); } }); }); }
}
class NPC extends Character {
    constructor(x, y, name, icon, color) { super(x, y, 28, color || '#00ff00', icon || '\uf0c0', name); this.isInteractable = true; }
    draw(ctx, camera, player) { super.draw(ctx, camera, player); ctx.font = '14px Verdana'; ctx.fillStyle = this.color; ctx.textAlign = 'center'; ctx.fillText(this.name, this.x, this.y - this.size); }
    interact(player) {}
}
class QuestGiver extends NPC {
    constructor(x, y, name, questIds) { super(x, y, name, '\uf075', '#ffd700'); this.questIds = questIds; }
    getQuestStatus(player) { for (const questId of this.questIds) { const playerQuest = player.quests.find(q => q.id === questId); if (playerQuest) { if (playerQuest.progress.every(p => p.current >= p.count)) return 'complete'; } else return 'available'; } return 'none'; }
    draw(ctx, camera, player) { super.draw(ctx, camera, player); const status = this.getQuestStatus(player); let questIcon = ''; if (status === 'available') questIcon = '!'; if (status === 'complete') questIcon = '?'; if (questIcon) { ctx.font = 'bold 30px Arial'; ctx.fillStyle = '#ffd700'; ctx.fillText(questIcon, this.x, this.y - this.size - 25); } }
    interact(player) { const status = this.getQuestStatus(player); const questId = this.questIds[0]; if (status === 'available') { if(confirm(`Quest: ${GameData.QUESTS[questId].title}\n\n${GameData.QUESTS[questId].description}\n\nAccept quest?`)) player.addQuest(questId); } else if (status === 'complete') { const quest = player.quests.find(q => q.id === questId); alert(`Quest Complete: ${quest.title}\nYou receive ${quest.rewards.xp} XP and ${quest.rewards.gold} Gold.`); player.addXp(quest.rewards.xp); player.gold += quest.rewards.gold; quest.rewards.items.forEach(item => player.addItem(item.id, item.quantity)); player.quests = player.quests.filter(q => q.id !== questId); game.ui.updateAll(player); } else { alert(`Hello, ${player.name}. The forest is dangerous today.`); } }
}
class Enemy extends Character {
    constructor(x, y, type) { super(x, y, type.size, type.color, type.icon, type.name); this.type = type; this.state = 'patrol'; this.patrolTarget = { x: x + (Math.random()*200-100), y: y + (Math.random()*200-100) }; this.stats.health = this.stats.maxHealth = type.health; this.stats.attack = type.attack; this.attackSpeed = type.attackSpeed; this.autoAttackTimer = 0; }
    update(deltaTime, world, entities, player) { if(this.isDead) return; this.autoAttackTimer += deltaTime; const distToPlayer = distance(this, player); switch(this.state) { case 'patrol': if(distToPlayer < this.type.aggroRadius && !player.isDead) { this.state = 'chase'; this.setTarget(player); } else { this.moveTowards(this.patrolTarget, deltaTime); if (distance(this, this.patrolTarget) < 10) this.patrolTarget = { x: this.x + (Math.random()*200-100), y: this.y + (Math.random()*200-100) }; } break; case 'chase': if (player.isDead || distToPlayer > this.type.aggroRadius * 1.5) { this.state = 'patrol'; this.setTarget(null); } else if (distToPlayer <= this.type.attackRange) { this.state = 'attack'; } else { this.moveTowards(player, deltaTime); } break; case 'attack': if (!this.target || this.target.isDead) { this.state = 'patrol'; this.setTarget(null); return; } if (distToPlayer > this.type.attackRange) { this.state = 'chase'; } else { if (this.autoAttackTimer >= this.attackSpeed) { this.target.takeDamage(this.stats.attack, 'physical'); this.autoAttackTimer = 0; } } break; } }
    moveTowards(target, deltaTime) { const angle = Math.atan2(target.y - this.y, target.x - this.x); this.x += Math.cos(angle) * this.type.speed * (deltaTime / 16.67); this.y += Math.sin(angle) * this.type.speed * (deltaTime / 16.67); }
    die() { super.die(); game.player.addXp(this.type.xp); game.player.updateQuestProgress('kill', this.type.name.split(" ")[1].toUpperCase()); this.type.lootTable.forEach(item => { if(Math.random() < item.chance) { if(item.gold) { game.player.gold += item.gold; game.createFloatingText(`${item.gold} Gold`, this.x, this.y, 'gold'); } if(item.itemId) { const quantity = item.min ? Math.floor(Math.random() * (item.max - item.min + 1)) + item.min : 1; game.player.addItem(item.itemId, quantity); const itemData = GameData.ITEMS[item.itemId]; game.createFloatingText(`+ ${itemData.name}`, this.x, this.y - 20, 'white'); } } }); game.ui.updateInventory(game.player); }
}
class Particle {
    constructor(ctx, x, y, color, size, lifetime, speed) { this.ctx = ctx; this.x = x; this.y = y; this.color = color; this.initialSize = size; this.size = size; this.lifetime = lifetime; this.initialLifetime = lifetime; const angle = Math.random() * Math.PI * 2; this.vx = Math.cos(angle) * speed * (Math.random() * 5); this.vy = Math.sin(angle) * speed * (Math.random() * 5); this.active = true; }
    update(deltaTime) { this.lifetime -= deltaTime; if (this.lifetime <= 0) { this.active = false; return; } this.x += this.vx * (deltaTime / 16.67); this.y += this.vy * (deltaTime / 16.67); this.size = this.initialSize * (this.lifetime / this.initialLifetime); }
    draw() { if(!this.active) return; this.ctx.fillStyle = this.color; this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); this.ctx.fill(); }
}
const ParticleSystem = { particles: [], ctx: null, init(ctx) { this.ctx = ctx; }, create(x, y, color, count = 20, lifetime = 1, speed = 2) { for (let i = 0; i < count; i++) this.particles.push(new Particle(this.ctx, x, y, color, Math.random() * 5 + 2, lifetime * 1000, speed)); }, update(deltaTime) { this.particles = this.particles.filter(p => p.active); this.particles.forEach(p => p.update(deltaTime)); }, draw(camera) { this.ctx.save(); this.ctx.globalCompositeOperation = 'lighter'; this.particles.forEach(p => { if (p.x > camera.x && p.x < camera.x + camera.width && p.y > camera.y && p.y < camera.y + camera.height) p.draw(); }); this.ctx.restore(); } };
class InputHandler {
    constructor(isMobile) { this.keys = {}; this.mouse = { x: 0, y: 0, clicked: false }; this.isMobile = isMobile; isMobile ? this.setupMobileControls() : this.setupDesktopControls(); }
    setupDesktopControls() { window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true); window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false); window.addEventListener('mousedown', (e) => { if(e.target.id === 'game-canvas') this.mouse.clicked = true; }); window.addEventListener('mousemove', (e) => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; }); }
    setupMobileControls() { const joystickArea = $('#joystick-area'); const joystickThumb = $('#joystick-thumb'); this.joystickVector = {x: 0, y: 0}; const handleTouch = (e) => { e.preventDefault(); const joystickRect = joystickArea.getBoundingClientRect(); const centerX = joystickRect.width / 2; const centerY = joystickRect.height / 2; const touch = e.touches[0]; let x = touch.clientX - joystickRect.left - centerX; let y = touch.clientY - joystickRect.top - centerY; const dist = Math.sqrt(x*x + y*y); const maxDist = centerX - joystickThumb.offsetWidth / 2; if (dist > maxDist) { x = (x / dist) * maxDist; y = (y / dist) * maxDist; } joystickThumb.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`; this.joystickVector = { x: x / maxDist, y: y / maxDist }; }; joystickArea.addEventListener('touchstart', handleTouch, { passive: false }); joystickArea.addEventListener('touchmove', handleTouch, { passive: false }); joystickArea.addEventListener('touchend', () => { joystickThumb.style.transform = `translate(-50%, -50%)`; this.joystickVector = { x: 0, y: 0 }; }); $('#game-canvas').addEventListener('touchstart', (e) => { const touch = e.touches[0]; if (touch.clientX > 200 && touch.clientY < window.innerHeight - 100) { this.mouse.x = touch.clientX; this.mouse.y = touch.clientY; this.mouse.clicked = true; } }); }
    getMoveVector() { if(this.isMobile) return this.joystickVector; let vector = { x: 0, y: 0 }; if (this.keys['w']) vector.y -= 1; if (this.keys['s']) vector.y += 1; if (this.keys['a']) vector.x -= 1; if (this.keys['d']) vector.x += 1; if (vector.x !== 0 && vector.y !== 0) { vector.x *= 0.7071; vector.y *= 0.7071; } return vector; }
}
class UI {
    constructor(game) { this.game = game; this.minimapCanvas = $("#minimap-canvas"); this.mCtx = this.minimapCanvas.getContext("2d"); this.tooltip = $('#tooltip'); this.setupActionbar(game.player); this.setupTooltips(); this.setupDragAndDrop(game.player); }
    update(player, deltaTime) { this.updatePlayerFrame(player); this.updateTargetFrame(player.target); this.updateXPBar(player); this.updateCooldowns(player); this.drawMinimap(player, game.entities); }
    updateAll(player) { this.updatePlayerFrame(player); this.updateTargetFrame(player.target); this.updateCharacterSheet(player); this.updateInventory(player); this.updateXPBar(player); this.updateQuestLog(player); }
    updatePlayerFrame(player) { $('#player-name').textContent = player.name; $('#player-level').textContent = `Lvl ${player.level}`; $('#player-health-text').textContent = `${player.stats.health} / ${player.stats.maxHealth}`; $('#player-health-fill').style.width = `${(player.stats.health / player.stats.maxHealth) * 100}%`; $('#player-mana-text').textContent = `${player.stats.mana} / ${player.stats.maxMana}`; $('#player-mana-fill').style.width = `${(player.stats.mana / player.stats.maxMana) * 100}%`; }
    updateTargetFrame(target) { const frame = $('#target-frame'); if (target && !target.isDead) { frame.style.display = 'flex'; $('#target-portrait').innerHTML = `<i class="fas ${target.icon.substring(1)}"></i>`; $('#target-portrait').style.color = target.color; $('#target-name').textContent = target.name; $('#target-level').textContent = `Lvl ${target.level}`; $('#target-health-text').textContent = `${target.stats.health} / ${target.stats.maxHealth}`; $('#target-health-fill').style.width = `${(target.stats.health / target.stats.maxHealth) * 100}%`; } else { frame.style.display = 'none'; } }
    updateXPBar(player) { $('#xp-bar-fill').style.width = `${(player.xp / player.nextLevelXp) * 100}%`; }
    setupActionbar(player) {
        const bar = $('#action-bar'); bar.innerHTML = '';
        for (let i = 0; i < 10; i++) {
            const slotItem = player.hotbar[i]; const slot = document.createElement('div');
            slot.className = 'action-slot'; slot.dataset.index = i;
            if (slotItem) {
                const ref = slotItem.ref;
                slot.innerHTML = `<i class="fas ${ref.icon}"></i><div class="action-keybind">${(i+1)%10}</div>`;
                if(slotItem.type === 'ability') slot.innerHTML += `<div class="cooldown-overlay" data-ability-id="${ref.id}"></div>`;
                if(slotItem.type === 'item' && ref.quantity > 1) slot.innerHTML += `<div class="hotbar-item-count">${ref.quantity}</div>`;
                slot.addEventListener('click', () => player.useHotbarSlot(i));
            } else { slot.innerHTML = `<div class="action-keybind">${(i+1)%10}</div>`; }
            bar.appendChild(slot);
        }
    }
    updateCooldowns(player) { $$('.cooldown-overlay').forEach(overlay => { const id = overlay.dataset.abilityId; const hotbarItem = player.hotbar.find(h => h && h.type === 'ability' && h.ref.id == id); if(hotbarItem && player.cooldowns[id]) { const remaining = player.cooldowns[id]; const percentage = (remaining / hotbarItem.ref.cooldown) * 100; overlay.style.height = `${percentage}%`; overlay.textContent = (remaining / 1000).toFixed(1); } else { overlay.style.height = '0%'; overlay.textContent = ''; } }); }
    drawMinimap(player, entities) { const size = 150; const range = 400; this.mCtx.clearRect(0, 0, size, size); this.mCtx.fillStyle = 'rgba(0,0,0,0.5)'; this.mCtx.fillRect(0, 0, size, size); entities.forEach(entity => { const dx = entity.x - player.x; const dy = entity.y - player.y; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > range || entity instanceof Player) return; const mapX = (dx / range) * (size / 2) + (size / 2); const mapY = (dy / range) * (size / 2) + (size / 2); let color = 'gray'; if(entity instanceof Enemy) color = 'red'; if(entity instanceof QuestGiver) color = 'yellow'; this.mCtx.fillStyle = color; this.mCtx.beginPath(); this.mCtx.arc(mapX, mapY, 3, 0, 2 * Math.PI); this.mCtx.fill(); }); this.mCtx.fillStyle = 'white'; this.mCtx.save(); this.mCtx.translate(size/2, size/2); this.mCtx.beginPath(); this.mCtx.moveTo(0, -5); this.mCtx.lineTo(4, 5); this.mCtx.lineTo(-4, 5); this.mCtx.closePath(); this.mCtx.fill(); this.mCtx.restore(); }
    createFloatingText(text, worldX, worldY, color, camera) { const textElement = document.createElement('div'); textElement.className = 'floating-text'; textElement.textContent = text; textElement.style.color = color; textElement.style.left = `${worldX - camera.x}px`; textElement.style.top = `${worldY - camera.y}px`; $('#floating-text-container').appendChild(textElement); setTimeout(() => textElement.remove(), 1500); }
    updateCharacterSheet(player) { player.recalculateStats(); $('#character-content').innerHTML = `<div class="stat-line"><span>Health</span><span>${player.stats.maxHealth}</span></div><div class="stat-line"><span>Mana</span><span>${player.stats.maxMana}</span></div><hr><div class="stat-line"><span>Strength</span><span>${player.stats.strength}</span></div><div class="stat-line"><span>Agility</span><span>${player.stats.agility}</span></div><div class="stat-line"><span>Stamina</span><span>${player.stats.stamina}</span></div><div class="stat-line"><span>Intellect</span><span>${player.stats.intellect}</span></div><hr><div class="stat-line"><span>Attack Power</span><span>${player.getAttackDamage().toFixed(1)}</span></div><div class="stat-line"><span>Armor</span><span>${player.stats.armor}</span></div>`; }
    updateInventory(player) {
        const grid = $('#inventory-grid'); grid.innerHTML = '';
        player.inventory.forEach((item, index) => {
            const slot = document.createElement('div'); slot.className = 'inventory-slot'; slot.dataset.index = index;
            if (item) {
                slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`;
                if(item.stackable && item.quantity > 1) slot.innerHTML += `<div class="item-count">${item.quantity}</div>`;
                slot.dataset.itemId = item.id;
                slot.draggable = true;
            }
            grid.appendChild(slot);
        });
        $('#currency').textContent = `Gold: ${player.gold}`;
    }
    setupDragAndDrop(player) {
        const inventoryGrid = $('#inventory-grid');
        const actionBar = $('#action-bar');
        
        inventoryGrid.addEventListener('dragstart', (e) => {
            if(e.target.classList.contains('inventory-slot') && e.target.dataset.itemId) {
                e.dataTransfer.setData('text/plain', e.target.dataset.index);
                e.dataTransfer.effectAllowed = 'copy';
            }
        });

        actionBar.addEventListener('dragover', (e) => {
            e.preventDefault();
            const targetSlot = e.target.closest('.action-slot');
            if (targetSlot) {
                targetSlot.classList.add('drag-over');
            }
        });
        
        actionBar.addEventListener('dragleave', (e) => {
            const targetSlot = e.target.closest('.action-slot');
            if (targetSlot) {
                targetSlot.classList.remove('drag-over');
            }
        });

        actionBar.addEventListener('drop', (e) => {
            e.preventDefault();
            const targetSlot = e.target.closest('.action-slot');
            if (targetSlot) {
                targetSlot.classList.remove('drag-over');
                const hotbarIndex = targetSlot.dataset.index;
                const inventoryIndex = e.dataTransfer.getData('text/plain');
                player.setHotbarSlot(hotbarIndex, inventoryIndex);
            }
        });
    }
    updateQuestLog(player = this.game.player) { const content = $('#quest-log-content'); content.innerHTML = ''; if (player.quests.length === 0) { content.innerHTML = 'You have no active quests.'; return; } player.quests.forEach(quest => { const item = document.createElement('div'); item.className = 'quest-item'; let objectivesHtml = ''; quest.progress.forEach(obj => { objectivesHtml += `<div class="quest-objective">- ${obj.target} slain: ${obj.current} / ${obj.count}</div>`; }); item.innerHTML = `<div class="quest-title">${quest.title}</div>${objectivesHtml}`; content.appendChild(item); }); }
    setupTooltips() { document.body.addEventListener('mouseover', (e) => { const slot = e.target.closest('.inventory-slot[data-item-id], .action-slot[data-index]'); if (!slot) return; let itemRef; if(slot.dataset.itemId) { const invIndex = slot.dataset.index; itemRef = game.player.inventory[invIndex]; } else if (slot.dataset.index) { const hotbarItem = game.player.hotbar[slot.dataset.index]; if(hotbarItem) itemRef = hotbarItem.ref; } if (!itemRef) return; let statsHtml = ''; if (itemRef.stats) { statsHtml += '<div class="stats">'; for(const stat in itemRef.stats) statsHtml += `<div style="color: lightgreen">+${itemRef.stats[stat]} ${stat.charAt(0).toUpperCase() + stat.slice(1)}</div>`; statsHtml += '</div>'; } if (itemRef.cost) statsHtml += `<div class="stats"><div>Mana Cost: ${itemRef.cost}</div><div>Cooldown: ${itemRef.cooldown/1000}s</div></div>`; this.tooltip.innerHTML = `<div class="name quality-${itemRef.quality || 'common'}">${itemRef.name}</div><div class="description">${itemRef.slot || `Range: ${itemRef.range}`}</div>${statsHtml}`; this.tooltip.style.display = 'block'; }); document.body.addEventListener('mousemove', (e) => { if (this.tooltip.style.display === 'block') { this.tooltip.style.left = `${e.clientX + 15}px`; this.tooltip.style.top = `${e.clientY + 15}px`; } }); document.body.addEventListener('mouseout', (e) => { const slot = e.target.closest('.inventory-slot, .action-slot'); if (slot) this.tooltip.style.display = 'none'; }); }
    makeDraggable(element) { let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; const header = element.querySelector('.window-header'); const dragMouseDown = (e) => { e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; }; const elementDrag = (e) => { e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; element.style.top = (element.offsetTop - pos2) + "px"; element.style.left = (element.offsetLeft - pos1) + "px"; }; const closeDragElement = () => { document.onmouseup = null; document.onmousemove = null; }; if (header) header.onmousedown = dragMouseDown; else element.onmousedown = dragMouseDown; }
    showDeathScreen() { $('#death-screen').style.display = 'flex'; }
    hideDeathScreen() { $('#death-screen').style.display = 'none'; }
}

const game = new Game();
window.game = game;

</script>
</body>
</html>
