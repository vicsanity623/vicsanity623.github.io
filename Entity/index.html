<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem Evolution Simulation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#00ffff">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* VISUAL ENHANCEMENT: Animated Grid Background */
        @keyframes subtle-scroll {
            from { background-position: 0 0; }
            to { background-position: -256px 0; }
        }

        /* Basic Resets & Body Styles */
        body {
            margin: 0;
            background-color: #01040a; /* Fallback */
            background-image:
                linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 32px 32px;
            animation: subtle-scroll 10s linear infinite;
            font-family: 'Exo 2', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden;
        }

        /* Canvas Styles */
        canvas {
            display: block;
            width: 100%;
            flex-grow: 1;
            background-color: transparent;
            cursor: crosshair;
        }
        canvas.dragging {
            cursor: grabbing;
        }

        /* UI Panel (God Panel) Styles */
        #ui-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.4), 0 0 20px rgba(0, 255, 255, 0.2);
            max-width: 300px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            font-size: 0.9em;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(0);
            opacity: 1;
        }
        #ui-panel.hidden {
            transform: translateX(110%);
            opacity: 0;
            pointer-events: none;
        }
        #ui-panel h2, #nn-visualization-panel h3 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            font-weight: 700;
        }
        #ui-panel h2 {
            color: #0ff;
            text-shadow: 0 0 5px #0ff, 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* NEW: Section sub-headers in God Panel */
        .panel-subheader {
            color: #0ff;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 5px;
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 1.05em;
        }

        .param-group { display: flex; flex-direction: column; gap: 5px; }
        .param-group label { display: flex; justify-content: space-between; align-items: center; color: #ccc; }
        .param-group input[type="range"] {
            width: 100%; -webkit-appearance: none; height: 8px; border-radius: 5px;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.2) 0%, rgba(0, 100, 100, 0.2) 100%);
            outline: none; opacity: 0.7; transition: opacity .2s; border: 1px solid rgba(0, 255, 255, 0.1);
        }
        .param-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px; border-radius: 50%;
            background: #0ff; cursor: pointer; box-shadow: 0 0 8px #0ff, 0 0 12px rgba(0,255,255,0.7);
            border: 2px solid #fff;
        }
        .param-group input[type="range"]::-moz-range-thumb {
            width: 16px; height: 16px; border-radius: 50%; background: #0ff; cursor: pointer;
            box-shadow: 0 0 8px #0ff, 0 0 12px rgba(0,255,255,0.7); border: 2px solid #fff;
        }
        .ui-button {
            padding: 10px 15px; font-size: 1em; font-weight: bold; font-family: 'Exo 2', sans-serif;
            background-image: linear-gradient(45deg, rgba(0, 123, 255, 0.8) 0%, rgba(0, 200, 255, 0.8) 100%);
            color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 8px rgba(0, 123, 255, 0.5), inset 0 0 5px rgba(255,255,255,0.2); text-align: center;
        }
        .ui-button:hover { transform: translateY(-2px); box-shadow: 0 0 12px rgba(0, 180, 255, 0.8), inset 0 0 8px rgba(255,255,255,0.3); }
        .ui-button:active { transform: translateY(0); box-shadow: 0 0 5px rgba(0, 123, 255, 0.5), inset 0 0 10px rgba(0,0,0,0.3); }
        #start-pause-button, #toggle-panel-button { margin-top: 10px; }
        
        #top-entities-panel {
            background-color: rgba(10, 10, 15, 0.5); padding: 8px; display: flex; justify-content: center;
            align-items: center; gap: 15px; flex-wrap: wrap; box-shadow: inset 0 2px 10px rgba(0,0,0,0.4);
            border-top: 1px solid rgba(0, 255, 255, 0.1); border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            flex-shrink: 0; width: 100%; box-sizing: border-box;
        }
        .top-entity-group { display: flex; gap: 8px; align-items: center; }
        .top-entity-group strong { font-size: 0.9em; text-shadow: 1px 1px 2px #000; }
        .top-entity-button {
            padding: 5px 10px; font-size: 0.8em; border-radius: 5px; transition: transform 0.1s ease, box-shadow 0.2s ease;
            cursor: pointer; border: 1px solid rgba(255, 255, 255, 0.3); font-weight: bold;
        }
        .top-entity-button:hover { transform: translateY(-1px); }
        .prey-btn { background-color: #0f0; color: #000; box-shadow: 0 0 5px #0f0; }
        .predator-btn { background-color: #f00; color: #fff; box-shadow: 0 0 5px #f00; }
        .hunter-btn { background-color: #f0f; color: #fff; box-shadow: 0 0 5px #f0f; }
        
        #nn-visualization-panel {
            position: fixed; top: 20px; left: 20px; background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 10px; padding: 15px;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.4), 0 0 20px rgba(0, 255, 0, 0.2);
            width: 350px; max-width: 90vw; z-index: 10; display: flex; flex-direction: column; gap: 10px;
            border: 1px solid rgba(0, 255, 0, 0.3); transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(0); opacity: 1;
        }
        #nn-visualization-panel.hidden { transform: translateX(-110%); opacity: 0; pointer-events: none; }
        #nn-visualization-panel h3 { color: #0f0; text-shadow: 0 0 5px #0f0; }
        #toggle-nn-panel-button {
            position: fixed; top: 20px; left: 20px; z-index: 9; opacity: 0;
            transform: translateX(-100%); transition: opacity 0.3s ease, transform 0.3s ease;
        }
        #toggle-nn-panel-button.visible { opacity: 1; transform: translateX(0); }

        #zoom-controls {
            position: fixed; bottom: 20px; right: 20px; background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 10px; padding: 10px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); z-index: 9; display: flex; gap: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3); transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(110%); opacity: 0; pointer-events: none;
        }
        #zoom-controls.visible { transform: translateX(0); opacity: 1; pointer-events: auto; }
        #zoom-controls .ui-button { font-size: 1.5em; padding: 8px 15px; min-width: 45px; line-height: 1; }

        #show-panel-button {
            position: fixed; top: 20px; right: 20px; z-index: 9; background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px; box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); border: 1px solid rgba(0, 255, 255, 0.3);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out; transform: translateX(110%);
            opacity: 0; pointer-events: none; padding: 12px 20px;
        }
        #show-panel-button.visible { transform: translateX(0); opacity: 1; pointer-events: auto; }

        #stats-panel {
            position: static; background-color: rgba(15, 5, 25, 0.8); backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px); border-radius: 10px; padding: 15px;
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.4), 0 0 20px rgba(255, 0, 255, 0.2);
            z-index: 1; display: flex; flex-wrap: wrap; justify-content: space-around; gap: 5px 20px;
            border: 1px solid rgba(255, 0, 255, 0.3); font-size: 0.9em; width: calc(100% - 20px);
            max-width: 900px; margin: 10px auto; box-sizing: border-box; flex-shrink: 0;
        }
        #stats-panel div { display: flex; justify-content: space-between; color: #ccc; gap: 10px; }
        #stats-panel strong { color: #fff; text-shadow: 0 0 5px #fff, 0 0 8px rgba(255, 0, 255, 0.7); }
        #game-over-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px); z-index: 20; display: flex; flex-direction: column; justify-content: center;
            align-items: center; color: #fff; text-shadow: 0 0 10px #f00; font-size: 1.2em; text-align: center;
            pointer-events: none; opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        #game-over-overlay.visible { opacity: 1; pointer-events: auto; }
        #game-over-overlay h1 { color: #f00; font-size: 4em; font-weight: 700; margin-bottom: 20px; text-shadow: 0 0 15px #f00, 0 0 30px #f00, 0 0 50px #f00; }
        #game-over-overlay p { margin: 5px 0; font-size: 1.1em; color: #ccc; }
        #game-over-overlay .final-stats { margin-top: 20px; padding: 20px; background-color: rgba(0, 0, 0, 0.5); border-radius: 8px; box-shadow: 0 0 10px rgba(255, 0, 255, 0.5); max-width: 80%; display: inline-block; border: 1px solid rgba(255, 0, 255, 0.4); }
        #game-over-overlay .final-stats strong { color: #0ff; }
        #game-over-overlay button { margin-top: 30px; padding: 15px 30px; font-size: 1.5em; background-image: linear-gradient(45deg, #00cc00, #00ff00); box-shadow: 0 0 15px rgba(0, 255, 0, 0.7), inset 0 0 5px rgba(255,255,255,0.3); color: #000; font-weight: 700; border: 1px solid rgba(255,255,255,0.4); }
        #game-over-overlay button:hover { box-shadow: 0 0 25px rgba(0, 255, 0, 1), inset 0 0 8px rgba(255,255,255,0.4); }
        #follow-indicator {
            position: absolute; top: 0; left: 0; border: 2px solid rgba(0, 255, 255, 0.8); border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.9), 0 0 20px rgba(0, 255, 255, 0.6);
            pointer-events: none; z-index: 5; transition: width 0.2s ease, height 0.2s ease, transform 0.05s linear, opacity 0.3s ease;
            opacity: 0; will-change: transform, opacity;
        }
        #follow-indicator.visible { opacity: 1; }
        #follow-status {
            position: fixed; bottom: 20px; left: 20px; background-color: rgba(5, 15, 25, 0.8);
            backdrop-filter: blur(5px); border: 1px solid rgba(0, 255, 255, 0.3); border-radius: 8px;
            padding: 8px 15px; z-index: 9; font-size: 0.9em; color: #0ff; text-shadow: 0 0 5px #0ff;
            opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease, transform 0.3s ease; pointer-events: none;
        }
        #follow-status.visible { opacity: 1; transform: translateY(0); }

        @media (max-width: 768px) {
            body { overflow: auto; }
            #ui-panel, #nn-visualization-panel { top: auto; bottom: 10px; left: 10px; right: 10px; max-width: unset; max-height: 40vh; padding: 10px; width: auto; }
            #ui-panel.hidden, #nn-visualization-panel.hidden { transform: translateY(110%); opacity: 0; }
            #nn-visualization-panel { bottom: 50vh; }
            #ui-panel h2 { font-size: 1.2em; margin-bottom: 10px; }
            .ui-button { padding: 10px 15px; font-size: 1em; }
            #zoom-controls { top: 10px; bottom: auto; left: auto; right: 10px; transform: translateX(110%); }
            #zoom-controls.visible { transform: translateX(0); }
            #show-panel-button { top: 70px; right: 10px; }
            #toggle-nn-panel-button { top: 70px; left: 10px; }
            #stats-panel, #top-entities-panel { width: calc(100% - 20px); margin: 10px; padding: 10px; justify-content: flex-start; }
            #game-over-overlay h1 { font-size: 2.5em; }
            #game-over-overlay p { font-size: 1em; }
            #game-over-overlay button { padding: 10px 20px; font-size: 1.2em; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="top-entities-panel">
        <div class="top-entity-group">
            <strong>Prey:</strong>
            <div id="top-prey-list"></div>
        </div>
        <div class="top-entity-group">
            <strong>Predators:</strong>
            <div id="top-predators-list"></div>
        </div>
        <div class="top-entity-group">
            <strong>Hunters:</strong>
            <div id="top-hunters-list"></div>
        </div>
    </div>
    
    <div id="follow-indicator"></div>
    <div id="follow-status"></div>

    <div id="stats-panel">
        <div>Prey: <strong id="preyCount">0</strong></div>
        <div>Predators: <strong id="predatorCount">0</strong></div>
        <div>Hunters: <strong id="hunterCount">0</strong></div>
        <div>Food: <strong id="foodCount">0</strong></div>
        <div>Prey Survival: <strong id="totalPreySurvivalTime">00:00:00</strong></div>
        <div>Predator Survival: <strong id="totalPredatorSurvivalTime">00:00:00</strong></div>
        <div>Hunter Survival: <strong id="totalHunterSurvivalTime">00:00:00</strong></div>
        <div>Births: <strong id="totalBirths">0</strong></div>
        <div>Mutations: <strong id="totalGeneticMutations">0</strong></div>
        <div>Ticks: <strong id="simulationTicks">0</strong></div>
    </div>

    <div id="ui-panel">
        <h2>Ecosystem God Panel</h2>
        <button id="start-pause-button" class="ui-button">Start Simulation</button>
        <button id="toggle-panel-button" class="ui-button">Hide Panel</button>
        
        <div class="panel-subheader">Genetic Controls</div>
        <div class="param-group">
            <label for="hiddenLayerSize">Brain Complexity: <span id="hiddenLayerSizeValue"></span></label>
            <input type="range" id="hiddenLayerSize" min="4" max="20" step="1">
        </div>
        <div class="param-group">
            <label for="mutationRate">Mutation Rate: <span id="mutationRateValue"></span></label>
            <input type="range" id="mutationRate" min="0.001" max="0.1" step="0.001">
        </div>

        <div class="panel-subheader">Social Behavior</div>
        <div class="param-group">
            <label for="alignmentForce">Alignment: <span id="alignmentForceValue"></span></label>
            <input type="range" id="alignmentForce" min="0" max="2" step="0.1">
        </div>
        <div class="param-group">
            <label for="cohesionForce">Cohesion: <span id="cohesionForceValue"></span></label>
            <input type="range" id="cohesionForce" min="0" max="2" step="0.1">
        </div>
        <div class="param-group">
            <label for="separationForce">Separation: <span id="separationForceValue"></span></label>
            <input type="range" id="separationForce" min="0" max="3" step="0.1">
        </div>
        
        <div class="panel-subheader">World & Population</div>
        <div class="param-group">
            <label for="timeScale">World Speed: <span id="timeScaleValue"></span></label>
            <input type="range" id="timeScale" min="0.1" max="5" step="0.1">
        </div>
        <div class="param-group">
            <label for="foodSpawnRate">Food Spawn Rate: <span id="foodSpawnRateValue"></span></label>
            <input type="range" id="foodSpawnRate" min="0.1" max="2" step="0.1">
        </div>
        <div class="param-group">
            <label for="foodEnergy">Food Energy: <span id="foodEnergyValue"></span></label>
            <input type="range" id="foodEnergy" min="10" max="200" step="5">
        </div>
        <div class="param-group">
            <label for="preyTargetPopulation">Prey Target Pop: <span id="preyTargetPopulationValue"></span></label>
            <input type="range" id="preyTargetPopulation" min="50" max="500" step="10">
        </div>
        <div class="param-group">
            <label for="predatorTargetPopulation">Predator Target Pop: <span id="predatorTargetPopulationValue"></span></label>
            <input type="range" id="predatorTargetPopulation" min="10" max="100" step="5">
        </div>
        <div class="param-group">
            <label for="hunterTargetPopulation">Hunter Target Pop: <span id="hunterTargetPopulationValue"></span></label>
            <input type="range" id="hunterTargetPopulation" min="0" max="50" step="5">
        </div>
    </div>
    
    <div id="nn-visualization-panel">
        <h3>Genetic Improvement (Avg. Age)</h3>
        <canvas id="nnChartCanvas"></canvas>
        <button id="hide-nn-panel-button" class="ui-button">Hide Chart</button>
    </div>
    <button id="toggle-nn-panel-button" class="ui-button">Show Chart</button>

    <div id="zoom-controls">
        <button id="zoom-in-button" class="ui-button">+</button>
        <button id="zoom-out-button" class="ui-button">-</button>
    </div>

    <button id="show-panel-button" class="ui-button">Show Panel</button>

    <div id="game-over-overlay">
        <h1>GAME OVER</h1>
        <p>Prey population has gone extinct!</p>
        <div class="final-stats">
            <p>Total Ticks: <strong><span id="finalTicks">0</span></strong></p>
            <p>Total Prey Survival Ticks: <strong><span id="finalPreySurvival">0</span></strong></p>
            <p>Total Predator Survival Ticks: <strong><span id="finalPredatorSurvival">0</span></strong></p>
            <p>Total Hunter Survival Ticks: <strong><span id="finalHunterSurvival">0</span></strong></p>
            <p>Total Births: <strong><span id="finalBirths">0</span></strong></p>
            <p>Total Mutations: <strong><span id="finalMutations">0</span></strong></p>
        </div>
        <button id="restart-game-button" class="ui-button">Restart Simulation</button>
    </div>

    <script>
        // --- Game Configuration and Global Variables ---
        const config = {
            worldWidth: 2000, worldHeight: 1500, tileSize: 32,
            biomeColors: { water: 'hsl(200, 70%, 25%)', forest: 'hsl(80, 50%, 20%)', desert: 'hsl(40, 60%, 40%)' },
            noise: { scale: 0.005, octaves: 4, persistence: 0.5, waterLevel: -0.3, forestLevel: 0.2, waterBiasStrength: 0.5 },
            
            timeScale: 1.0, zoomLevel: 1.0,
            foodSpawnRate: 0.5, foodEnergy: 50,
            preyTargetPopulation: 200, predatorTargetPopulation: 50, hunterTargetPopulation: 10,
            
            hiddenLayerSize: 10,       
            mutationRate: 0.01,         
            mutationColorRange: 20,     
            alignmentForce: 1.0,       
            cohesionForce: 0.8,        
            separationForce: 1.5,      
            separationDistance: 20,    
            
            creatureSize: 8,
            preyMaxHealth: 100, predatorMaxHealth: 150, hunterMaxHealth: 200,
            preyReproductionThreshold: 95, 
            predatorReproductionThreshold: 140,
            hunterReproductionThreshold: 180,
            preyEnergyConsumption: 0.07,
            predatorEnergyConsumption: 0.12,
            hunterEnergyConsumption: 0.18,
            reproductionCost: 75,
            
            visionRange: 150, 
            
            quadtreeCapacity: 4, maxEntities: 1000
        };

        let canvas, ctx, simulationPaused = true, lastFrameTime = 0, entities = [], quadtree, entityIdCounter = 0;
        let cameraX = 0, cameraY = 0, isDragging = false, lastMouseX = 0, lastMouseY = 0;
        let followedEntity = null, targetZoom = 1.0, targetCameraX = 0, targetCameraY = 0;
        const CAMERA_LERP_SPEED = 0.08;
        let nnChart, chartLabels = [], avgPreyAgeData = [], avgPredatorAgeData = [], avgHunterAgeData = [];
        const CHART_UPDATE_INTERVAL = 120, MAX_CHART_POINTS = 100;
        let currentPreyCount = 0, currentPredatorCount = 0, currentHunterCount = 0, currentFoodCount = 0;
        let totalPreySurvivalTicks = 0, totalPredatorSurvivalTicks = 0, totalHunterSurvivalTicks = 0;
        let totalBirths = 0, totalGeneticMutations = 0, simulationTicks = 0, gameOver = false;
        let perlinNoise;
        
        // --- Vector, Rectangle, QuadTree, PerlinNoise Classes (Full, Readable Code) ---
        class Vector {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(other) { return new Vector(this.x + other.x, this.y + other.y); }
            sub(other) { return new Vector(this.x - other.x, this.y - other.y); }
            mult(scalar) { return new Vector(this.x * scalar, this.y * scalar); }
            div(scalar) { return new Vector(this.x / scalar, this.y / scalar); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { const m = this.mag(); return m > 0 ? this.div(m) : new Vector(0, 0); }
            setMag(magnitude) { return this.normalize().mult(magnitude); }
            limit(max) { if (this.mag() > max) { return this.setMag(max); } return this; }
            dist(other) { return this.sub(other).mag(); }
            angle() { return Math.atan2(this.y, this.x); }
            static random2D() { const angle = Math.random() * Math.PI * 2; return new Vector(Math.cos(angle), Math.sin(angle)); }
            copy() { return new Vector(this.x, this.y); }
        }

        class Rectangle {
            constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
            contains(point) { return (point.x >= this.x - this.w && point.x <= this.x + this.w && point.y >= this.y - this.h && point.y <= this.y + this.h); }
            intersects(range) { return !(range.x - range.w > this.x + this.w || range.x + range.w < this.x - this.w || range.y - range.h > this.y + this.h || range.y + range.h < this.y - this.h); }
        }

        class QuadTree {
            constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.entities = []; this.divided = false; }
            subdivide() { let x = this.boundary.x, y = this.boundary.y, w = this.boundary.w / 2, h = this.boundary.h / 2; this.northeast = new QuadTree(new Rectangle(x + w, y - h, w, h), this.capacity); this.northwest = new QuadTree(new Rectangle(x - w, y - h, w, h), this.capacity); this.southeast = new QuadTree(new Rectangle(x + w, y + h, w, h), this.capacity); this.southwest = new QuadTree(new Rectangle(x - w, y + h, w, h), this.capacity); this.divided = true; for (let entity of this.entities) { this.insert(entity); } this.entities = []; }
            insert(entity) { if (!this.boundary.contains(entity.position)) { return false; } if (this.entities.length < this.capacity && !this.divided) { this.entities.push(entity); return true; } else { if (!this.divided) { this.subdivide(); } if (this.northeast.insert(entity)) { return true; } if (this.northwest.insert(entity)) { return true; } if (this.southeast.insert(entity)) { return true; } if (this.southwest.insert(entity)) { return true; } } return false; }
            query(range, found = []) { if (!this.boundary.intersects(range)) { return found; } for (let entity of this.entities) { if (range.contains(entity.position)) { found.push(entity); } } if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); } return found; }
            clear() { this.entities = []; this.divided = false; this.northeast = null; this.northwest = null; this.southeast = null; this.southwest = null; }
        }
        
        const P = new Array(512); const PERM = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,178,243,109,86,242,102,220,83,208,82,60,204,244,196,174,251,193,249,173,192,205,124,150,89,147,48,206,231,38,1,101,163,179,113,228,207,209,17,9,47,61,106,73,202,238,145,155,186,171,154,210,100,211,166,20,230,24,64,104,16,246,250,116,218,114,63,76,181,28,200,12,66,105,107,59,18,65,110,253,254,255,127,199,198,164,180,74,201,141,123,97,25,126,134,138,111,175,98,187,189,248,115,55,135,212,125,146,161,162,176,168,144,226,143,188,93,14,133,121,167,46,108,169,130,172,165,136,191,213,232,156,239,170,39,183,119,112,100,52,29,19,132,122,227,27,253,139,67,100,34,81,185,100,217,215,221,80,214,245,68,2,78,140,241,70,10,235,172,50,49,159,157,177,44,153,195,129,58,77,222,174,182,184,236,195,216,224,197];
        function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); } function lerp(t, a, b) { return a + t * (b - a); } function grad(hash, x, y) { const h = hash & 15; const u = h < 8 ? x : y; const v = h < 4 ? y : h === 12 || h === 14 ? x : 0; return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v); }
        class PerlinNoise { constructor(seed = Date.now()) { this.seed = seed; this._initPermutation(); } _initPermutation() { for (let i = 0; i < 256; i++) { P[i] = P[i + 256] = PERM[i]; } let currentSeed = this.seed; function lcgRandom() { currentSeed = (currentSeed * 9301 + 49297) % 233280; return currentSeed / 233280; } for (let i = 0; i < 256; i++) { const j = Math.floor(lcgRandom() * 256); [P[i], P[j]] = [P[j], P[i]]; P[i + 256] = P[i]; P[j + 256] = P[j]; } } noise(x, y) { const X = Math.floor(x) & 255, Y = Math.floor(y) & 255; x -= Math.floor(x); y -= Math.floor(y); const u = fade(x), v = fade(y), A = P[X] + Y, AA = P[A], AB = P[A + 1], B = P[X + 1] + Y, BA = P[B], BB = P[B + 1]; return lerp(v, lerp(u, grad(P[AA], x, y), grad(P[BA], x - 1, y)), lerp(u, grad(P[AB], x, y - 1), grad(P[BB], x - 1, y - 1))); } }
        function getLayeredNoise(x, y) { let total = 0, frequency = config.noise.scale, amplitude = 1, maxAmplitude = 0; for (let i = 0; i < config.noise.octaves; i++) { total += perlinNoise.noise(x * frequency, y * frequency) * amplitude; maxAmplitude += amplitude; amplitude *= config.noise.persistence; frequency *= 2; } return total / maxAmplitude; }

        class NeuralNetwork {
            static INPUT_SIZE = 1 + (2 * 5); // Health + 5 types of entities (dist, angle)
            static OUTPUT_SIZE = 2;

            constructor(...layerSizes) {
                this.layerSizes = layerSizes.length ? layerSizes : [NeuralNetwork.INPUT_SIZE, config.hiddenLayerSize, NeuralNetwork.OUTPUT_SIZE];
                this.weights = [];
                this.biases = [];

                for (let i = 0; i < this.layerSizes.length - 1; i++) {
                    const rows = this.layerSizes[i + 1];
                    const cols = this.layerSizes[i];
                    this.weights.push(Array.from({ length: rows }, () => Array.from({ length: cols }, () => Math.random() * 2 - 1)));
                    this.biases.push(Array.from({ length: rows }, () => Math.random() * 2 - 1));
                }
            }

            static tanh(x) { return Math.tanh(x); }

            feedForward(inputs) {
                if (inputs.length !== this.layerSizes[0]) { console.error(`Input size mismatch. Expected ${this.layerSizes[0]}, got ${inputs.length}.`); const padded = inputs.slice(0, this.layerSizes[0]); while (padded.length < this.layerSizes[0]) padded.push(0); inputs = padded; }
                let currentOutputs = inputs;
                for (let i = 0; i < this.weights.length; i++) {
                    const nextOutputs = [];
                    const weightMatrix = this.weights[i];
                    const biasVector = this.biases[i];
                    for (let r = 0; r < weightMatrix.length; r++) {
                        let sum = 0;
                        for (let c = 0; c < weightMatrix[r].length; c++) { sum += currentOutputs[c] * weightMatrix[r][c]; }
                        nextOutputs.push(NeuralNetwork.tanh(sum + biasVector[r]));
                    }
                    currentOutputs = nextOutputs;
                }
                return currentOutputs;
            }

            copy() { const newNN = new NeuralNetwork(...this.layerSizes); newNN.weights = this.weights.map(m => m.map(r => [...r])); newNN.biases = this.biases.map(b => [...b]); return newNN; }
            
            mutate(rate) { let mutationsCount = 0; for (let i = 0; i < this.weights.length; i++) for (let r = 0; r < this.weights[i].length; r++) for (let c = 0; c < this.weights[i][r].length; c++) if (Math.random() < rate) { this.weights[i][r][c] += (Math.random() * 2 - 1) * 0.5; mutationsCount++; } for (let i = 0; i < this.biases.length; i++) for (let r = 0; r < this.biases[i].length; r++) if (Math.random() < rate) { this.biases[i][r] += (Math.random() * 2 - 1) * 0.5; mutationsCount++; } return mutationsCount; }
            
            static crossover(nn1, nn2) {
                if (nn1.layerSizes.join('-') !== nn2.layerSizes.join('-')) {
                    throw new Error("Cannot crossover NNs with different architectures.");
                }
                const childNN = new NeuralNetwork(...nn1.layerSizes);
                for (let i = 0; i < nn1.weights.length; i++) { const crossoverPointRow = Math.floor(Math.random() * nn1.weights[i].length), crossoverPointCol = Math.floor(Math.random() * nn1.weights[i][0].length); for (let r = 0; r < nn1.weights[i].length; r++) for (let c = 0; c < nn1.weights[i][r].length; c++) childNN.weights[i][r][c] = r < crossoverPointRow || (r === crossoverPointRow && c < crossoverPointCol) ? nn1.weights[i][r][c] : nn2.weights[i][r][c]; }
                for (let i = 0; i < nn1.biases.length; i++) { const crossoverPoint = Math.floor(Math.random() * nn1.biases[i].length); for (let r = 0; r < nn1.biases[i].length; r++) childNN.biases[i][r] = r < crossoverPoint ? nn1.biases[i][r] : nn2.biases[i][r]; }
                return childNN;
            }
        }

        class Entity {
            constructor(x, y, color, size, world) { this.position = new Vector(x, y); this.color = color; this.size = size; this.world = world; this.id = entityIdCounter++; this.isDead = false; this.trail = []; this.maxTrailLength = 5; }
            update() { this.trail.unshift(this.position.copy()); if (this.trail.length > this.maxTrailLength) { this.trail.pop(); } }
            draw(ctx) {}
        }

        class Creature extends Entity {
            constructor(x, y, color, size, world, nn, maxHealth, reproductionThreshold, energyConsumption, maxSpeed) { super(x, y, color, size, world); this.velocity = Vector.random2D().setMag(Math.random() * maxSpeed); this.acceleration = new Vector(0, 0); this.maxSpeed = maxSpeed; this.maxHealth = maxHealth; this.health = maxHealth; this.reproductionThreshold = reproductionThreshold; this.energyConsumption = energyConsumption; this.nn = nn; this.visionRange = config.visionRange; this.age = 0; }
            _addNormalizedInputs(inputs, { entity, dist }) { if (entity) { inputs.push(dist / this.visionRange); let relativeAngle = entity.position.sub(this.position).angle() - this.velocity.angle(); inputs.push(Math.atan2(Math.sin(relativeAngle), Math.cos(relativeAngle)) / Math.PI); } else { inputs.push(1); inputs.push(0); } }
            calculateFlocking(neighbors) {
                let alignmentSum = new Vector(0, 0), cohesionSum = new Vector(0, 0), separationSum = new Vector(0, 0);
                let a_count = 0, c_count = 0, s_count = 0;
                for (const other of neighbors) {
                    if (other.id === this.id) continue;
                    let d = this.position.dist(other.position);
                    if (d > 0 && d < this.visionRange) { alignmentSum = alignmentSum.add(other.velocity); a_count++; cohesionSum = cohesionSum.add(other.position); c_count++; }
                    if (d > 0 && d < config.separationDistance) { let diff = this.position.sub(other.position).normalize().div(d); separationSum = separationSum.add(diff); s_count++; }
                }
                let steer = new Vector(0, 0);
                if (a_count > 0) { steer = steer.add(alignmentSum.div(a_count).normalize().mult(this.maxSpeed).sub(this.velocity).limit(0.2).mult(config.alignmentForce)); }
                if (c_count > 0) { steer = steer.add(cohesionSum.div(c_count).sub(this.position).normalize().mult(this.maxSpeed).sub(this.velocity).limit(0.1).mult(config.cohesionForce)); }
                if (s_count > 0) { steer = steer.add(separationSum.div(s_count).normalize().mult(this.maxSpeed).sub(this.velocity).limit(0.3).mult(config.separationForce)); }
                return steer;
            }
            think(nearbyEntities) {
                let closest = { food: null, prey: null, predator: null, hunter: null, mate: null };
                let dists = { food: Infinity, prey: Infinity, predator: Infinity, hunter: Infinity, mate: Infinity };
                for (let e of nearbyEntities) {
                    if (e.id === this.id || e.isDead) continue;
                    const d = this.position.dist(e.position);
                    if (d >= this.visionRange) continue;
                    if (e instanceof Food && d < dists.food) { dists.food = d; closest.food = e; }
                    else if (e instanceof Prey && d < dists.prey) { dists.prey = d; closest.prey = e; }
                    else if (e instanceof Predator && d < dists.predator) { dists.predator = d; closest.predator = e; }
                    else if (e instanceof Hunter && d < dists.hunter) { dists.hunter = d; closest.hunter = e; }
                    if (this.constructor === e.constructor && e.health > e.reproductionThreshold * 0.8 && d < dists.mate) { dists.mate = d; closest.mate = e; }
                }
                const inputs = [this.health / this.maxHealth];
                this._addNormalizedInputs(inputs, { entity: closest.food, dist: dists.food });
                this._addNormalizedInputs(inputs, { entity: closest.prey, dist: dists.prey });
                this._addNormalizedInputs(inputs, { entity: closest.predator, dist: dists.predator });
                this._addNormalizedInputs(inputs, { entity: closest.hunter, dist: dists.hunter });
                this._addNormalizedInputs(inputs, { entity: closest.mate, dist: dists.mate });
                const outputs = this.nn.feedForward(inputs), desiredHeading = this.velocity.angle() + outputs[1] * (Math.PI / 8);
                const nnAcceleration = new Vector(Math.cos(desiredHeading), Math.sin(desiredHeading)).setMag(((outputs[0] + 1) / 2) * 0.2);
                const flockingForce = this.calculateFlocking(nearbyEntities.filter(e => e.constructor === this.constructor));
                this.acceleration = this.acceleration.add(nnAcceleration).add(flockingForce);
            }
            move() { this.velocity = this.velocity.add(this.acceleration).limit(this.maxSpeed); this.position = this.position.add(this.velocity.mult(config.timeScale)); this.acceleration = new Vector(0, 0); if (this.position.x < 0) this.position.x = this.world.width; if (this.position.x > this.world.width) this.position.x = 0; if (this.position.y < 0) this.position.y = this.world.height; if (this.position.y > this.world.height) this.position.y = 0; }
            updateHealth() { this.health -= this.energyConsumption * config.timeScale; if (this.health <= 0) this.isDead = true; }
            reproduce(mateNN = null) { if (this.health >= this.reproductionThreshold) { const childNN = mateNN ? NeuralNetwork.crossover(this.nn, mateNN) : this.nn.copy(); const mutations = childNN.mutate(config.mutationRate); totalGeneticMutations += mutations; let childColor = this.color; if (mutations > 0) { childColor = (this.color + (Math.random() * 2 * config.mutationColorRange - config.mutationColorRange) + 360) % 360; } const offset = Vector.random2D().mult(this.size * 2); const child = new(this.constructor)(this.position.x + offset.x, this.position.y + offset.y, this.world, childNN, childColor); this.health -= config.reproductionCost; totalBirths++; return child; } return null; }
            eat(target, energy) { this.health += energy; this.health = Math.min(this.health, this.maxHealth); target.isDead = true; }
            update() {
                super.update(); this.age += config.timeScale; this.updateHealth(); if (this.isDead) return;
                const nearby = quadtree.query(new Rectangle(this.position.x, this.position.y, this.visionRange, this.visionRange));
                for (let e of nearby) { if (e.id === this.id || e.isDead) continue; if (this.position.dist(e.position) < this.size / 2 + e.size / 2) { if (this instanceof Prey && e instanceof Food) this.eat(e, config.foodEnergy); else if (this instanceof Predator && e instanceof Prey) this.eat(e, e.maxHealth * 0.5); else if (this instanceof Hunter) { if (e instanceof Prey) this.eat(e, e.maxHealth * 0.75); else if (e instanceof Predator) this.eat(e, e.maxHealth * 1.0) } } }
                this.think(nearby); this.move();
                if (this.health >= this.reproductionThreshold) { const mate = nearby.find(e => e.constructor === this.constructor && e.id !== this.id && !e.isDead && e.health > e.reproductionThreshold * 0.8 && this.position.dist(e.position) < this.size * 2); if (mate) { const child = this.reproduce(mate.nn); if (child && entities.length < config.maxEntities) entities.push(child); } }
            }
            draw(ctx) { const h = this.health / this.maxHealth, b = Math.max(0.2, Math.min(1.0, h * 1.2)), a = Math.max(0.1, Math.min(0.8, h * 0.7 + 0.1)); if (this.trail.length > 1) { ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { const p = this.trail[i]; ctx.strokeStyle = `hsla(${this.color}, 100%, 50%, ${a * (1 - (i / this.maxTrailLength))})`; ctx.lineWidth = this.size * (1 - (i / this.maxTrailLength)) / 2; ctx.lineTo(p.x, p.y); } ctx.stroke(); } ctx.shadowBlur = this.size * 1.5; ctx.shadowColor = `hsla(${this.color}, 100%, 50%, ${a})`; ctx.fillStyle = `hsla(${this.color}, 100%, ${b * 100}%, ${a})`; ctx.beginPath(); if (this instanceof Prey) { ctx.arc(this.position.x, this.position.y, this.size / 2, 0, Math.PI * 2); } else if (this instanceof Predator) { const an = this.velocity.angle(), tX = this.position.x + Math.cos(an) * this.size / 2, tY = this.position.y + Math.sin(an) * this.size / 2, bA1 = an + (2 * Math.PI / 3), bA2 = an - (2 * Math.PI / 3); ctx.moveTo(tX, tY); ctx.lineTo(this.position.x + Math.cos(bA1) * this.size / 2, this.position.y + Math.sin(bA1) * this.size / 2); ctx.lineTo(this.position.x + Math.cos(bA2) * this.size / 2, this.position.y + Math.sin(bA2) * this.size / 2); ctx.closePath(); } else if (this instanceof Hunter) { const an = this.velocity.angle(), hS = this.size * 0.7, s2 = Math.sqrt(2); const p1 = {x: this.position.x + Math.cos(an) * hS * s2, y: this.position.y + Math.sin(an) * hS * s2}; const p2 = {x: this.position.x + Math.cos(an + Math.PI/2) * hS, y: this.position.y + Math.sin(an + Math.PI/2) * hS}; const p3 = {x: this.position.x - Math.cos(an) * hS * s2, y: this.position.y - Math.sin(an) * hS * s2}; const p4 = {x: this.position.x - Math.cos(an + Math.PI/2) * hS, y: this.position.y - Math.sin(an + Math.PI/2) * hS}; ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y); ctx.closePath(); } ctx.fill(); ctx.shadowBlur = 0; ctx.shadowColor = 'transparent'; ctx.lineWidth = 1; }
        }

        class Prey extends Creature { constructor(x,y,w,nn=null,c=120){super(x,y,c,config.creatureSize,w,nn||new NeuralNetwork(),config.preyMaxHealth,config.preyReproductionThreshold,config.preyEnergyConsumption,3.5);}}
        class Predator extends Creature { constructor(x,y,w,nn=null,c=0){super(x,y,c,config.creatureSize+2,w,nn||new NeuralNetwork(),config.predatorMaxHealth,config.predatorReproductionThreshold,config.predatorEnergyConsumption,4.0);}}
        class Hunter extends Creature { constructor(x,y,w,nn=null,c=280){super(x,y,c,config.creatureSize+4,w,nn||new NeuralNetwork(),config.hunterMaxHealth,config.hunterReproductionThreshold,config.hunterEnergyConsumption,4.5);}}
        class Food extends Entity { constructor(x,y,w){const h=240,s=config.creatureSize/2+(Math.random()*2-1)*(config.creatureSize/8);super(x,y,h,s,w)} draw(ctx){ctx.shadowBlur=this.size*2;ctx.shadowColor=`hsla(${this.color}, 100%, 70%, 0.5)`;ctx.fillStyle=`hsla(${this.color}, 100%, 80%, 0.8)`;ctx.beginPath();ctx.arc(this.position.x,this.position.y,this.size/2,0,Math.PI*2);ctx.fill();ctx.shadowBlur=0;ctx.shadowColor='transparent'} }

        function formatTime(t){const s=Math.floor(t/60),h=Math.floor(s/3600),m=Math.floor((s%3600)/60),c=s%60,p=n=>String(n).padStart(2,'0');return`${p(h)}:${p(m)}:${p(c)}`}
        
        // --- Management and Drawing Functions (Full, Readable Code) ---
        function initSimulation() { canvas = document.getElementById('gameCanvas'); ctx = canvas.getContext('2d'); perlinNoise = new PerlinNoise(Date.now()); setupUI(); resizeCanvas(); window.addEventListener('resize', resizeCanvas); quadtree = new QuadTree(new Rectangle(config.worldWidth / 2, config.worldHeight / 2, config.worldWidth / 2, config.worldHeight / 2), config.quadtreeCapacity); setupCanvasEvents(); generateInitialPopulation(); initNNChart(); drawSimulation(); }
        function handleEntityClick(e) { const rect = canvas.getBoundingClientRect(), worldX = (e.clientX - rect.left) / config.zoomLevel + cameraX, worldY = (e.clientY - rect.top) / config.zoomLevel + cameraY, clickPos = new Vector(worldX, worldY); let closestEntity = null, minDistance = Infinity; const searchRadius = 50 / config.zoomLevel, nearbyEntities = quadtree.query(new Rectangle(worldX, worldY, searchRadius, searchRadius)); for (const entity of nearbyEntities) { if (entity instanceof Food) continue; const dist = clickPos.dist(entity.position); if (dist < entity.size * 1.5 && dist < minDistance) { minDistance = dist; closestEntity = entity; } } if (closestEntity) { if (followedEntity === closestEntity) { followedEntity = null; } else { followedEntity = closestEntity; targetZoom = 1.8; } } else { followedEntity = null; } }
        function setupCanvasEvents() { let dragged = false; canvas.addEventListener('mousedown', e => { if (e.button === 0) { isDragging = true; dragged = false; lastMouseX = e.clientX; lastMouseY = e.clientY; if (!followedEntity) canvas.classList.add('dragging'); } }); canvas.addEventListener('mousemove', e => { if (isDragging) { const dx = e.clientX - lastMouseX, dy = e.clientY - lastMouseY; if (Math.abs(dx) > 3 || Math.abs(dy) > 3) dragged = true; if (!followedEntity) { targetCameraX -= dx / config.zoomLevel; targetCameraY -= dy / config.zoomLevel; lastMouseX = e.clientX; lastMouseY = e.clientY; } } }); canvas.addEventListener('mouseup', e => { if (e.button === 0) { if (!dragged) handleEntityClick(e); isDragging = false; canvas.classList.remove('dragging'); } }); canvas.addEventListener('mouseleave', () => { isDragging = false; canvas.classList.remove('dragging'); }); canvas.addEventListener('touchstart', e => { if (e.touches.length === 1) { isDragging = true; dragged = false; lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY; if (!followedEntity) canvas.classList.add('dragging'); } }, { passive: true }); canvas.addEventListener('touchmove', e => { if (isDragging && e.touches.length === 1) { const dx = e.touches[0].clientX - lastMouseX, dy = e.touches[0].clientY - lastMouseY; if (Math.abs(dx) > 5 || Math.abs(dy) > 5) dragged = true; if (!followedEntity) { targetCameraX -= dx / config.zoomLevel; targetCameraY -= dy / config.zoomLevel; lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY; } } }, { passive: true }); canvas.addEventListener('touchend', e => { if (!dragged && e.changedTouches.length > 0) handleEntityClick(e.changedTouches[0]); isDragging = false; canvas.classList.remove('dragging'); }); canvas.addEventListener('contextmenu', e => e.preventDefault()); }
        function updateCamera() { if (followedEntity) { if (followedEntity.isDead) { followedEntity = null; } else { targetCameraX = followedEntity.position.x - (canvas.width / targetZoom / 2); targetCameraY = followedEntity.position.y - (canvas.height / targetZoom / 2); } } config.zoomLevel += (targetZoom - config.zoomLevel) * CAMERA_LERP_SPEED; cameraX += (targetCameraX - cameraX) * CAMERA_LERP_SPEED; cameraY += (targetCameraY - cameraY) * CAMERA_LERP_SPEED; clampCamera(); }
        function clampCamera() { const worldViewWidth = canvas.width / config.zoomLevel, worldViewHeight = canvas.height / config.zoomLevel; const maxX = config.worldWidth - worldViewWidth, maxY = config.worldHeight - worldViewHeight; targetCameraX = Math.max(0, Math.min(targetCameraX, maxX < 0 ? 0 : maxX)); targetCameraY = Math.max(0, Math.min(targetCameraY, maxY < 0 ? 0 : maxY)); cameraX = Math.max(0, Math.min(cameraX, maxX < 0 ? 0 : maxX)); cameraY = Math.max(0, Math.min(cameraY, maxY < 0 ? 0 : maxY)); }
        function generateInitialPopulation() { entities = []; totalBirths = 0; totalGeneticMutations = 0; simulationTicks = 0; totalPreySurvivalTicks = 0; totalPredatorSurvivalTicks = 0; totalHunterSurvivalTicks = 0; gameOver = false; followedEntity = null; chartLabels = []; avgPreyAgeData = []; avgPredatorAgeData = []; avgHunterAgeData = []; if (nnChart) { nnChart.data.labels = chartLabels; nnChart.data.datasets[0].data = avgPreyAgeData; nnChart.data.datasets[1].data = avgPredatorAgeData; nnChart.data.datasets[2].data = avgHunterAgeData; nnChart.update(); } const fZE = config.worldWidth * 0.4; for (let i = 0; i < config.preyTargetPopulation; i++) entities.push(new Prey(Math.random() * fZE, Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); const cSMX = config.worldWidth * 0.2, cSMaX = config.worldWidth * 0.8; for (let i = 0; i < config.predatorTargetPopulation; i++) entities.push(new Predator(cSMX + Math.random() * (cSMaX - cSMX), Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); const hSMX = config.worldWidth * 0.4, hSMaX = config.worldWidth * 0.6; for (let i = 0; i < config.hunterTargetPopulation; i++) entities.push(new Hunter(hSMX + Math.random() * (hSMaX - hSMX), Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); for (let i = 0; i < config.preyTargetPopulation * 2; i++) entities.push(new Food(Math.random() * fZE, Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); updateEntityCounts(); updateTopEntitiesPanel(); }
        function updateSimulation() { if (simulationPaused || gameOver) return; simulationTicks++; quadtree.clear(); for (let e of entities) if (!e.isDead) quadtree.insert(e); let newEntities = []; for (let entity of entities) { if (!entity.isDead) { if (entity instanceof Prey) totalPreySurvivalTicks += config.timeScale; else if (entity instanceof Predator) totalPredatorSurvivalTicks += config.timeScale; else if (entity instanceof Hunter) totalHunterSurvivalTicks += config.timeScale; entity.update(); if (!entity.isDead) newEntities.push(entity); } } entities = newEntities; updateEntityCounts(); if (simulationTicks % 60 === 0) updateTopEntitiesPanel(); if (simulationTicks % CHART_UPDATE_INTERVAL === 0) updateNNChartData(); if (currentPreyCount === 0 && !gameOver && simulationTicks > 10) { endGame(); return; } const foodZoneEnd = config.worldWidth * 0.4, predatorDenStart = config.worldWidth * 0.6, hunterSpawnMinX = config.worldWidth * 0.4, hunterSpawnMaxX = config.worldWidth * 0.6; if (Math.random() < config.foodSpawnRate * config.timeScale && entities.length < config.maxEntities) entities.push(new Food(Math.random() * foodZoneEnd, Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); if (currentPreyCount < config.preyTargetPopulation && entities.length < config.maxEntities) entities.push(new Prey(Math.random() * foodZoneEnd, Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); if (currentPredatorCount < config.predatorTargetPopulation && entities.length < config.maxEntities) entities.push(new Predator(predatorDenStart + Math.random() * (config.worldWidth - predatorDenStart), Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); if (currentHunterCount < config.hunterTargetPopulation && entities.length < config.maxEntities) entities.push(new Hunter(hunterSpawnMinX + Math.random() * (hunterSpawnMaxX - hunterSpawnMinX), Math.random() * config.worldHeight, { width: config.worldWidth, height: config.worldHeight })); }
        function updateTopEntitiesPanel() { const lists = { 'prey': { entities: [], container: document.getElementById('top-prey-list'), class: 'prey-btn' }, 'predators': { entities: [], container: document.getElementById('top-predators-list'), class: 'predator-btn' }, 'hunters': { entities: [], container: document.getElementById('top-hunters-list'), class: 'hunter-btn' } }; for (const e of entities) { if (e instanceof Prey) lists.prey.entities.push(e); else if (e instanceof Predator) lists.predators.entities.push(e); else if (e instanceof Hunter) lists.hunters.entities.push(e); } for (const key in lists) { const list = lists[key]; const topEntities = list.entities.sort((a, b) => b.age - a.age).slice(0, 3); list.container.innerHTML = ''; if (topEntities.length === 0) { list.container.textContent = "None"; } else { topEntities.forEach(entity => { const button = document.createElement('button'); button.className = `top-entity-button ${list.class}`; button.textContent = `#${entity.id} (Age: ${Math.floor(entity.age/60)})`; button.title = `Click to follow ${entity.constructor.name} #${entity.id}`; button.addEventListener('click', () => { if (entities.includes(entity)) { followedEntity = entity; targetZoom = 1.8; } }); list.container.appendChild(button); }); } } }
        function updateNNChartData() { if (!nnChart) return; let preyAges = 0, predatorAges = 0, hunterAges = 0; entities.forEach(e => { if (e instanceof Prey) preyAges += e.age; else if (e instanceof Predator) predatorAges += e.age; else if (e instanceof Hunter) hunterAges += e.age; }); const avgPrey = currentPreyCount > 0 ? (preyAges / currentPreyCount) / 60 : 0; const avgPredator = currentPredatorCount > 0 ? (predatorAges / currentPredatorCount) / 60 : 0; const avgHunter = currentHunterCount > 0 ? (hunterAges / currentHunterCount) / 60 : 0; chartLabels.push(simulationTicks); avgPreyAgeData.push(avgPrey); avgPredatorAgeData.push(avgPredator); avgHunterAgeData.push(avgHunter); if (chartLabels.length > MAX_CHART_POINTS) { chartLabels.shift(); avgPreyAgeData.shift(); avgPredatorAgeData.shift(); avgHunterAgeData.shift(); } nnChart.update('none'); }
        function updateEntityCounts() { currentPreyCount = 0; currentPredatorCount = 0; currentHunterCount = 0; currentFoodCount = 0; for (const entity of entities) { if (entity instanceof Prey) currentPreyCount++; else if (entity instanceof Predator) currentPredatorCount++; else if (entity instanceof Hunter) currentHunterCount++; else if (entity instanceof Food) currentFoodCount++; } }
        function endGame() { simulationPaused = true; gameOver = true; document.getElementById('start-pause-button').textContent = 'Restart Simulation'; displayGameOverStats(); }
        function displayGameOverStats() { const overlay = document.getElementById('game-over-overlay'); overlay.querySelector('#finalTicks').textContent = simulationTicks; overlay.querySelector('#finalPreySurvival').textContent = formatTime(totalPreySurvivalTicks); overlay.querySelector('#finalPredatorSurvival').textContent = formatTime(totalPredatorSurvivalTicks); overlay.querySelector('#finalHunterSurvival').textContent = formatTime(totalHunterSurvivalTicks); overlay.querySelector('#finalBirths').textContent = totalBirths; overlay.querySelector('#finalMutations').textContent = totalGeneticMutations; overlay.classList.add('visible'); }
        function hideGameOverStats() { document.getElementById('game-over-overlay').classList.remove('visible'); }
        function drawLandscape(ctx) { const tilePx = config.tileSize; const startTileX = Math.floor(cameraX / tilePx), endTileX = Math.ceil((cameraX + canvas.width / config.zoomLevel) / tilePx); const startTileY = Math.floor(cameraY / tilePx), endTileY = Math.ceil((cameraY + canvas.height / config.zoomLevel) / tilePx); for (let x = startTileX; x < endTileX; x++) { for (let y = startTileY; y < endTileY; y++) { const worldX = x * tilePx, worldY = y * tilePx; if (worldX >= config.worldWidth || worldY >= config.worldHeight || worldX < 0 || worldY < 0) continue; let heightValue = getLayeredNoise(worldX, worldY); const distToCenter = Math.sqrt(Math.pow(worldX + tilePx / 2 - config.worldWidth / 2, 2) + Math.pow(worldY + tilePx / 2 - config.worldHeight / 2, 2)); const waterRadius = Math.min(config.worldWidth, config.worldHeight) * 0.3; if (distToCenter < waterRadius) { heightValue -= fade(1 - distToCenter / waterRadius) * config.noise.waterBiasStrength; } let tileColor; if (heightValue < config.noise.waterLevel) tileColor = config.biomeColors.water; else if (heightValue < config.noise.forestLevel) tileColor = config.biomeColors.forest; else tileColor = config.biomeColors.desert; ctx.fillStyle = tileColor; ctx.fillRect(worldX, worldY, tilePx, tilePx); } } }
        function drawSimulation() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = 'hsl(240, 50%, 5%)'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.translate(-cameraX * config.zoomLevel, -cameraY * config.zoomLevel); ctx.scale(config.zoomLevel, config.zoomLevel); drawLandscape(ctx); for (let e of entities) e.draw(ctx); ctx.restore(); const indicator = document.getElementById('follow-indicator'), status = document.getElementById('follow-status'); if (followedEntity && !followedEntity.isDead) { const screenX = (followedEntity.position.x - cameraX) * config.zoomLevel, screenY = (followedEntity.position.y - cameraY) * config.zoomLevel; const indicatorSize = followedEntity.size * 2 * config.zoomLevel; if (screenX > -indicatorSize && screenX < canvas.width + indicatorSize && screenY > -indicatorSize && screenY < canvas.height + indicatorSize) { indicator.style.width = `${indicatorSize}px`; indicator.style.height = `${indicatorSize}px`; indicator.style.transform = `translate(${screenX - indicatorSize / 2}px, ${screenY - indicatorSize / 2}px)`; indicator.classList.add('visible'); } else { indicator.classList.remove('visible'); } status.textContent = `Following ${followedEntity.constructor.name} #${followedEntity.id}`; status.classList.add('visible'); } else { indicator.classList.remove('visible'); status.classList.remove('visible'); } document.getElementById('preyCount').textContent = currentPreyCount; document.getElementById('predatorCount').textContent = currentPredatorCount; document.getElementById('hunterCount').textContent = currentHunterCount; document.getElementById('foodCount').textContent = currentFoodCount; document.getElementById('totalPreySurvivalTime').textContent = formatTime(totalPreySurvivalTicks); document.getElementById('totalPredatorSurvivalTime').textContent = formatTime(totalPredatorSurvivalTicks); document.getElementById('totalHunterSurvivalTime').textContent = formatTime(totalHunterSurvivalTicks); document.getElementById('totalBirths').textContent = totalBirths; document.getElementById('totalGeneticMutations').textContent = totalGeneticMutations; document.getElementById('simulationTicks').textContent = simulationTicks; }
        function gameLoop(currentTime) { lastFrameTime = currentTime; updateCamera(); updateSimulation(); drawSimulation(); requestAnimationFrame(gameLoop); }
        function resizeCanvas() { canvas.width = window.innerWidth; const sP = document.getElementById('stats-panel'), tEP = document.getElementById('top-entities-panel'); const panelsHeight = (sP ? sP.offsetHeight : 0) + (tEP ? tEP.offsetHeight : 0), margin = 20; canvas.height = window.innerHeight - (panelsHeight + margin); if (canvas.height < 0) canvas.height = 0; const scaleX = canvas.width / config.worldWidth, scaleY = canvas.height / config.worldHeight; config.zoomLevel = Math.min(scaleX, scaleY); config.zoomLevel = Math.max(config.zoomLevel, 0.1); targetZoom = config.zoomLevel; cameraX = (config.worldWidth - canvas.width / config.zoomLevel) / 2; cameraY = (config.worldHeight - canvas.height / config.zoomLevel) / 2; targetCameraX = cameraX; targetCameraY = cameraY; clampCamera(); quadtree = new QuadTree(new Rectangle(config.worldWidth / 2, config.worldHeight / 2, config.worldWidth / 2, config.worldHeight / 2), config.quadtreeCapacity); drawSimulation(); }
        function initNNChart() { const chartCtx = document.getElementById('nnChartCanvas').getContext('2d'); nnChart = new Chart(chartCtx, { type: 'line', data: { labels: chartLabels, datasets: [{ label: 'Prey Avg Age', data: avgPreyAgeData, borderColor: 'hsl(120, 100%, 50%)', borderWidth: 2, tension: 0.3, pointRadius: 0 }, { label: 'Predator Avg Age', data: avgPredatorAgeData, borderColor: 'hsl(0, 100%, 50%)', borderWidth: 2, tension: 0.3, pointRadius: 0 }, { label: 'Hunter Avg Age', data: avgHunterAgeData, borderColor: 'hsl(280, 100%, 60%)', borderWidth: 2, tension: 0.3, pointRadius: 0 }] }, options: { animation: false, responsive: true, maintainAspectRatio: true, scales: { x: { ticks: { color: '#ccc' }, grid: { color: 'rgba(255,255,255,0.1)' } }, y: { beginAtZero: true, ticks: { color: '#ccc' }, grid: { color: 'rgba(255,255,255,0.1)' }, title: { display: true, text: 'Avg. Age (sec)', color: '#ccc' } } }, plugins: { legend: { labels: { color: '#eee' } } } } }); }
        
        function setupUI() {
            const uiElements = { startPauseButton: 'start-pause-button', togglePanelButton: 'toggle-panel-button', uiPanel: 'ui-panel', zoomControls: 'zoom-controls', zoomInButton: 'zoom-in-button', zoomOutButton: 'zoom-out-button', showPanelButton: 'show-panel-button', restartGameButton: 'restart-game-button', nnPanel: 'nn-visualization-panel', hideNNButton: 'hide-nn-panel-button', showNNButton: 'toggle-nn-panel-button' };
            for (const key in uiElements) { uiElements[key] = document.getElementById(uiElements[key]); }

            const sliders = [
                { id: 'timeScale', prop: 'timeScale', valueSpan: 'timeScaleValue', precision: 1 },
                { id: 'mutationRate', prop: 'mutationRate', valueSpan: 'mutationRateValue', precision: 3 },
                { id: 'foodSpawnRate', prop: 'foodSpawnRate', valueSpan: 'foodSpawnRateValue', precision: 1 },
                { id: 'foodEnergy', prop: 'foodEnergy', valueSpan: 'foodEnergyValue', precision: 0 },
                { id: 'preyTargetPopulation', prop: 'preyTargetPopulation', valueSpan: 'preyTargetPopulationValue', precision: 0 },
                { id: 'predatorTargetPopulation', prop: 'predatorTargetPopulation', valueSpan: 'predatorTargetPopulationValue', precision: 0 },
                { id: 'hunterTargetPopulation', prop: 'hunterTargetPopulation', valueSpan: 'hunterTargetPopulationValue', precision: 0 },
                { id: 'hiddenLayerSize', prop: 'hiddenLayerSize', valueSpan: 'hiddenLayerSizeValue', precision: 0, requiresReset: true }, // BUG FIX
                { id: 'alignmentForce', prop: 'alignmentForce', valueSpan: 'alignmentForceValue', precision: 1 },
                { id: 'cohesionForce', prop: 'cohesionForce', valueSpan: 'cohesionForceValue', precision: 1 },
                { id: 'separationForce', prop: 'separationForce', valueSpan: 'separationForceValue', precision: 1 },
            ];

            sliders.forEach(s => {
                const el = document.getElementById(s.id);
                const vs = document.getElementById(s.valueSpan);
                el.value = config[s.prop];
                vs.textContent = parseFloat(config[s.prop]).toFixed(s.precision);
                
                // BUG FIX: Use 'change' event for sliders that require a reset, 'input' for others.
                const eventType = s.requiresReset ? 'change' : 'input';

                el.addEventListener(eventType, e => {
                    config[s.prop] = parseFloat(e.target.value);
                    vs.textContent = config[s.prop].toFixed(s.precision);
                    
                    // BUG FIX: If the slider requires a reset, pause and reset the simulation.
                    if (s.requiresReset) {
                        simulationPaused = true;
                        uiElements.startPauseButton.textContent = 'Start New Simulation';
                        gameOver = false;
                        hideGameOverStats();
                        generateInitialPopulation();
                        drawSimulation();
                    }
                });
            });

            uiElements.startPauseButton.addEventListener('click', () => { if (gameOver) { hideGameOverStats(); generateInitialPopulation(); simulationPaused = false; uiElements.startPauseButton.textContent = 'Pause Simulation'; } else { simulationPaused = !simulationPaused; uiElements.startPauseButton.textContent = simulationPaused ? 'Resume Simulation' : 'Pause Simulation'; } if (!simulationPaused) lastFrameTime = performance.now(); });
            uiElements.togglePanelButton.addEventListener('click', () => { const h = uiElements.uiPanel.classList.toggle('hidden'); uiElements.zoomControls.classList.toggle('visible', h); uiElements.showPanelButton.classList.toggle('visible', h); });
            uiElements.showPanelButton.addEventListener('click', () => { uiElements.uiPanel.classList.remove('hidden'); uiElements.zoomControls.classList.remove('visible'); uiElements.showPanelButton.classList.remove('visible'); });
            const toggleNNPanel = () => { const h = uiElements.nnPanel.classList.toggle('hidden'); uiElements.showNNButton.classList.toggle('visible', h); };
            uiElements.hideNNButton.addEventListener('click', toggleNNPanel);
            uiElements.showNNButton.addEventListener('click', toggleNNPanel);
            uiElements.zoomInButton.addEventListener('click', () => { followedEntity = null; targetZoom = Math.min(targetZoom * 1.25, 5.0); });
            uiElements.zoomOutButton.addEventListener('click', () => { followedEntity = null; targetZoom = Math.max(targetZoom * 0.8, 0.1); });
            uiElements.restartGameButton.addEventListener('click', () => { hideGameOverStats(); generateInitialPopulation(); simulationPaused = false; uiElements.startPauseButton.textContent = 'Pause Simulation'; lastFrameTime = performance.now(); });
        }

        document.addEventListener('DOMContentLoaded', () => { initSimulation(); lastFrameTime = performance.now(); requestAnimationFrame(gameLoop); });
    
    </script>
    <script>
      if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('./sw.js').then(reg => console.log('SW registered:', reg.scope)).catch(err => console.error('SW registration failed:', err)); }); }
    </script>
</body>
</html>