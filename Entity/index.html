<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Mini-RPG: The 2D Adventure</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- NEW: Icon Enhancement Styles -->
    <style>
        /* General flair for all icons in slots */
        .action-slot i, .inventory-slot i {
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            transition: transform 0.2s ease-out, text-shadow 0.2s ease-out;
            will-change: transform;
        }

        /* Make icons feel interactive on hover */
        .action-slot:hover i, .inventory-slot:hover i {
            transform: scale(1.15);
        }
        
        /* --- Quality-Based Glows --- */
        /* Magic items get a subtle blue glow */
        .quality-magic {
            text-shadow: 0 0 7px var(--color-text-magic), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
        }
        /* Rare items get a brighter blue glow */
        .quality-rare {
            text-shadow: 0 0 10px var(--color-text-rare), 0 0 3px var(--color-text-rare), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
        }
        /* Epic items get a powerful, animated purple glow */
        .quality-epic {
            text-shadow: 0 0 12px var(--color-text-epic), 0 0 5px var(--color-text-epic), 1px 1px 3px rgba(0, 0, 0, 0.8) !important;
            animation: epic-glow 2s infinite alternate ease-in-out;
        }
        
        @keyframes epic-glow {
            from { text-shadow: 0 0 12px var(--color-text-epic), 0 0 5px var(--color-text-epic), 1px 1px 3px rgba(0, 0, 0, 0.8); }
            to   { text-shadow: 0 0 20px var(--color-text-epic), 0 0 8px #fff, 1px 1px 3px rgba(0, 0, 0, 0.8); }
        }

        /* --- Thematic Icon Coloring & Styling --- */
        /* Abilities */
        .fa-burst { color: #ffffa0; } /* A bright flash for a slash */
        .fa-fire-flame-curved { color: #ff8c00; } /* A fiery orange for Fireball */
        .fa-gavel { color: #c39c6d; } /* Hammer of Justice */
        .fa-shield-heart { color: #e0e0e0; } /* Divine Protection */
        .fa-book-skull { color: #8b008b; } /* Curse */
        
        /* Professions & World Objects */
        .fa-leaf { color: #228b22; } /* Herb */
        .fa-person-digging { color: #cd7f32; } /* Mining Node */
        .fa-hammer { color: #a9a9a9; } /* Blacksmith */
        .fa-ghost { color: #a0c4ff; } /* Spirit Healer */
        .fa-dove { color: #ffd700; } /* Flight Master */
        .fa-shop { color: #c0c0c0; } /* Vendor */
        .fa-chair { color: #8b4513; } /* Woodworking bench */

        /* Weapons */
        .fa-sword { color: #A9A9A9; } /* A dull grey for a rusty sword */
        .fa-scythe { color: #E0E0E0; } /* A sharp silver for a forged blade */
        
        /* Armor */
        .fa-vest-patches { color: #8B4513; } /* A leathery brown for a vest */
        .fa-jedi { color: #f0f0f0; } /* A light color for robes */

        /* Consumables & Materials */
        .fa-flask-vial { color: #2E8B57; } /* A healing green for potions */
        .fa-network-wired { color: #F5F5F5; } /* A silvery white for spider silk */
        .fa-tooth { color: #FFFAF0; } /* An off-white for a fang */
    </style>

    <style>
        :root {
            --color-health: #28a745;
            --color-mana: #007bff;
            --color-xp: #9370db;
            --color-xp-rested: #00bfff;
            --color-enemy-health: #dc3545;
            --color-bg-dark: #1a1a1a;
            --color-bg-medium: #2a2a2e;
            --color-bg-light: #3a3a40;
            --color-border: #4f4f58;
            --color-text: #f0f0f0;
            --color-text-muted: #888;
            --color-text-quest: #ffd700;
            --color-text-magic: #87ceeb;
            --color-text-rare: #0070dd;
            --color-text-epic: #a335ee;
            --color-cooldown: rgba(0, 0, 0, 0.75);
            --font-main: 'Verdana', sans-serif;
            --color-gold: #ffd700;
            --color-silver: #c0c0c0;
            --color-copper: #b87333;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--color-bg-dark);
            font-family: var(--font-main); color: var(--color-text);
            user-select: none; -webkit-user-select: none;
        }
        #game-container { position: relative; width: 100%; height: 100%; }
        /* --- NEW: Added a subtle filter for atmosphere --- */
        #game-canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            filter: saturate(1.1) contrast(1.05);
        }
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        .unit-frame {
            position: absolute; top: 20px; width: 250px; background-color: var(--color-bg-medium);
            border: 1px solid var(--color-border); border-radius: 5px; padding: 5px;
            display: flex; gap: 10px; align-items: center; pointer-events: all;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #player-frame { left: 20px; }
        #target-frame { left: 290px; display: none; }
        .portrait {
            width: 50px; height: 50px; background: var(--color-bg-dark);
            border: 2px solid var(--color-border); border-radius: 5px;
            display: flex; justify-content: center; align-items: center; font-size: 30px;
        }
        .unit-info { flex-grow: 1; }
        .name-level { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .resource-bar {
            width: 100%; height: 15px; background-color: var(--color-bg-dark);
            border-radius: 3px; overflow: hidden; margin-top: 2px; position: relative;
        }
        .resource-bar .bar-fill { height: 100%; transition: width 0.2s ease-out; }
        .resource-bar .bar-text {
            position: absolute; width: 100%; text-align: center;
            font-size: 10px; line-height: 15px; color: white; text-shadow: 1px 1px 1px black;
        }
        #player-health-fill { background-color: var(--color-health); }
        #player-mana-fill { background-color: var(--color-mana); }
        #target-health-fill { background-color: var(--color-enemy-health); }

        /* --- NEW: Buff/Debuff Area --- */
        .buff-container {
            display: flex;
            gap: 3px;
            margin-top: 4px;
            height: 24px;
        }
        .buff-icon {
            width: 22px; height: 22px;
            background-color: var(--color-bg-dark);
            border: 1px solid var(--color-border);
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; position: relative;
        }
        .buff-icon.debuff { border-color: var(--color-enemy-health); }
        .buff-duration {
            position: absolute;
            bottom: -1px; right: -1px;
            font-size: 10px;
            background: rgba(0,0,0,0.8);
            padding: 0 2px;
            border-radius: 2px;
            color: white;
        }
        .buff-icon .fa-skull { color: #ff4500; }
        .buff-icon .fa-hand-fist { color: #f0e68c; }
        .buff-icon .fa-heart-crack { color: #dc143c; }


        /* --- Bottom Bar Area --- */
        #bottom-ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column-reverse; /* Puts action bar at the very bottom */
            align-items: center;
            gap: 2px;
        }
        #action-bar {
            position: relative;
            bottom: 0; left: 0;
            transform: none; /* Reset transform as it's now in a container */
            display: flex; background-color: var(--color-bg-medium);
            padding: 5px; border-radius: 5px; border: 1px solid var(--color-border);
            pointer-events: all;
        }
        .action-slot {
            width: 50px; height: 50px; background-color: var(--color-bg-dark);
            border: 1px solid var(--color-border); margin: 2px; position: relative;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; cursor: pointer;
        }
        .action-slot:hover { border-color: #fff; }
        .action-slot.drag-over { border-color: gold; box-shadow: 0 0 5px gold; }
        /* CHANGE: Removed default color to allow for thematic coloring */
        .action-slot i { pointer-events: none; /* Clicks go to parent */ }
        .action-keybind {
            position: absolute; top: 2px; left: 2px; font-size: 10px; color: var(--color-text-muted);
        }
        .hotbar-item-count {
            position: absolute; bottom: 2px; right: 2px; font-size: 14px;
            color: white; text-shadow: 1px 1px 2px black;
        }
        .cooldown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 0;
            background-color: var(--color-cooldown); pointer-events: none;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; color: white; overflow: hidden;
        }

        #xp-bar {
            position: relative; /* Now positioned within the container */
            bottom: 0; left: 0; transform: none;
            width: 80vw; /* --- CHANGE: Widen XP Bar --- */
            max-width: 544px; /* Maintain max width to match action bar */
            height: 8px; background-color: rgba(0,0,0,0.5);
            border: 1px solid var(--color-border); pointer-events: none;
            display: flex; /* For rested XP */
        }
        #xp-bar-fill { width: 0%; height: 100%; background-color: var(--color-xp); transition: width 0.5s ease-in-out; }
        /* NEW: Rested XP Bar */
        #xp-bar-rested-fill { width: 0%; height: 100%; background-color: var(--color-xp-rested); transition: width 0.5s ease-in-out; }

        /* Other UI elements... */
        #minimap { position: absolute; top: 20px; right: 20px; width: 150px; height: 150px; border-radius: 50%; border: 3px solid var(--color-border); background-color: var(--color-bg-dark); overflow: hidden; pointer-events: all; }
        #minimap-canvas { width: 100%; height: 100%; }
        .window { position: absolute; width: 350px; background: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; box-shadow: 0 0 15px rgba(0,0,0,0.7); display: none; flex-direction: column; pointer-events: all; z-index: 100; }
        .window-header { padding: 8px; background: var(--color-bg-light); cursor: move; display: flex; justify-content: space-between; align-items: center; }
        .window-header .close-btn { cursor: pointer; }
        .window-content { padding: 10px; max-height: 400px; overflow-y: auto; }
        #character-window { top: 150px; left: 100px; }
        #inventory-window { top: 150px; left: 500px; }
        #quest-log-window { top: 100px; right: 200px; }
        /* NEW: Talent, Spellbook, and Reputation Windows */
        #talent-window { top: 200px; left: 150px; width: 450px; }
        #spellbook-window { top: 200px; left: 600px; width: 300px; }
        #reputation-window { top: 200px; left: 950px; width: 300px; }
        #vendor-window { top: 100px; left: 300px; width: 400px; }
        #crafting-window { top: 100px; left: 300px; width: 400px; }


        #inventory-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .inventory-slot { width: 60px; height: 60px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 28px; position: relative; }
        .inventory-slot[draggable="true"] { cursor: grab; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 12px; text-shadow: 1px 1px 1px black; }
        .quality-common { color: var(--color-text); }
        .quality-magic { color: var(--color-text-magic); }
        .quality-rare { color: var(--color-text-rare); }
        .quality-epic { color: var(--color-text-epic); }
        .stat-line { display: flex; justify-content: space-between; padding: 4px 0; }
        
        /* NEW: Currency Display */
        .currency-container { display: flex; justify-content: flex-end; align-items: center; gap: 5px; font-size: 14px; }
        .currency-item { display: flex; align-items: center; gap: 2px; }
        .currency-icon { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #333; }
        .gold { background-color: var(--color-gold); }
        .silver { background-color: var(--color-silver); }
        .copper { background-color: var(--color-copper); }

        /* --- NEW/MODIFIED FOR AUTO-QUEST --- */
        .quest-item {
            padding: 8px;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quest-item > div { flex-grow: 1; }
        .auto-quest-btn {
            padding: 4px 8px; font-size: 12px;
            background-color: var(--color-bg-light); border: 1px solid var(--color-border);
            color: var(--color-text-quest); cursor: pointer; pointer-events: all;
            margin-left: 10px; flex-shrink: 0;
            transition: background-color 0.2s;
        }
        .auto-quest-btn:hover { background-color: var(--color-bg-medium); border-color: #fff; }
        .auto-quest-btn.active { background-color: var(--color-enemy-health); color: white; }
        /* --- END AUTO-QUEST STYLES --- */

        .quest-title { font-weight: bold; color: var(--color-text-quest); }
        .quest-objective { font-size: 14px; padding-left: 15px; }
        .floating-text { position: absolute; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black; animation: floatUp 1.5s ease-out forwards; pointer-events: none; }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-60px); opacity: 0; } }
        /* NEW: Styles for critical hits and misses */
        .floating-text.crit { font-size: 24px; animation: floatUpCrit 1.5s ease-out forwards; color: #ff4500 !important; }
        @keyframes floatUpCrit { 0% { transform: translateY(0) scale(1); opacity: 1; } 50% { transform: translateY(-40px) scale(1.5); } 100% { transform: translateY(-80px) scale(1); opacity: 0; } }
        .floating-text.miss { color: #ccc !important; font-style: italic; font-size: 16px; }

        #tooltip { position: absolute; background: var(--color-bg-dark); border: 1px solid var(--color-border); padding: 10px; border-radius: 5px; display: none; max-width: 250px; pointer-events: none; z-index: 10000; }
        #tooltip .name { font-weight: bold; margin-bottom: 5px; }
        #tooltip .description { font-size: 14px; color: var(--color-text-muted); }
        #tooltip .stats { margin-top: 8px; font-size: 14px; }
        /* NEW: Tooltip durability */
        #tooltip .durability { color: #ff4500; }
        
        #mobile-controls { position: absolute; bottom: 10px; left: 10px; width: 150px; height: 150px; display: none; pointer-events: all; }
        #joystick-area { position: relative; width: 100%; height: 100%; background: rgba(50, 50, 50, 0.4); border-radius: 50%; }
        #joystick-thumb { position: absolute; width: 60px; height: 60px; background: rgba(120, 120, 120, 0.7); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #system-menu { position: absolute; bottom: 20px; right: 20px; display: flex; pointer-events: all; gap: 2px; }
        .sys-button { width: 30px; height: 30px; background: var(--color-bg-light); border: 1px solid var(--color-border); cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .sys-button:hover { background: var(--color-bg-medium); }
        
        /* NEW: Talent Window Styles */
        #talent-points-display { text-align: center; margin-bottom: 10px; font-weight: bold; }
        .talent-tree { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .talent { background: var(--color-bg-dark); border: 1px solid var(--color-border); padding: 5px; text-align: center; cursor: pointer; position: relative; }
        .talent.locked { filter: grayscale(1) brightness(0.5); cursor: not-allowed; }
        .talent.maxed { border-color: gold; }
        .talent:not(.locked):not(.maxed):hover { border-color: white; }
        .talent-icon { font-size: 30px; }
        .talent-name { font-size: 12px; margin-top: 4px; }
        .talent-rank { position: absolute; bottom: 2px; right: 2px; font-size: 12px; background: rgba(0,0,0,0.7); padding: 1px 3px; border-radius: 3px; }

        /* NEW: Spellbook Styles */
        #spellbook-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .spellbook-slot { width: 50px; height: 50px; background: var(--color-bg-dark); border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center; font-size: 24px; position: relative; }
        .spellbook-slot[draggable="true"] { cursor: grab; }

        /* NEW: Reputation Window Styles */
        .reputation-line { display: flex; justify-content: space-between; padding: 5px; border-bottom: 1px solid var(--color-border); }
        .rep-bar-container { width: 120px; height: 16px; background: var(--color-bg-dark); border: 1px solid var(--color-border); }
        .rep-bar-fill { height: 100%; background-color: var(--color-health); }

        /* NEW: Vendor Window */
        #vendor-content, #crafting-content { display: flex; flex-direction: column; gap: 10px; }
        .vendor-section, .crafting-section { border: 1px solid var(--color-border); padding: 8px; background: var(--color-bg-dark); }
        .vendor-section h3, .crafting-section h3 { margin: 0 0 5px 0; font-size: 1.1em; color: var(--color-text-quest); }
        .vendor-grid, .crafting-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .vendor-item-slot, .crafting-recipe-slot {
            width: 60px; height: 60px; background: var(--color-bg-medium);
            border: 1px solid var(--color-border); display: flex; justify-content: center; align-items: center;
            font-size: 28px; position: relative; cursor: pointer;
        }
        .vendor-item-slot:hover, .crafting-recipe-slot:hover { border-color: white; }
        .vendor-item-price, .crafting-recipe-cost {
            position: absolute; bottom: 2px; left: 2px; font-size: 10px;
            color: var(--color-gold); text-shadow: 1px 1px 2px black;
            display: flex; align-items: center;
        }
        .crafting-recipe-cost.unmet { color: red; }
        .craft-button {
            display: block; width: calc(100% - 16px); padding: 8px; margin: 8px;
            background-color: var(--color-bg-light); border: 1px solid var(--color-border);
            color: var(--color-text); cursor: pointer; text-align: center;
        }
        .craft-button:disabled { opacity: 0.5; cursor: not-allowed; }
        .craft-button:not(:disabled):hover { background-color: var(--color-bg-medium); }


        #death-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: none; justify-content: center; align-items: center; flex-direction: column; color: #dc3545; text-align: center; font-size: 3em; text-shadow: 2px 2px 4px black; pointer-events: all; z-index: 20000; }
        /* NEW: Resurrection Sickness Overlay */
        #res-sickness-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(100, 0, 0, 0.2); pointer-events: none; z-index: 19999; display: none; }
        #respawn-button { padding: 15px 30px; font-size: 1.2em; color: var(--color-text); background-color: var(--color-bg-light); border: 2px solid var(--color-border); border-radius: 5px; cursor: pointer; margin-top: 20px; }
        #respawn-button:hover { border-color: #fff; background-color: var(--color-bg-medium); }
        #release-spirit-button { padding: 15px 30px; font-size: 1.2em; color: var(--color-text); background-color: var(--color-bg-light); border: 2px solid var(--color-border); border-radius: 5px; cursor: pointer; margin-top: 20px; }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="player-frame" class="unit-frame">
                <div class="portrait"><i class="fas fa-user"></i></div>
                <div class="unit-info">
                    <div class="name-level"><span id="player-name">Player</span><span id="player-level">Lvl 1</span></div>
                    <div class="resource-bar"><div id="player-health-fill" class="bar-fill"></div><div id="player-health-text" class="bar-text">100 / 100</div></div>
                    <div class="resource-bar"><div id="player-mana-fill" class="bar-fill"></div><div id="player-mana-text" class="bar-text">100 / 100</div></div>
                    <div class="buff-container" id="player-buffs"></div>
                </div>
            </div>
            <div id="target-frame" class="unit-frame">
                <div class="portrait" id="target-portrait"></div>
                <div class="unit-info">
                    <div class="name-level"><span id="target-name"></span><span id="target-level"></span></div>
                    <div class="resource-bar"><div id="target-health-fill" class="bar-fill"></div><div id="target-health-text" class="bar-text"></div></div>
                    <div class="buff-container" id="target-buffs"></div>
                </div>
            </div>
            
            <div id="bottom-ui-container">
                <div id="action-bar"></div>
                <div id="xp-bar"><div id="xp-bar-rested-fill"></div><div id="xp-bar-fill"></div></div>
            </div>
            
            <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
            <div id="floating-text-container"></div>
            <div id="tooltip"></div>

            <div id="character-window" class="window">
                <div class="window-header"><span>Character</span><i class="fas fa-times close-btn"></i></div><div class="window-content" id="character-content"></div>
            </div>
            <div id="inventory-window" class="window">
                <div class="window-header"><span>Inventory</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="inventory-grid"></div><div id="currency" class="currency-container" style="margin-top: 10px; text-align: right;"></div></div>
            </div>
            <div id="quest-log-window" class="window">
                <div class="window-header"><span>Quest Log</span><i class="fas fa-times close-btn"></i></div><div class="window-content" id="quest-log-content"></div>
            </div>
            
            <!-- NEW: Talent, Spellbook, and Reputation Windows -->
            <div id="talent-window" class="window">
                <div class="window-header"><span>Talents</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content">
                    <div id="talent-points-display">Talent Points: 0</div>
                    <div id="talent-tree" class="talent-tree"></div>
                </div>
            </div>
            <div id="spellbook-window" class="window">
                <div class="window-header"><span>Spellbook</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content"><div id="spellbook-grid"></div></div>
            </div>
            <div id="reputation-window" class="window">
                <div class="window-header"><span>Reputation</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="reputation-content"></div>
            </div>

            <!-- NEW: Vendor and Crafting Windows -->
            <div id="vendor-window" class="window">
                <div class="window-header"><span>Vendor</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="vendor-content">
                    <div class="vendor-section">
                        <h3>Your Items (Drag to Sell)</h3>
                        <div id="vendor-player-inventory" class="vendor-grid"></div>
                    </div>
                    <div class="vendor-section">
                        <h3>Vendor Sells</h3>
                        <div id="vendor-sells-grid" class="vendor-grid"></div>
                    </div>
                    <div class="currency-container" style="text-align: right; margin-top: 10px;">Your Gold: <span id="vendor-player-gold"></span></div>
                </div>
            </div>
            
            <div id="crafting-window" class="window">
                <div class="window-header"><span>Crafting</span><i class="fas fa-times close-btn"></i></div>
                <div class="window-content" id="crafting-content">
                    <div class="crafting-section">
                        <h3>Recipes</h3>
                        <div id="crafting-recipes-grid" class="crafting-grid"></div>
                    </div>
                    <div class="crafting-section">
                        <h3>Materials</h3>
                        <div id="crafting-materials-display"></div>
                    </div>
                    <button id="craft-button" class="craft-button" disabled>Craft</button>
                </div>
            </div>

            <div id="mobile-controls"><div id="joystick-area"><div id="joystick-thumb"></div></div></div>
            <div id="system-menu">
                <button class="sys-button" data-window="character-window" title="Character (C)"><i class="fas fa-user-circle"></i></button>
                <button class="sys-button" data-window="inventory-window" title="Inventory (I)"><i class="fas fa-briefcase"></i></button>
                <!-- NEW: Spellbook and Talent Buttons -->
                <button class="sys-button" data-window="spellbook-window" title="Spellbook (P)"><i class="fas fa-book"></i></button>
                <button class="sys-button" data-window="talent-window" title="Talents (N)"><i class="fas fa-sitemap"></i></button>
                <button class="sys-button" data-window="quest-log-window" title="Quest Log (L)"><i class="fas fa-book-open"></i></button>
                <button class="sys-button" data-window="reputation-window" title="Reputation (U)"><i class="fas fa-users"></i></button>
            </div>
            <div id="death-screen"><p>You have died.</p><button id="release-spirit-button">Release Spirit</button></div>
            <div id="res-sickness-overlay"></div>
        </div>
    </div>

<script type="module">
const $ = (selector) => document.querySelector(selector);
const $$ = (selector) => document.querySelectorAll(selector);
const distance = (a, b) => Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);

// World Coordinates for key locations
const STARTING_ZONE_CENTER = { x: 5000, y: 5000 };
const RESPAWN_POINT = { x: 5000, y: 5000 };
const GRAVEYARD_POINT = { x: 4850, y: 4850 };

const GameData = {
    ITEMS: {
        1: { id: 1, name: "Rusty Sword", icon: "fa-sword", slot: "main-hand", quality: "common", stats: { attack: 2 }, durability: 100, maxDurability: 100, sellPrice: 100 },
        2: { id: 2, name: "Worn Leather Vest", icon: "fa-vest-patches", slot: "chest", quality: "common", stats: { armor: 5 }, durability: 100, maxDurability: 100, sellPrice: 150 },
        3: { id: 3, name: "Spider Silk", icon: "fa-network-wired", slot: "material", quality: "common", stackable: true, sellPrice: 50 },
        4: { id: 4, name: "Wolf Fang", icon: "fa-tooth", slot: "material", quality: "common", stackable: true, sellPrice: 40 },
        5: { id: 5, name: "Minor Healing Potion", icon: "fa-flask-vial", slot: "consumable", quality: "common", stackable: true, onUse: (player) => player.heal(50), sellPrice: 25 },
        6: { id: 6, name: "Peacebloom", icon: "fa-leaf", slot: "material", quality: "common", stackable: true, sellPrice: 20 },
        7: { id: 7, name: "Copper Ore", icon: "fa-gem", slot: "material", quality: "common", stackable: true, color: "#b87333", sellPrice: 30 },
        8: { id: 8, name: "Rough Wooden Staff", icon: "fa-staff-snake", slot: "main-hand", quality: "common", stats: { attack: 3, intellect: 1 }, durability: 100, maxDurability: 100, sellPrice: 200 },
        9: { id: 9, name: "Thick Leather", icon: "fa-paw", slot: "material", quality: "common", stackable: true, sellPrice: 70 },
        10: { id: 10, name: "Sturdy Wooden Shield", icon: "fa-shield", slot: "off-hand", quality: "common", stats: { armor: 3, stamina: 1 }, durability: 100, maxDurability: 100, sellPrice: 250 },
        101: { id: 101, name: "Goblin-Forged Blade", icon: "fa-scythe", slot: "main-hand", quality: "rare", stats: { attack: 5, strength: 2 }, durability: 100, maxDurability: 100, sellPrice: 500 },
        102: { id: 102, name: "Enchanted Robes", icon: "fa-jedi", slot: "chest", quality: "magic", stats: { armor: 8, intellect: 3 }, durability: 100, maxDurability: 100, sellPrice: 400 },
    },
    ABILITIES: {
        1: { id: 1, name: "Slash", icon: "fa-burst", cost: 20, cooldown: 3000, range: 90, onUse: (caster, target) => { ParticleSystem.create(target.x, target.y, 'red', 15, 0.1, 10); const damage = caster.getAttackDamage() * 1.5; target.takeDamage(damage, 'physical', caster); }},
        2: { id: 2, name: "Fireball", icon: "fa-fire-flame-curved", cost: 30, cooldown: 5000, range: 200, onUse: (caster, target) => { ParticleSystem.create(target.x, target.y, 'orange', 25, 0.2, 15); const damage = (caster.stats.intellect * 2) + 10; target.takeDamage(damage, 'magic', caster); }},
        3: { id: 3, name: "Rend", icon: "fa-heart-crack", cost: 15, cooldown: 6000, range: 90, onUse: (caster, target) => { target.addBuff({ id: 'rend_dot', name: 'Rend', icon: 'fa-heart-crack', duration: 9000, tickRate: 3000, onTick: (t) => { const damage = caster.getAttackDamage() * 0.2; t.takeDamage(damage, 'physical', caster, true); game.createFloatingText(Math.round(damage), t.x, t.y, '#ff4500'); }, isDebuff: true }); }},
    },
    ENEMY_TYPES: {
        'WOLF': { name: "Dire Wolf", icon: "\uf6f0", color: "#a9a9a9", size: 28, speed: 1.5, health: 80, attack: 5, aggroRadius: 150, attackRange: 40, attackSpeed: 2000, xp: 15, lootTable: [{itemId: 4, chance: 0.8, min: 1, max: 2}, {itemId: 9, chance: 0.5, min: 1, max: 1}, {gold: 50, chance: 1.0}] },
        'SPIDER': { name: "Forest Spider", icon: "\uf717", color: "#654321", size: 25, speed: 1.2, health: 60, attack: 4, aggroRadius: 120, attackRange: 35, attackSpeed: 1800, xp: 10, lootTable: [{itemId: 3, chance: 0.9, min: 1, max: 3}, {gold: 30, chance: 1.0}] },
        'GOBLIN': { name: "Goblin Thug", icon: "\uf7a0", color: "#2E8B57", size: 22, speed: 1.8, health: 120, attack: 8, aggroRadius: 180, attackRange: 45, attackSpeed: 2200, xp: 25, lootTable: [{itemId: 101, chance: 0.1}, {gold: 150, chance: 0.5}] },
        'DARK_CASTER': { name: "Dark Caster", icon: "\uf718", color: "#8A2BE2", size: 24, speed: 1.4, health: 100, attack: 5, aggroRadius: 220, attackRange: 200, attackSpeed: 3000, xp: 30, lootTable: [{gold: 200, chance: 0.8}] }
    },
    NPC_TYPES: {
        'BLACKSMITH': { name: "Barton the Blacksmith", icon: '\uf0e7', color: '#a9a9a9', interactType: 'repair', interaction: (player) => { const cost = player.getRepairCost(); if (cost > 0) { if (confirm(`Repair all items for ${UI.formatCurrency(cost)}?`)) { if (player.gold >= cost) { player.gold -= cost; player.repairAllItems(); alert('All items repaired!'); game.ui.updateAll(player); } else { alert("You don't have enough gold!"); } } } else { alert('Your items are in perfect condition.'); } } },
        'SPIRIT_HEALER': { name: "Spirit Healer", icon: '\uf70e', color: '#a0c4ff', interactType: 'resurrect', interaction: (player) => { if (player.isGhost) { if(confirm("Resurrect here? You will suffer Resurrection Sickness and your equipped items will lose durability.")) { player.resurrectAtHealer(); } } else { alert("The spirits can only help the dead."); } } },
        'GENERAL_VENDOR': { name: "General Goods Vendor", icon: '\uf54e', color: '#c0c0c0', interactType: 'vendor', sells: [{itemId: 5, quantity: 5, price: 50}], buys: ['consumable', 'material'] },
        'WOODWORKING_TRAINER': { name: "Master Woodworker", icon: '\uf5bb', color: '#8b4513', interactType: 'crafting_trainer', profession: 'Woodworking', interaction: (player) => { if (player.professions.Woodworking) { player.addRecipe('wooden_staff'); player.addRecipe('wooden_shield'); alert("You learned new woodworking recipes!"); game.ui.updateSpellbook(player); game.ui.updateCraftingWindow(player); } else { alert("You need to learn Woodworking first!"); } } }
    },
    QUESTS: { 
        1: { id: 1, title: "A Tangled Web", description: "The forest path is overrun with spiders. Clear out 5 of them so travelers can pass safely.", objectives: [{ type: 'kill', target: 'SPIDER', count: 5 }], rewards: { xp: 100, gold: 1000, items: [{id: 2, quantity: 1}] }, reputation: { faction: 'Stormwind Guard', value: 50 }, repeatable: false },
        2: { id: 2, title: "Wolf Hunting", description: "The local farmers are losing livestock to dire wolves. Hunt 3 dire wolves.", objectives: [{ type: 'kill', target: 'WOLF', count: 3 }], rewards: { xp: 80, gold: 800, items: [{id: 4, quantity: 1}] }, reputation: { faction: 'Stormwind Guard', value: 40 }, repeatable: true, cooldown: 3600000 }, // 1 hour cooldown
        3: { id: 3, title: "Gather Peacebloom", description: "Collect 5 Peacebloom for the local alchemist.", objectives: [{ type: 'gather', target: 'PEACEBLOOM', count: 5 }], rewards: { xp: 50, gold: 300 }, repeatable: true, cooldown: 1800000 } // 30 min cooldown
    },
    XP_TABLE: [0, 100, 250, 500, 1000, 2000, 4000, 8000, 12000, 18000],
    TALENTS: {
        'WARRIOR': [
            { id: 'str1', name: 'Toughness', maxRank: 5, icon: 'fa-hand-fist', description: 'Increases total Stamina by 2% per rank.', requires: null, apply: (p, r) => p.statBonuses.staminaBonus = (p.statBonuses.staminaBonus || 0) + 0.02 * r },
            { id: 'crit1', name: 'Cruelty', maxRank: 5, icon: 'fa-gavel', description: 'Increases critical strike chance by 1% per rank.', requires: null, apply: (p, r) => p.stats.critChance = (p.baseStats.critChance || 0) + (1 * r) },
            { id: 'rend1', name: 'Improved Rend', maxRank: 3, icon: 'fa-heart-crack', description: 'Increases the damage of your Rend ability by 15% per rank.', requires: null, apply: (p, r) => p.talentBonuses.rendDamageMultiplier = (p.talentBonuses.rendDamageMultiplier || 1) + 0.15 * r},
        ]
    },
    FACTIONS: {
        'Stormwind Guard': { name: 'Stormwind Guard', tiers: ['Hated', 'Hostile', 'Unfriendly', 'Neutral', 'Friendly', 'Honored', 'Revered', 'Exalted'], base: 3000, values: [-42000, -6000, -3000, 0, 3000, 9000, 21000, 999999] },
        'Wilderness': { name: 'The Wilds', tiers: ['Ally', 'Neutral', 'Enemy'], base: 0, values: [0, 1000, -1000] },
    },
    RESOURCE_NODES: {
        'PEACEBLOOM': { name: 'Peacebloom', icon: '\uf4d9', color: '#adff2f', size: 20, itemId: 6, respawnTime: 30000, requiredSkill: 'Herbalism' },
        'COPPER_VEIN': { name: 'Copper Vein', icon: '\uf1b2', color: '#b87333', size: 24, itemId: 7, respawnTime: 60000, requiredSkill: 'Mining' },
    },
    CRAFTING_RECIPES: {
        'wooden_staff': { id: 'wooden_staff', name: 'Rough Wooden Staff', icon: 'fa-staff-snake', itemId: 8, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 6, quantity: 5}], time: 3000 },
        'wooden_shield': { id: 'wooden_shield', name: 'Sturdy Wooden Shield', icon: 'fa-shield', itemId: 10, profession: 'Woodworking', skillRequired: 1, materials: [{itemId: 6, quantity: 3}, {itemId: 9, quantity: 2}], time: 4000 }
    },
    PROFESSIONS: {
        'Herbalism': { level: 1, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        'Mining': { level: 1, maxLevel: 100, xp: 0, nextLevelXp: 100 },
        'Woodworking': { level: 0, maxLevel: 100, xp: 0, nextLevelXp: 50 } // Woodworking starts at 0, must be trained
    },
    REGIONS: [
        {
            id: 'starting_zone',
            name: 'Whispering Woods',
            x: 0, y: 0, width: 7000, height: 7000,
            bgColor: "#182c18",
            decorations: [
                { type: 'mist', density: 50, color: `rgba(200, 220, 255, 0.04)`, sizeMin: 150, sizeMax: 200 },
                { type: 'grass', density: 1000, char: ['"', ',', "`"], color: `rgba(144, 238, 144, 0.2)`, sizeMin: 8, sizeMax: 12 },
                { type: 'tree', density: 300, char: '\uf1bb', color: `rgba(0, 100, 0, 0.5)`, sizeMin: 20, sizeMax: 30 }
            ],
            enemies: [
                { type: 'SPIDER', count: 30 },
                { type: 'WOLF', count: 20 }
            ],
            resources: [
                { type: 'PEACEBLOOM', count: 15 },
                { type: 'COPPER_VEIN', count: 10 }
            ],
            npcs: [
                { type: 'QuestGiver', name: "Old Man Willow", x: 5000, y: 4950, questIds: [1, 2] },
                { type: 'GenericNPC', npcType: 'BLACKSMITH', x: 4900, y: 5050 },
                { type: 'GenericNPC', npcType: 'GENERAL_VENDOR', x: 5100, y: 5050 },
                { type: 'GenericNPC', npcType: 'SPIRIT_HEALER', x: 4850, y: 4800 } // Graveyard
            ]
        },
        {
            id: 'goblin_camp',
            name: 'Goblin Hideout',
            x: 7000, y: 0, width: 3000, height: 5000,
            bgColor: "#3b302c",
            decorations: [
                { type: 'mist', density: 20, color: `rgba(100, 80, 70, 0.08)`, sizeMin: 100, sizeMax: 180 },
                { type: 'rocks', density: 500, char: '\uf6ed', color: `rgba(100, 100, 100, 0.7)`, sizeMin: 10, sizeMax: 25 },
                { type: 'tree', density: 50, char: '\uf1bb', color: `rgba(60, 40, 0, 0.6)`, sizeMin: 20, sizeMax: 30 }
            ],
            enemies: [
                { type: 'GOBLIN', count: 20 },
                { type: 'DARK_CASTER', count: 5 }
            ],
            resources: [
                { type: 'COPPER_VEIN', count: 20 }
            ],
            npcs: [
                { type: 'GenericNPC', npcType: 'WOODWORKING_TRAINER', x: 8000, y: 2500 },
                { type: 'CraftingStation', stationType: 'WOODWORKING_BENCH', x: 8050, y: 2550 }
            ]
        },
        // Add more regions here as needed for future expansion
    ],
    CRAFTING_STATIONS: {
        'WOODWORKING_BENCH': {
            name: 'Woodworking Bench',
            icon: '\uf6a3', // Fa-chair
            color: '#8B4513',
            recipes: ['wooden_staff', 'wooden_shield']
        }
    }
};

class Game {
    constructor() {
        this.canvas = $("#game-canvas"); this.ctx = this.canvas.getContext("2d");
        this.lastTime = 0; this.entities = []; this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        this.input = new InputHandler(this.isMobile);
        this.world = new World(this.ctx, 10000, 10000);
        ParticleSystem.init(this.ctx);
        this.player = new Player(RESPAWN_POINT.x, RESPAWN_POINT.y, this.input);
        this.entities.push(this.player);
        this.ui = new UI(this);
        this.camera = new Camera(this.player, this.canvas.width, this.canvas.height);
        this.spawnEntities(); this.ui.updateAll(this.player);
        this.setupUIInteractions(); this.gameLoop(0);
    }
    resizeCanvas() {
        this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight;
        if(this.camera) { this.camera.width = this.canvas.width; this.camera.height = this.canvas.height; }
    }
    spawnEntities() {
        // --- NEW: Spawning entities by region ---
        GameData.REGIONS.forEach(regionData => {
            // Spawn NPCs
            regionData.npcs.forEach(npc => {
                let npcEntity;
                if (npc.type === 'QuestGiver') {
                    npcEntity = new QuestGiver(npc.x, npc.y, npc.name, npc.questIds);
                } else if (npc.type === 'GenericNPC') {
                    npcEntity = new GenericNPC(npc.x, npc.y, GameData.NPC_TYPES[npc.npcType]);
                } else if (npc.type === 'CraftingStation') {
                    npcEntity = new CraftingStation(npc.x, npc.y, GameData.CRAFTING_STATIONS[npc.stationType]);
                }
                if (npcEntity) {
                    this.entities.push(npcEntity);
                }
            });

            // Spawn Enemies
            if (regionData.enemies) {
                regionData.enemies.forEach(enemyDef => {
                    for (let i = 0; i < enemyDef.count; i++) {
                        let x, y;
                        // Ensure spawn within region bounds
                        do {
                            x = regionData.x + Math.random() * regionData.width;
                            y = regionData.y + Math.random() * regionData.height;
                        } while (distance({x,y}, STARTING_ZONE_CENTER) < 300); // Keep a small safe zone around main spawn for a new player
                        this.entities.push(new Enemy(x, y, GameData.ENEMY_TYPES[enemyDef.type]));
                    }
                });
            }

            // Spawn Resources
            if (regionData.resources) {
                regionData.resources.forEach(resourceDef => {
                    for (let i = 0; i < resourceDef.count; i++) {
                        let x, y;
                        do {
                            x = regionData.x + Math.random() * regionData.width;
                            y = regionData.y + Math.random() * regionData.height;
                        } while (distance({x,y}, STARTING_ZONE_CENTER) < 300); // Keep a small safe zone
                        this.entities.push(new ResourceNode(x, y, GameData.RESOURCE_NODES[resourceDef.type]));
                    }
                });
            }
        });
        // --- END NEW ---
    }
    gameLoop(timestamp) { const deltaTime = timestamp - this.lastTime; this.lastTime = timestamp; this.update(deltaTime); this.draw(); requestAnimationFrame((ts) => this.gameLoop(ts)); }
    update(deltaTime) {
        if (!deltaTime) return;
        if (this.input.mouse.clicked && !this.player.isAutoQuesting && !this.player.isGhost) { // Disable click-to-target when auto-questing or ghost
            let clickedOnSomething = false; const clickWorldPos = { x: this.input.mouse.x + this.camera.x, y: this.input.mouse.y + this.camera.y };
            const sortedEntities = [...this.entities].sort((a, b) => b.y - a.y);
            for (const entity of sortedEntities) {
                if (entity !== this.player && distance(clickWorldPos, entity) < entity.size) {
                    if (entity.isInteractable && distance(this.player, entity) < 100) entity.interact(this.player);
                    else if (entity instanceof Character) this.player.setTarget(entity); // BUG FIX: Only allow Characters to be targeted.
                    clickedOnSomething = true; break;
                }
            }
            if (!clickedOnSomething) this.player.setTarget(null);
            this.input.mouse.clicked = false;
        }
        this.entities.forEach(entity => entity.update(deltaTime, this.world, this.entities, this.player));
        const deadNPCs = this.entities.filter(e => e.isDead && e !== this.player && !(e instanceof PlayerCorpse));
        if(deadNPCs.length > 0) {
            deadNPCs.forEach(dead => { if (dead === this.player.target) this.player.setTarget(null); });
            this.entities = this.entities.filter(e => !deadNPCs.includes(e));
        }
        this.camera.update(); ParticleSystem.update(deltaTime); this.ui.update(this.player, deltaTime);
        this.world.updateAmbiance(deltaTime);
    }
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.save();
        this.ctx.translate(-this.camera.x, -this.camera.y);
        this.world.draw(this.camera, this.player.isGhost);
        const sortedEntities = [...this.entities].sort((a, b) => a.y - b.y);
        sortedEntities.forEach(entity => entity.draw(this.ctx, this.camera, this.player));
        ParticleSystem.draw(this.camera); this.ctx.restore();
    }
    createFloatingText(text, x, y, color, type = '') { this.ui.createFloatingText(text, x, y, color, this.camera, type); }
    setupUIInteractions() {
        if (this.isMobile) $("#mobile-controls").style.display = "block";
        $$('.sys-button').forEach(btn => btn.addEventListener('click', () => { const windowId = btn.dataset.window; const win = $(`#${windowId}`); win.style.display = win.style.display === 'flex' ? 'none' : 'flex'; this.ui.updateAll(this.player); }));
        $$('.close-btn').forEach(btn => btn.addEventListener('click', (e) => e.target.closest('.window').style.display = 'none'));
        $$('.window').forEach(win => this.ui.makeDraggable(win));
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            const keyMap = {c: '#character-window', i: '#inventory-window', l: '#quest-log-window', n: '#talent-window', p: '#spellbook-window', u: '#reputation-window'};
            if(keyMap[e.key.toLowerCase()]){
                const win = $(keyMap[e.key.toLowerCase()]);
                win.style.display = win.style.display === 'flex' ? 'none' : 'flex';
                this.ui.updateAll(this.player); // Refresh content when opening
            }
        });
        $('#release-spirit-button').addEventListener('click', () => this.player.releaseSpirit());
    }
}

class World {
    constructor(ctx, width, height) {
        this.ctx = ctx;
        this.width = width;
        this.height = height;
        this.bgColor = "#182c18"; // Base background color, individual regions will draw their own ambiance
        this.regions = [];
        this.sparkles = [];
        this.generateRegions(); // NEW: Call to generate regions
        this.generateAmbiance();
    }

    generateRegions() {
        GameData.REGIONS.forEach(regionData => {
            const region = {
                id: regionData.id,
                name: regionData.name,
                x: regionData.x,
                y: regionData.y,
                width: regionData.width,
                height: regionData.height,
                bgColor: regionData.bgColor,
                decorations: []
            };

            // Generate decorations for this specific region
            regionData.decorations.forEach(dType => {
                for (let i = 0; i < dType.density; i++) {
                    const x = region.x + Math.random() * region.width;
                    const y = region.y + Math.random() * region.height;
                    const size = Math.random() * (dType.sizeMax - dType.sizeMin) + dType.sizeMin;
                    const color = dType.color;
                    const char = Array.isArray(dType.char) ? dType.char[Math.floor(Math.random() * dType.char.length)] : dType.char;
                    region.decorations.push({ x, y, type: dType.type, char, color, size });
                }
            });
            this.regions.push(region);
        });
    }

    generateAmbiance() { for (let i = 0; i < 500; i++) { this.sparkles.push({ x: Math.random() * this.width, y: Math.random() * this.height, size: Math.random() * 1.5 + 0.5, opacity: Math.random() * 0.5, opacityDir: 1 }); } }
    updateAmbiance(deltaTime) { this.sparkles.forEach(s => { s.opacity += 0.05 * s.opacityDir * (deltaTime / 16.67); if (s.opacity > 1 || s.opacity < 0) { s.opacityDir *= -1; s.opacity = Math.max(0, Math.min(1, s.opacity)); } }); }
    
    draw(camera, isGhost = false) {
        this.ctx.save();
        if (isGhost) { this.ctx.filter = 'grayscale(1) brightness(0.7) sepia(1) hue-rotate(180deg)'; }

        // --- NEW: Draw region backgrounds and decorations ---
        this.ctx.fillStyle = this.bgColor; // Fallback or global background
        this.ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

        this.regions.forEach(region => {
            // Only draw regions visible in camera
            if (region.x < camera.x + camera.width && region.x + region.width > camera.x &&
                region.y < camera.y + camera.height && region.y + region.height > camera.y) {
                
                // Draw region background (if different from global)
                this.ctx.fillStyle = region.bgColor;
                this.ctx.fillRect(Math.max(camera.x, region.x), Math.max(camera.y, region.y),
                                  Math.min(camera.x + camera.width, region.x + region.width) - Math.max(camera.x, region.x),
                                  Math.min(camera.y + camera.height, region.y + region.height) - Math.max(camera.y, region.y));

                // Draw region specific decorations
                region.decorations.forEach(d => {
                    if (d.x > camera.x - d.size && d.x < camera.x + camera.width + d.size && d.y > camera.y - d.size && d.y < camera.y + camera.height + d.size) {
                        if (d.type === 'mist') { this.ctx.fillStyle = d.color; this.ctx.beginPath(); this.ctx.arc(d.x, d.y, d.size, 0, 2 * Math.PI); this.ctx.fill(); } else { this.ctx.font = `${d.size}px "Font Awesome 6 Free"`; this.ctx.fillStyle = d.color; if(d.type === 'grass') this.ctx.font = `${d.size}px "Verdana"`; this.ctx.fillText(d.char, d.x, d.y); }
                    }
                });
            }
        });
        // --- END NEW ---

        this.drawAmbiance(camera);
        this.ctx.restore();
    }
    drawAmbiance(camera) { this.ctx.save(); this.ctx.globalCompositeOperation = 'lighter'; this.sparkles.forEach(s => { if (s.x > camera.x && s.x < camera.x + camera.width && s.y > camera.y && s.y < camera.y + camera.height) { this.ctx.fillStyle = `rgba(255, 255, 220, ${s.opacity * 0.6})`; this.ctx.beginPath(); this.ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); this.ctx.fill(); } }); this.ctx.restore(); }
}
class Camera {
    constructor(target, width, height) { this.target = target; this.width = width; this.height = height; this.x = 0; this.y = 0; }
    update() { if(this.target.isDead && !this.target.isGhost) return; this.x = this.target.x - this.width / 2; this.y = this.target.y - this.height / 2; this.x = Math.max(0, Math.min(this.x, game.world.width - this.width)); this.y = Math.max(0, Math.min(this.y, game.world.height - this.height)); }
}
class Entity {
    constructor(x, y, size, color, icon) { this.x = x; this.y = y; this.size = size; this.color = color; this.icon = icon; this.isDead = false; }
    draw(ctx, camera, player) { if(this.isDead && this instanceof Player) ctx.globalAlpha = 0.5; ctx.fillStyle = "rgba(0,0,0,0.3)"; ctx.beginPath(); ctx.ellipse(this.x, this.y + this.size/2, this.size/2, this.size/4, 0, 0, 2*Math.PI); ctx.fill(); ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`; ctx.fillStyle = this.color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.icon, this.x, this.y); ctx.globalAlpha = 1.0; }
    update(deltaTime, world, entities) {}
}
class Character extends Entity {
    constructor(x, y, size, color, icon, name) { super(x, y, size, color, icon); this.name = name; this.level = 1; this.stats = { strength: 5, agility: 5, stamina: 5, intellect: 5, spirit: 5, health: 100, maxHealth: 100, mana: 100, maxMana: 100, attack: 5, armor: 0, critChance: 5, dodgeChance: 5 }; this.target = null; this.buffs = []; this.threatTable = new Map(); }
    
    recalculateStats() {
        // Base stats are inherent
        const baseStats = { ...this.baseStats };
        // Apply gear stats
        if (this.equipment) {
            for (const slot in this.equipment) {
                const item = this.equipment[slot];
                if (item && item.stats) {
                    for (const stat in item.stats) { baseStats[stat] = (baseStats[stat] || 0) + item.stats[stat]; }
                }
            }
        }
        // Apply talent % bonuses
        if (this.statBonuses) {
            if (this.statBonuses.staminaBonus) baseStats.stamina *= (1 + this.statBonuses.staminaBonus);
        }
        // Apply buffs/debuffs
        this.buffs.forEach(buff => { if (buff.stats) { for (const stat in buff.stats) { baseStats[stat] = (baseStats[stat] || 0) + buff.stats[stat]; } } });
        
        this.stats = { ...this.baseStats, ...baseStats }; // Merge them
        this.stats.maxHealth = this.stats.stamina * 10;
        this.stats.maxMana = this.stats.intellect * 10;
        this.stats.attack = 5 + (this.stats.strength * 0.5);
        this.stats.critChance = 5 + (this.stats.agility * 0.2);
        this.stats.dodgeChance = 5 + (this.stats.agility * 0.25);
    }
    
    update(deltaTime) {
        // Buffs/Debuffs update
        this.buffs.forEach(buff => {
            buff.duration -= deltaTime;
            if (buff.onTick) {
                buff.tickTimer = (buff.tickTimer || 0) + deltaTime;
                if (buff.tickTimer >= buff.tickRate) {
                    buff.onTick(this);
                    buff.tickTimer = 0;
                }
            }
        });
        const expiredBuffs = this.buffs.some(b => b.duration <= 0);
        if (expiredBuffs) {
            this.buffs = this.buffs.filter(b => b.duration > 0);
            this.recalculateStats();
        }
    }

    addBuff(buff) {
        const existing = this.buffs.find(b => b.id === buff.id);
        if (existing) { // Re-apply, just refresh duration
            existing.duration = buff.duration;
            return;
        }
        this.buffs.push({ ...buff, tickTimer: 0 });
        if (buff.stats) this.recalculateStats();
    }
    
    takeDamage(amount, type, source, isDot = false) {
        if (this.isDead) return;
        // Dodge check for physical attacks
        if (type === 'physical' && !isDot && Math.random() * 100 < this.stats.dodgeChance) {
            game.createFloatingText('Dodge', this.x, this.y, '#fff', 'miss');
            return;
        }

        // Crit check
        let isCrit = false;
        if (!isDot && source && source.stats.critChance && Math.random() * 100 < source.stats.critChance) {
            amount *= 2; // Double damage on crit
            isCrit = true;
        }
        
        let finalAmount = amount; if(type === 'physical') { const mitigation = 1 - (this.stats.armor / (this.stats.armor + 400 + 85 * this.level)); finalAmount = Math.max(1, amount * mitigation); }
        finalAmount = Math.round(finalAmount); this.stats.health = Math.max(0, this.stats.health - finalAmount);
        
        if (this instanceof Player) {
            game.ui.updatePlayerFrame(this); // BUG FIX: Immediately update UI on damage taken.
            this.fiveSecondRuleTimer = 5000; // Reset 5 sec rule on taking damage
        }
        // Threat generation
        if(source) {
            const currentThreat = this.threatTable.get(source) || 0;
            this.threatTable.set(source, currentThreat + finalAmount * (isCrit ? 1.5 : 1));
        }

        const color = type === 'physical' ? '#fff' : '#87ceeb'; game.createFloatingText(finalAmount, this.x, this.y, color, isCrit ? 'crit' : '');
        if (this.stats.health === 0) this.die(source);
    }
    
    heal(amount, source) {
        this.stats.health = Math.min(this.stats.maxHealth, this.stats.health + amount);
        if (this instanceof Player) { 
            game.ui.updatePlayerFrame(this); // BUG FIX: Immediately update UI on healing.
        }
        // Threat generation for healing
        if(source && this.inCombatTimer > 0) {
            const healerThreat = this.threatTable.get(source) || 0;
            this.threatTable.set(source, healerThreat + amount * 0.5);
        }
        game.createFloatingText(amount, this.x, this.y, 'lightgreen');
    }

    die(killer) { if (this.isDead) return; this.isDead = true; ParticleSystem.create(this.x, this.y, '#777', 30, 0.5); }
    setTarget(entity) { if (this.target) this.target.isTargeted = false; this.target = entity; if (this.target) this.target.isTargeted = true; }
    getAttackDamage() { return this.stats.attack; }
    draw(ctx, camera, player) { super.draw(ctx, camera, player); if (this.stats.health < this.stats.maxHealth || this.isTargeted) { const barWidth = this.size * 2; const barHeight = 5; const barY = this.y + this.size / 2 + 10; ctx.fillStyle = '#333'; ctx.fillRect(this.x - barWidth / 2, barY, barWidth, barHeight); const healthPercent = this.stats.health / this.stats.maxHealth; ctx.fillStyle = this instanceof Player ? '#28a745' : '#dc3545'; ctx.fillRect(this.x - barWidth / 2, barY, barWidth * healthPercent, barHeight); } if(this.isTargeted) { ctx.strokeStyle = '#ffc107'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(this.x, this.y + this.size/2, this.size/1.5, this.size/3, 0, 0, 2*Math.PI); ctx.stroke(); } }
}

class Player extends Character {
    constructor(x, y, input) {
        super(x, y, 30, '#ddd', '\uf007', 'Hero');
        this.input = input; this.speed = 3.5; this.xp = 0; this.restedXp = 0;
        this.nextLevelXp = GameData.XP_TABLE[this.level]; this.gold = 5000;
        this.inventory = new Array(16).fill(null);
        this.equipment = { 'main-hand': null, 'chest': null };
        this.baseStats = { ...this.stats }; // Store a copy of initial stats
        this.statBonuses = {};
        this.talentBonuses = {};
        this.talents = {}; this.talentPoints = 0;
        this.reputation = {}; 
        // --- NEW: Initialize reputation for all factions
        for(const factionId in GameData.FACTIONS) {
            this.reputation[factionId] = GameData.FACTIONS[factionId].base;
        }
        // --- END NEW ---
        this.professions = { Herbalism: { level: 1, xp: 0 }, Mining: { level: 1, xp: 0 }, Woodworking: { level: 0, xp: 0 } }; // NEW: profession objects with xp
        this.recipes = []; // NEW: Player's learned crafting recipes
        
        this.hotbar = new Array(10).fill(null);
        this.spellbook = [];
        this.addAbilityToSpellbook(1); this.addAbilityToSpellbook(2); this.addAbilityToSpellbook(3);
        this.hotbar[0] = { type: 'ability', ref: GameData.ABILITIES[1] };
        this.hotbar[1] = { type: 'ability', ref: GameData.ABILITIES[2] };
        
        this.cooldowns = {}; this.quests = []; this.autoAttackTimer = 0; this.attackSpeed = 2000;
        this.inCombatTimer = 0; this.fiveSecondRuleTimer = 0;
        
        this.isGhost = false; this.corpse = null;
        this.isResting = false;
        
        this.isAutoQuesting = false;
        this.autoQuest = null; 
        this.autoMoveTarget = null;
        // --- NEW: Quest cooldowns ---
        this.questCooldowns = {};
        // --- END NEW ---

        this.addItem(1, 1); this.addItem(5, 3);
        this.recalculateStats();
        this.stats.health = this.stats.maxHealth;
        this.stats.mana = this.stats.maxMana;
    }

    update(deltaTime) {
        super.update(deltaTime);
        if (this.isDead && !this.isGhost) return;
        
        if (this.isGhost) {
            if (this.corpse && distance(this, this.corpse) < this.size) {
                this.resurrectAtCorpse();
            }
        }

        this.updateAutoQuest();

        let moveVector = { x: 0, y: 0 };
        if (this.isAutoQuesting && this.autoMoveTarget) {
            const angle = Math.atan2(this.autoMoveTarget.y - this.y, this.autoMoveTarget.x - this.x);
             if (distance(this, this.autoMoveTarget) > 5) {
                moveVector.x = Math.cos(angle);
                moveVector.y = Math.sin(angle);
            } else {
                 this.autoMoveTarget = null;
            }
        } else if (!this.isAutoQuesting) {
            moveVector = this.input.getMoveVector();
        }
        
        if (moveVector.x !== 0 || moveVector.y !== 0) {
            if (moveVector.x !== 0 && moveVector.y !== 0) {
                moveVector.x *= 0.7071;
                moveVector.y *= 0.7071;
            }
            this.x += moveVector.x * this.speed * (this.isGhost ? 1.5 : 1) * (deltaTime / 16.67);
            this.y += moveVector.y * this.speed * (this.isGhost ? 1.5 : 1) * (deltaTime / 16.67);
            this.x = Math.max(this.size/2, Math.min(this.x, game.world.width - this.size/2));
            this.y = Math.max(this.size/2, Math.min(this.y, game.world.height - this.size/2));
        }

        for (const id in this.cooldowns) { this.cooldowns[id] -= deltaTime; if (this.cooldowns[id] <= 0) delete this.cooldowns[id]; }
        // --- NEW: Update quest cooldowns ---
        for (const id in this.questCooldowns) { this.questCooldowns[id] -= deltaTime; if (this.questCooldowns[id] <= 0) delete this.questCooldowns[id]; }
        // --- END NEW ---
        if (!this.isAutoQuesting && !this.isGhost) {
            for(let i = 0; i < 10; i++) { if (this.input.keys[`${(i + 1) % 10}`]) { this.useHotbarSlot(i); this.input.keys[`${(i + 1) % 10}`] = false; } }
        }
        this.autoAttackTimer += deltaTime;
        if(this.target && !this.target.isDead && distance(this, this.target) <= 40 && !this.isGhost) { if (this.autoAttackTimer >= this.attackSpeed) { this.autoAttack(); this.autoAttackTimer = 0; } }
        
        // WoW-like Regen
        if (this.inCombatTimer > 0) { this.inCombatTimer -= deltaTime; if(this.inCombatTimer < 0) this.inCombatTimer = 0; }
        
        this.fiveSecondRuleTimer -= deltaTime;
        const inCombat = this.inCombatTimer > 0;
        const manaRegenActive = !inCombat || this.fiveSecondRuleTimer <= 0;

        // Health Regen (always active out of combat)
        if (!inCombat && this.stats.health < this.stats.maxHealth) {
            const healthRegen = this.stats.spirit * 0.5 * (deltaTime / 1000);
            this.stats.health = Math.min(this.stats.maxHealth, this.stats.health + healthRegen);
        }
        // Mana Regen (active out of combat or if 5 seconds passed since last mana use/damage taken)
        if (manaRegenActive && this.stats.mana < this.stats.maxMana) {
            const manaRegen = this.stats.spirit * 0.8 * (deltaTime / 1000);
            this.stats.mana = Math.min(this.stats.maxMana, this.stats.mana + manaRegen);
        }
        
        // Rested XP
        const wasResting = this.isResting;
        this.isResting = distance(this, RESPAWN_POINT) < 200; // Inn is at spawn for now
        if (this.isResting) {
            this.restedXp += 0.5 * (deltaTime / 1000);
            this.restedXp = Math.min(this.restedXp, this.nextLevelXp * 1.5); // Max 1.5 levels of rested
        }
    }
    
    toggleAutoQuest(quest) {
        if (!quest) return;
        if (this.isAutoQuesting && this.autoQuest && this.autoQuest.id === quest.id) {
            this.isAutoQuesting = false;
            this.autoQuest = null;
            this.autoMoveTarget = null;
            this.setTarget(null);
        } else {
            if(this.isAutoQuesting) this.toggleAutoQuest(this.autoQuest);
            
            this.isAutoQuesting = true;
            this.autoQuest = quest;
            this.autoMoveTarget = null;
        }
        game.ui.updateQuestLog(this);
    }
    
    getBestAbilityRange() {
        let maxRange = 40;
        this.hotbar.forEach(slot => {
            if (slot && slot.type === 'ability' && slot.ref.range > maxRange) {
                maxRange = slot.ref.range;
            }
        });
        return maxRange * 0.9;
    }

    updateAutoQuest() {
        if (!this.isAutoQuesting || !this.autoQuest || this.isGhost) return;

        const isQuestComplete = this.autoQuest.progress.every(p => p.current >= p.count);

        if (isQuestComplete) {
            const giver = this.autoQuest.giver;
            if (giver) {
                this.autoMoveTarget = giver;
                if (distance(this, giver) < 100) {
                    this.autoMoveTarget = null;
                    giver.interact(this, true);
                }
            }
        } else {
            const objective = this.autoQuest.progress.find(p => p.current < p.count);
            if (!objective) { // No objectives remaining
                this.toggleAutoQuest(this.autoQuest);
                return;
            }

            if (objective.type === 'kill') {
                const targetMobType = objective.target;
                const currentTargetIsValid = this.target && !this.target.isDead && this.target.type.name.split(' ')[1].toUpperCase() === targetMobType;
                if (this.target && this.target.isDead) this.setTarget(null);
                
                if (this.target && currentTargetIsValid) {
                    const bestRange = this.getBestAbilityRange();
                    this.autoMoveTarget = this.target;

                    if (distance(this, this.target) <= bestRange) {
                        this.autoMoveTarget = null;
                        for (let i = 0; i < this.hotbar.length; i++) {
                            const slotItem = this.hotbar[i];
                            if (slotItem && slotItem.type === 'ability') {
                                const ability = slotItem.ref;
                                if (!this.cooldowns[ability.id] && this.stats.mana >= ability.cost && distance(this, this.target) <= ability.range) {
                                    this.useHotbarSlot(i);
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    this.autoMoveTarget = null;
                    let closestMob = null;
                    let minDistance = Infinity;
                    for (const entity of game.entities) {
                        if (entity instanceof Enemy && !entity.isDead && entity.type.name.split(' ')[1].toUpperCase() === targetMobType) {
                            const d = distance(this, entity);
                            if (d < minDistance) {
                                minDistance = d;
                                closestMob = entity;
                            }
                        }
                    }
                    if (closestMob) {
                        this.setTarget(closestMob);
                        this.autoMoveTarget = closestMob;
                    } else {
                        if (!this.autoMoveTarget) {
                             this.autoMoveTarget = { x: this.x + (Math.random() * 800 - 400), y: this.y + (Math.random() * 800 - 400) };
                        }
                    }
                }
            } else if (objective.type === 'gather') {
                const targetResourceNode = objective.target;
                const currentTargetIsValid = this.target && this.target instanceof ResourceNode && !this.target.depleted && this.target.type.name.toUpperCase() === targetResourceNode;

                if (this.target && this.target.depleted) this.setTarget(null);

                if (this.target && currentTargetIsValid) {
                    this.autoMoveTarget = this.target;
                    if (distance(this, this.target) < 100) { // Interaction range for nodes
                        this.autoMoveTarget = null;
                        this.target.interact(this);
                        this.setTarget(null); // Clear target after interaction
                    }
                } else {
                    this.autoMoveTarget = null;
                    let closestNode = null;
                    let minDistance = Infinity;
                    for (const entity of game.entities) {
                        if (entity instanceof ResourceNode && !entity.depleted && entity.type.name.toUpperCase() === targetResourceNode) {
                            const d = distance(this, entity);
                            if (d < minDistance) {
                                minDistance = d;
                                closestNode = entity;
                            }
                        }
                    }
                    if (closestNode) {
                        this.setTarget(closestNode);
                        this.autoMoveTarget = closestNode;
                    } else {
                         if (!this.autoMoveTarget) {
                             this.autoMoveTarget = { x: this.x + (Math.random() * 800 - 400), y: this.y + (Math.random() * 800 - 400) };
                        }
                    }
                }
            }
        }
    }

    takeDamage(amount, type, source) { super.takeDamage(amount, type, source); if (!this.isDead) { this.inCombatTimer = 8000; this.fiveSecondRuleTimer = 5000; } }
    
    die(killer) {
        if (this.isDead) return;
        super.die(killer);
        if (this.isAutoQuesting) { this.toggleAutoQuest(this.autoQuest); }
        game.ui.showDeathScreen();
        // Durability loss on death
        Object.values(this.equipment).forEach(item => { if (item) item.durability = Math.max(0, item.durability - 10); });
        this.corpse = new PlayerCorpse(this.x, this.y);
        game.entities.push(this.corpse);
    }

    releaseSpirit() {
        if (!this.isDead || this.isGhost) return;
        this.isGhost = true;
        this.x = GRAVEYARD_POINT.x;
        this.y = GRAVEYARD_POINT.y;
        this.setTarget(null);
        game.ui.hideDeathScreen();
    }
    
    resurrectAtCorpse() {
        this.isDead = false;
        this.isGhost = false;
        this.stats.health = this.stats.maxHealth * 0.5;
        this.stats.mana = this.stats.maxMana * 0.5;
        this.x = this.corpse.x;
        this.y = this.corpse.y;
        this.corpse.isDead = true; // Mark for removal
        game.entities = game.entities.filter(e => e !== this.corpse);
        this.corpse = null;
        game.ui.updateAll(this);
    }
    
    resurrectAtHealer() {
        this.isDead = false;
        this.isGhost = false;
        this.x = this.x; this.y = this.y;
        this.addBuff({ id: 'res_sickness', name: 'Resurrection Sickness', icon: 'fa-skull', duration: 60000, isDebuff: true, stats: { strength: -10, agility: -10, stamina: -10, intellect: -10, spirit: -10 } });
        // Sickness also reduces durability further
        Object.values(this.equipment).forEach(item => { if (item) item.durability = Math.max(0, item.durability - 15); });
        this.recalculateStats();
        this.stats.health = this.stats.maxHealth * 0.25;
        this.stats.mana = this.stats.maxMana * 0.25;
        game.ui.updateAll(this);
    }

    autoAttack() { if (!this.target) return; ParticleSystem.create(this.target.x, this.target.y, 'white', 10, 0.1, 8); this.target.takeDamage(this.getAttackDamage(), 'physical', this); this.inCombatTimer = 8000; }
    useHotbarSlot(index) { const slotItem = this.hotbar[index]; if (!slotItem || this.isGhost) return; if(slotItem.type === 'ability') { const ability = slotItem.ref; if (this.cooldowns[ability.id] || !this.target || this.target.isDead) return; if(distance(this, this.target) > ability.range) { if(!this.isAutoQuesting) game.createFloatingText("Out of range", this.x, this.y, "yellow"); return; } if (this.stats.mana < ability.cost) { if(!this.isAutoQuesting) game.createFloatingText("Not enough mana", this.x, this.y, "blue"); return; } this.stats.mana -= ability.cost; ability.onUse(this, this.target); this.cooldowns[ability.id] = ability.cooldown; this.inCombatTimer = 8000; this.fiveSecondRuleTimer = 5000; game.ui.updatePlayerFrame(this); } else if (slotItem.type === 'item') { const item = slotItem.ref; if (item.slot === 'consumable' && item.onUse) { item.onUse(this); item.quantity--; if(item.quantity <= 0) { const invIndex = this.inventory.findIndex(i => i && i.id === item.id); if (invIndex > -1) this.inventory[invIndex] = null; this.hotbar[index] = null; } game.ui.updateInventory(this); game.ui.setupActionbar(this); } } }
    setHotbarSlot(hotbarIndex, source, sourceIndex) { const item = source === 'inventory' ? this.inventory[sourceIndex] : this.spellbook[sourceIndex]; if (item) { let type; if (item.slot === 'consumable') type = 'item'; else if (item.cost !== undefined) type = 'ability'; else return; this.hotbar[hotbarIndex] = { type: type, ref: item }; game.ui.setupActionbar(this); } }
    addXp(amount) { let bonusXp = 0; if (this.restedXp > 0) { bonusXp = Math.min(this.restedXp, amount); this.restedXp -= bonusXp; } const totalXp = amount + bonusXp; this.xp += totalXp; game.createFloatingText(`${amount} XP` + (bonusXp > 0 ? ` (+${bonusXp})` : ''), this.x, this.y - 20, bonusXp > 0 ? '#00bfff' : '#b636d1'); while(this.xp >= this.nextLevelXp && this.level < GameData.XP_TABLE.length -1) this.levelUp(); game.ui.updateXPBar(this); }
    levelUp() { this.xp -= this.nextLevelXp; this.level++; this.talentPoints++; this.nextLevelXp = GameData.XP_TABLE[this.level] || 99999; this.baseStats.strength += 2; this.baseStats.agility += 1; this.baseStats.stamina += 2; this.baseStats.intellect += 1; this.baseStats.spirit += 1; this.recalculateStats(); this.stats.health = this.stats.maxHealth; this.stats.mana = this.stats.maxMana; game.createFloatingText('LEVEL UP!', this.x, this.y, 'gold', 'crit'); ParticleSystem.create(this.x, this.y, 'gold', 50, 1.5, 30); }
    recalculateStats() {
        this.baseStats.maxHealth = this.baseStats.stamina * 10;
        this.baseStats.maxMana = this.baseStats.intellect * 10;
        this.statBonuses = {}; this.stats = {...this.baseStats}; this.talentBonuses = {};
        for(const talentId in this.talents) { const talentData = GameData.TALENTS.WARRIOR.find(t=>t.id === talentId); if(talentData) talentData.apply(this, this.talents[talentId]); }
        super.recalculateStats();
    }
    
    learnTalent(talentId) {
        if(this.talentPoints <= 0) return;
        const talentData = GameData.TALENTS.WARRIOR.find(t => t.id === talentId);
        if(!talentData) return;
        const currentRank = this.talents[talentId] || 0;
        if(currentRank >= talentData.maxRank) return;
        
        this.talents[talentId] = currentRank + 1;
        this.talentPoints--;
        this.recalculateStats();
        game.ui.updateAll(this);
    }

    addAbilityToSpellbook(abilityId) { const abilityData = GameData.ABILITIES[abilityId]; if (abilityData && !this.spellbook.find(a => a.id === abilityId)) this.spellbook.push(abilityData); }
    // --- NEW: Player learns recipe
    addRecipe(recipeId) { 
        const recipeData = GameData.CRAFTING_RECIPES[recipeId];
        if (recipeData && !this.recipes.find(r => r.id === recipeId)) {
            this.recipes.push(recipeData);
            game.createFloatingText(`New Recipe: ${recipeData.name}!`, this.x, this.y - 80, 'cyan');
        }
    }
    // --- END NEW ---
    
    addItem(itemId, quantity = 1) { const itemData = { ...GameData.ITEMS[itemId] }; if (!itemData) return; if(itemData.stackable) { const existingStack = this.inventory.find(item => item && item.id === itemId); if (existingStack) { existingStack.quantity += quantity; return; } } const emptySlotIndex = this.inventory.findIndex(slot => slot === null); if (emptySlotIndex !== -1) { this.inventory[emptySlotIndex] = { ...itemData, quantity }; } else { game.createFloatingText("Inventory Full", this.x, this.y, 'red'); } }
    // --- NEW: Remove Item (for selling/crafting) ---
    removeItem(itemId, quantity = 1) {
        const itemIndex = this.inventory.findIndex(item => item && item.id === itemId && item.quantity >= quantity);
        if (itemIndex > -1) {
            this.inventory[itemIndex].quantity -= quantity;
            if (this.inventory[itemIndex].quantity <= 0) {
                this.inventory[itemIndex] = null;
            }
            // Also update hotbar if item quantity changes to 0
            this.hotbar.forEach((slot, idx) => {
                if (slot && slot.type === 'item' && slot.ref.id === itemId && slot.ref.quantity <= 0) {
                    this.hotbar[idx] = null;
                }
            });
            return true;
        }
        return false;
    }
    // --- END NEW ---
    
    addReputation(factionId, value) {
        if (!this.reputation[factionId]) this.reputation[factionId] = GameData.FACTIONS[factionId].base;
        this.reputation[factionId] += value;
        // Clamp reputation to max/min values if they exist in faction data
        const factionData = GameData.FACTIONS[factionId];
        if (factionData && factionData.values) {
            this.reputation[factionId] = Math.max(factionData.values[0], Math.min(this.reputation[factionId], factionData.values[factionData.values.length - 1]));
        }
        game.createFloatingText(`${value > 0 ? '+' : ''}${value} ${GameData.FACTIONS[factionId].name} Rep`, this.x, this.y-60, value > 0 ? 'lightgreen' : 'red');
    }
    
    getRepairCost() { let totalCost = 0; Object.values(this.equipment).forEach(item => { if (item) { const damage = item.maxDurability - item.durability; totalCost += damage * 5; } }); return totalCost; }
    repairAllItems() { Object.values(this.equipment).forEach(item => { if (item) item.durability = item.maxDurability; }); }

    addQuest(questId, giver) {
        // --- NEW: Check quest cooldowns ---
        if (this.questCooldowns[questId]) {
            game.createFloatingText("Quest on cooldown!", this.x, this.y, 'red');
            return;
        }
        // --- END NEW ---

        if(this.quests.find(q => q.id === questId)) return;
        const questData = GameData.QUESTS[questId];
        const questState = { ...questData, progress: questData.objectives.map(o => ({ ...o, current: 0 })), giver: giver };
        this.quests.push(questState);
        game.ui.updateQuestLog();
    }
    updateQuestProgress(type, target) { this.quests.forEach(quest => { quest.progress.forEach(obj => { if (obj.type === type && obj.target === target && obj.current < obj.count) { obj.current++; game.createFloatingText(`${obj.target}: ${obj.current}/${obj.count}`, this.x, this.y - 40, '#ffd700'); game.ui.updateQuestLog(); } }); }); }
    
    // --- NEW: Player crafts an item ---
    craftItem(recipeId) {
        const recipe = GameData.CRAFTING_RECIPES[recipeId];
        if (!recipe) return false;

        // Check profession level
        const profession = this.professions[recipe.profession];
        if (!profession || profession.level < recipe.skillRequired) {
            game.createFloatingText("Skill too low!", this.x, this.y, 'red');
            return false;
        }

        // Check materials
        let hasMaterials = true;
        for (const mat of recipe.materials) {
            const playerMat = this.inventory.find(item => item && item.id === mat.itemId);
            if (!playerMat || playerMat.quantity < mat.quantity) {
                hasMaterials = false;
                game.createFloatingText("Missing materials!", this.x, this.y, 'red');
                break;
            }
        }
        if (!hasMaterials) return false;

        // Consume materials
        for (const mat of recipe.materials) {
            this.removeItem(mat.itemId, mat.quantity);
        }

        // Add crafted item
        this.addItem(recipe.itemId, 1);
        game.createFloatingText(`Crafted: ${recipe.name}`, this.x, this.y, 'lightgreen');

        // Gain profession XP
        this.gainProfessionXp(recipe.profession, 10); // Example XP gain
        game.ui.updateAll(this);
        return true;
    }

    // --- NEW: Gain profession XP ---
    gainProfessionXp(professionName, amount) {
        const profession = this.professions[professionName];
        if (!profession) return;

        const professionData = GameData.PROFESSIONS[professionName];
        if (!professionData) return;

        if (profession.level >= professionData.maxLevel) return;

        profession.xp += amount;
        game.createFloatingText(`+${amount} ${professionName} XP`, this.x, this.y - 60, 'lightgray');

        while (profession.xp >= professionData.nextLevelXp && profession.level < professionData.maxLevel) {
            profession.xp -= professionData.nextLevelXp;
            profession.level++;
            // Simple linear progression for now, could add more complex scaling
            professionData.nextLevelXp += 50; 
            game.createFloatingText(`${professionName} Level Up!`, this.x, this.y - 100, 'gold');
        }
    }
    // --- END NEW ---

    draw(ctx, camera, player) { if (this.isGhost) { ctx.globalAlpha = 0.6; ctx.fillStyle = "#a0c4ff"; ctx.font = `900 ${this.size}px "Font Awesome 6 Free"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('\uf6e1', this.x, this.y); ctx.globalAlpha = 1.0; } else { super.draw(ctx, camera, player); } }
}
class NPC extends Character {
    constructor(x, y, name, icon, color) { super(x, y, 28, color || '#00ff00', icon || '\uf0c0', name); this.isInteractable = true; }
    draw(ctx, camera, player) { super.draw(ctx, camera, player); ctx.font = '14px Verdana'; ctx.fillStyle = this.color; ctx.textAlign = 'center'; ctx.fillText(this.name, this.x, this.y - this.size); }
    interact(player) {}
}

class GenericNPC extends NPC {
    constructor(x, y, type) { 
        super(x, y, type.name, type.icon, type.color); 
        this.interactType = type.interactType;
        this.sells = type.sells; // NEW: What this vendor sells
        this.buys = type.buys;   // NEW: What this vendor buys (item types)
        this.baseInteraction = type.interaction; // NEW: Store the base interaction if it's not a generic vendor/trainer
        this.profession = type.profession; // NEW: If it's a trainer
    }
    interact(player) { 
        if (player.isGhost) return; // Ghosts cannot interact with living NPCs
        if (this.interactType === 'vendor') {
            game.ui.openVendorWindow(player, this);
        } else if (this.interactType === 'crafting_trainer') {
            if (this.baseInteraction) {
                this.baseInteraction(player);
            }
        } else {
            if (this.baseInteraction) {
                this.baseInteraction(player);
            } else {
                alert(`Hello, ${player.name}. I am ${this.name}.`);
            }
        }
    }
}

// --- NEW: Crafting Station Entity ---
class CraftingStation extends Entity {
    constructor(x, y, typeData) {
        super(x, y, typeData.size || 30, typeData.color, typeData.icon);
        this.name = typeData.name;
        this.type = typeData.type;
        this.recipes = typeData.recipes;
        this.isInteractable = true;
    }

    draw(ctx, camera, player) {
        super.draw(ctx, camera, player);
        ctx.font = '14px Verdana';
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center';
        ctx.fillText(this.name, this.x, this.y - this.size);
    }

    interact(player) {
        if (player.isGhost) return;
        game.ui.openCraftingWindow(player, this);
    }
}
// --- END NEW ---

class PlayerCorpse extends Entity {
    constructor(x, y) { super(x, y, 30, '#ff4500', '\uf521'); this.isInteractable = false; }
    draw(ctx, camera, player) {
        if (player.isGhost) {
            ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
            ctx.beginPath();
            ctx.arc(this.x, this.y, 40, 0, 2*Math.PI);
            ctx.fill();
        }
        super.draw(ctx, camera, player);
    }
}

class ResourceNode extends Entity {
    constructor(x, y, type) { super(x, y, type.size, type.color, type.icon); this.type = type; this.isInteractable = true; this.depleted = false; }
    interact(player) {
        if (this.depleted || player.isGhost) return;
        // --- NEW: Check profession object for level ---
        const profession = player.professions[this.type.requiredSkill];
        if (profession && profession.level > 0) {
            this.depleted = true;
            this.icon = '\uf2d3'; // an empty/used icon
            this.color = '#555';
            player.addItem(this.type.itemId, 1);
            game.createFloatingText(`+1 ${this.type.name}`, player.x, player.y - 20, 'white');
            game.ui.updateInventory(player);
            // --- NEW: Gain profession XP from gathering ---
            player.gainProfessionXp(this.type.requiredSkill, 5); // Example XP gain
            // --- END NEW ---
            setTimeout(() => {
                this.depleted = false;
                this.icon = this.type.icon;
                this.color = this.type.color;
            }, this.type.respawnTime);
        } else {
            game.createFloatingText(`Requires ${this.type.requiredSkill}`, player.x, player.y, 'red');
        }
    }
    draw(ctx, camera, player) { super.draw(ctx, camera, player); if (!this.depleted) { ctx.font = '12px Verdana'; ctx.fillStyle = this.type.color; ctx.textAlign = 'center'; ctx.fillText(this.type.name, this.x, this.y - this.size); } }
}

class QuestGiver extends NPC {
    constructor(x, y, name, questIds) { super(x, y, name, '\uf70e', '#ffd700'); this.questIds = questIds; }
    getQuestStatus(player) { 
        for (const questId of this.questIds) { 
            const playerQuest = player.quests.find(q => q.id === questId); 
            if (playerQuest) { 
                if (playerQuest.progress.every(p => p.current >= p.count)) return 'complete'; 
            } else {
                // --- NEW: Check if quest is on cooldown ---
                if (player.questCooldowns[questId]) {
                    // It's available, but on cooldown. Still "available" but not interactable.
                    // For now, we'll return 'none' as if no quest is available for simplicity in icon.
                    // A more complex system would show a grey '!' or a timer.
                    continue; 
                }
                // --- END NEW ---
                return 'available'; 
            }
        } 
        return 'none'; 
    }
    draw(ctx, camera, player) { super.draw(ctx, camera, player); if(player.isGhost) return; const status = this.getQuestStatus(player); let questIcon = ''; if (status === 'available') questIcon = '!'; if (status === 'complete') questIcon = '?'; if (questIcon) { ctx.font = 'bold 30px Arial'; ctx.fillStyle = '#ffd700'; ctx.fillText(questIcon, this.x, this.y - this.size - 25); } }
    
    interact(player, isAutomatic = false) {
        if(player.isGhost) return;
        const status = this.getQuestStatus(player);
        // Find the first quest this giver offers that is relevant to the player
        const questId = this.questIds.find(qId => {
            const playerQuest = player.quests.find(q => q.id === qId);
            const questData = GameData.QUESTS[qId];
            if (playerQuest) {
                return playerQuest.progress.every(p => p.current >= p.count); // Return if complete
            } else {
                return !player.questCooldowns[qId]; // Return if available and not on cooldown
            }
        });

        if (!questId) { // No quests available from this NPC
            if (!isAutomatic) {
                alert(`Hello, ${player.name}. I have no tasks for you at the moment.`);
            }
            return;
        }

        const questData = GameData.QUESTS[questId];
        const playerQuestInstance = player.quests.find(q => q.id === questId);

        if (!playerQuestInstance) { // Quest is available to accept
            if (!isAutomatic && confirm(`Quest: ${questData.title}\n\n${questData.description}\n\nAccept quest?`)) {
                player.addQuest(questId, this);
            }
        } else if (playerQuestInstance.progress.every(p => p.current >= p.count)) { // Quest is complete to turn in
            if (!isAutomatic) {
                alert(`Quest Complete: ${questData.title}\nYou receive ${UI.formatCurrency(questData.rewards.gold)} and ${questData.rewards.xp} XP.`);
            } else {
                game.createFloatingText(`Quest Complete: ${questData.title}`, player.x, player.y - 60, 'gold');
            }
            player.addXp(questData.rewards.xp);
            player.gold += questData.rewards.gold;
            if (questData.rewards.reputation) player.addReputation(questData.rewards.reputation.faction, questData.rewards.reputation.value);
            if (questData.rewards.items) questData.rewards.items.forEach(item => player.addItem(item.id, item.quantity));
            
            player.quests = player.quests.filter(q => q.id !== questId); // Remove completed quest
            
            // --- NEW: Apply quest cooldown if repeatable ---
            if (questData.repeatable && questData.cooldown) {
                player.questCooldowns[questId] = questData.cooldown;
            }
            // --- END NEW ---

            if (player.isAutoQuesting && player.autoQuest && player.autoQuest.id === questId) {
                player.toggleAutoQuest(player.autoQuest); // Stop auto-questing if current quest is completed
            }
            game.ui.updateAll(player);
        } else if (!isAutomatic) { // Quest is accepted but not complete
            alert(`You are currently on quest: ${playerQuestInstance.title}.\nProgress:\n${playerQuestInstance.progress.map(obj => `${obj.target}: ${obj.current}/${obj.count}`).join('\n')}`);
        }
    }
}
class Enemy extends Character {
    constructor(x, y, type) { super(x, y, type.size, type.color, type.icon, type.name); this.type = type; this.state = 'patrol'; this.patrolTarget = { x: x + (Math.random()*200-100), y: y + (Math.random()*200-100) }; this.stats.health = this.stats.maxHealth = type.health; this.stats.attack = type.attack; this.attackSpeed = type.attackSpeed; this.autoAttackTimer = 0; this.spawnPoint = {x, y}; }
    update(deltaTime, world, entities, player) { if(this.isDead) return; super.update(deltaTime); this.autoAttackTimer += deltaTime; const distToPlayer = distance(this, player); switch(this.state) { case 'patrol': if(distToPlayer < this.type.aggroRadius && !player.isDead && !player.isGhost) { this.state = 'chase'; this.setTarget(player); this.threatTable.set(player, 1); } else { this.moveTowards(this.patrolTarget, deltaTime); if (distance(this, this.patrolTarget) < 10) this.patrolTarget = { x: this.spawnPoint.x + (Math.random()*200-100), y: this.spawnPoint.y + (Math.random()*200-100) }; } break; case 'chase': if (!this.target || this.target.isDead || this.target.isGhost || distance(this, this.spawnPoint) > this.type.aggroRadius * 2) { this.state = 'patrol'; this.setTarget(null); this.threatTable.clear(); this.stats.health = this.stats.maxHealth; this.patrolTarget = this.spawnPoint; } else if (distance(this, this.target) <= this.type.attackRange) { this.state = 'attack'; } else { this.moveTowards(this.target, deltaTime); } break; case 'attack': if (!this.target || this.target.isDead || this.target.isGhost) { this.state = 'patrol'; this.setTarget(null); return; } if (distance(this, this.target) > this.type.attackRange) { this.state = 'chase'; } else { if (this.autoAttackTimer >= this.attackSpeed) { if (this.type.onAttack) this.type.onAttack(this, this.target); else this.target.takeDamage(this.stats.attack, 'physical', this); this.autoAttackTimer = 0; } } break; } }
    moveTowards(target, deltaTime) { const angle = Math.atan2(target.y - this.y, target.x - this.x); this.x += Math.cos(angle) * this.type.speed * (deltaTime / 16.67); this.y += Math.sin(angle) * this.type.speed * (deltaTime / 16.67); }
    die(killer) { super.die(); if (killer instanceof Player) { killer.addXp(this.type.xp); killer.updateQuestProgress('kill', this.type.name.split(" ")[1].toUpperCase()); if(this.type.reputation) killer.addReputation(this.type.reputation.faction, this.type.reputation.value); this.type.lootTable.forEach(item => { if(Math.random() < item.chance) { if(item.gold) { killer.gold += item.gold; game.createFloatingText(`+${UI.formatCurrency(item.gold)}`, this.x, this.y, 'gold'); } if(item.itemId) { const quantity = item.min ? Math.floor(Math.random() * (item.max - item.min + 1)) + item.min : 1; killer.addItem(item.itemId, quantity); const itemData = GameData.ITEMS[item.itemId]; game.createFloatingText(`+ ${itemData.name}`, this.x, this.y - 20, `var(--color-text-${itemData.quality})`); } } }); game.ui.updateInventory(killer); } }
}
class Particle {
    constructor(ctx, x, y, color, size, lifetime, speed) { this.ctx = ctx; this.x = x; this.y = y; this.color = color; this.initialSize = size; this.size = size; this.lifetime = lifetime; this.initialLifetime = lifetime; const angle = Math.random() * Math.PI * 2; this.vx = Math.cos(angle) * speed * (Math.random() * 5); this.vy = Math.sin(angle) * speed * (Math.random() * 5); this.active = true; }
    update(deltaTime) { this.lifetime -= deltaTime; if (this.lifetime <= 0) { this.active = false; return; } this.x += this.vx * (deltaTime / 16.67); this.y += this.vy * (deltaTime / 16.67); this.size = this.initialSize * (this.lifetime / this.initialLifetime); }
    draw() { if(!this.active) return; this.ctx.fillStyle = this.color; this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); this.ctx.fill(); }
}
const ParticleSystem = { particles: [], ctx: null, init(ctx) { this.ctx = ctx; }, create(x, y, color, count = 20, lifetime = 1, speed = 2) { for (let i = 0; i < count; i++) this.particles.push(new Particle(this.ctx, x, y, color, Math.random() * 5 + 2, lifetime * 1000, speed)); }, update(deltaTime) { this.particles = this.particles.filter(p => p.active); this.particles.forEach(p => p.update(deltaTime)); }, draw(camera) { this.ctx.save(); this.ctx.globalCompositeOperation = 'lighter'; this.particles.forEach(p => { if (p.x > camera.x && p.x < camera.x + camera.width && p.y > camera.y && p.y < camera.y + camera.height) p.draw(); }); this.ctx.restore(); } };
class InputHandler {
    constructor(isMobile) { this.keys = {}; this.mouse = { x: 0, y: 0, clicked: false }; this.isMobile = isMobile; isMobile ? this.setupMobileControls() : this.setupDesktopControls(); }
    setupDesktopControls() { window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true); window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false); window.addEventListener('mousedown', (e) => { if(e.target.id === 'game-canvas') this.mouse.clicked = true; }); window.addEventListener('mousemove', (e) => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; }); }
    setupMobileControls() { const joystickArea = $('#joystick-area'); const joystickThumb = $('#joystick-thumb'); this.joystickVector = {x: 0, y: 0}; const handleTouch = (e) => { e.preventDefault(); const joystickRect = joystickArea.getBoundingClientRect(); const centerX = joystickRect.width / 2; const centerY = joystickRect.height / 2; const touch = e.touches[0]; let x = touch.clientX - joystickRect.left - centerX; let y = touch.clientY - joystickRect.top - centerY; const dist = Math.sqrt(x*x + y*y); const maxDist = centerX - joystickThumb.offsetWidth / 2; if (dist > maxDist) { x = (x / dist) * maxDist; y = (y / dist) * maxDist; } joystickThumb.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`; this.joystickVector = { x: x / maxDist, y: y / maxDist }; }; joystickArea.addEventListener('touchstart', handleTouch, { passive: false }); joystickArea.addEventListener('touchmove', handleTouch, { passive: false }); joystickArea.addEventListener('touchend', () => { joystickThumb.style.transform = `translate(-50%, -50%)`; this.joystickVector = { x: 0, y: 0 }; }); $('#game-canvas').addEventListener('touchstart', (e) => { const touch = e.touches[0]; if (touch.clientX > 200 && touch.clientY < window.innerHeight - 100) { this.mouse.x = touch.clientX; this.mouse.y = touch.clientY; this.mouse.clicked = true; } }); }
    getMoveVector() { if(this.isMobile) return this.joystickVector; let vector = { x: 0, y: 0 }; if (this.keys['w']) vector.y -= 1; if (this.keys['s']) vector.y += 1; if (this.keys['a']) vector.x -= 1; if (this.keys['d']) vector.x += 1; return vector; }
}
class UI {
    constructor(game) { this.game = game; this.minimapCanvas = $("#minimap-canvas"); this.mCtx = this.minimapCanvas.getContext("2d"); this.tooltip = $('#tooltip'); this.setupActionbar(game.player); this.setupTooltips(); this.setupDragAndDrop(game.player); }
    update(player, deltaTime) {
        this.updatePlayerFrame(player);
        if (!player.isDead) {
            this.updateTargetFrame(player.target);
            this.updateXPBar(player);
            this.updateCooldowns(player);
        } else {
            this.updateTargetFrame(null);
        }
        this.drawMinimap(player, game.entities);
        $('#res-sickness-overlay').style.display = player.buffs.some(b => b.id === 'res_sickness') ? 'block' : 'none';
        
        // --- NEW: Update open vendor/crafting windows ---
        if ($('#vendor-window').style.display === 'flex') {
            const vendor = game.entities.find(e => e.isTargeted && e.interactType === 'vendor');
            if (vendor) this.updateVendorWindow(player, vendor);
            else $('#vendor-window').style.display = 'none'; // Close if vendor is no longer targeted
        }
        if ($('#crafting-window').style.display === 'flex') {
            const station = game.entities.find(e => e.isTargeted && e instanceof CraftingStation);
            if (station) this.updateCraftingWindow(player, station);
            else $('#crafting-window').style.display = 'none'; // Close if station is no longer targeted
        }
        // --- END NEW ---
    }
    updateAll(player) { this.updatePlayerFrame(player); this.updateTargetFrame(player.target); this.updateCharacterSheet(player); this.updateInventory(player); this.updateXPBar(player); this.updateQuestLog(player); this.updateTalentWindow(player); this.updateSpellbook(player); this.updateReputationWindow(player); }
    updatePlayerFrame(player) { $('#player-name').textContent = player.name; $('#player-level').textContent = `Lvl ${player.level}`; $('#player-health-text').textContent = `${Math.ceil(player.stats.health)} / ${player.stats.maxHealth}`; $('#player-health-fill').style.width = `${(player.stats.health / player.stats.maxHealth) * 100}%`; $('#player-mana-text').textContent = `${Math.ceil(player.stats.mana)} / ${player.stats.maxMana}`; $('#player-mana-fill').style.width = `${(player.stats.mana / player.stats.maxMana) * 100}%`; this.updateBuffs(player, 'player-buffs'); }
    updateTargetFrame(target) { const frame = $('#target-frame'); if (target && !target.isDead) { frame.style.display = 'flex'; $('#target-portrait').innerHTML = `<i class="fas ${target.icon.substring(1)}"></i>`; $('#target-portrait').style.color = target.color; $('#target-name').textContent = target.name; $('#target-level').textContent = `Lvl ${target.level}`; $('#target-health-text').textContent = `${Math.ceil(target.stats.health)} / ${target.stats.maxHealth}`; $('#target-health-fill').style.width = `${(target.stats.health / target.stats.maxHealth) * 100}%`; this.updateBuffs(target, 'target-buffs'); } else { frame.style.display = 'none'; } }
    updateXPBar(player) {
        const xpPercent = (player.xp / player.nextLevelXp) * 100;
        const restedPercent = (player.restedXp / player.nextLevelXp) * 100;
        $('#xp-bar-fill').style.width = `${xpPercent}%`;
        $('#xp-bar-rested-fill').style.width = `${Math.min(100 - xpPercent, restedPercent)}%`;
        $('#xp-bar').title = `XP: ${player.xp} / ${player.nextLevelXp}\nRested: ${Math.floor(player.restedXp)}`;
    }

    setupActionbar(player) {
        const bar = $('#action-bar'); bar.innerHTML = '';
        for (let i = 0; i < 10; i++) {
            const slotItem = player.hotbar[i]; const slot = document.createElement('div');
            slot.className = 'action-slot'; slot.dataset.index = i; slot.dataset.dropTarget = 'hotbar';
            if (slotItem) {
                const ref = slotItem.ref;
                slot.innerHTML = `<i class="fas ${ref.icon} quality-${ref.quality || 'common'}"></i><div class="action-keybind">${(i+1)%10}</div>`;
                if(slotItem.type === 'ability') slot.innerHTML += `<div class="cooldown-overlay" data-ability-id="${ref.id}"></div>`;
                if(slotItem.type === 'item' && ref.quantity > 1) slot.innerHTML += `<div class="hotbar-item-count">${ref.quantity}</div>`;
                slot.addEventListener('click', () => player.useHotbarSlot(i));
            } else { slot.innerHTML = `<div class="action-keybind">${(i+1)%10}</div>`; }
            bar.appendChild(slot);
        }
    }
    updateCooldowns(player) { $$('.cooldown-overlay').forEach(overlay => { const id = overlay.dataset.abilityId; const hotbarItem = player.hotbar.find(h => h && h.type === 'ability' && h.ref.id == id); if(hotbarItem && player.cooldowns[id]) { const remaining = player.cooldowns[id]; const percentage = (remaining / hotbarItem.ref.cooldown) * 100; overlay.style.height = `${percentage}%`; overlay.textContent = (remaining / 1000).toFixed(1); } else { overlay.style.height = '0%'; overlay.textContent = ''; } }); }
    drawMinimap(player, entities) { const size = 150; const range = 400; this.mCtx.clearRect(0, 0, size, size); this.mCtx.fillStyle = 'rgba(0,0,0,0.5)'; this.mCtx.fillRect(0, 0, size, size); entities.forEach(entity => { const dx = entity.x - player.x; const dy = entity.y - player.y; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > range || entity instanceof Player || (entity instanceof ResourceNode && entity.depleted)) return; const mapX = (dx / range) * (size / 2) + (size / 2); const mapY = (dy / range) * (size / 2) + (size / 2); let color = 'gray'; let radius = 3; if(entity instanceof Enemy) color = 'red'; if(entity instanceof QuestGiver) { color = 'yellow'; radius=4; } if(entity instanceof GenericNPC) { color = '#bbb'; } if(entity instanceof ResourceNode) { color = entity.type.color; } if(entity instanceof PlayerCorpse) { color = '#ff4500'; radius = 4; } if (entity instanceof CraftingStation) { color = entity.color; radius = 4;} this.mCtx.fillStyle = color; this.mCtx.beginPath(); this.mCtx.arc(mapX, mapY, radius, 0, 2 * Math.PI); this.mCtx.fill(); }); this.mCtx.fillStyle = player.isResting ? 'cyan' : 'white'; this.mCtx.save(); this.mCtx.translate(size/2, size/2); this.mCtx.beginPath(); this.mCtx.moveTo(0, -5); this.mCtx.lineTo(4, 5); this.mCtx.lineTo(-4, 5); this.mCtx.closePath(); this.mCtx.fill(); this.mCtx.restore(); }
    createFloatingText(text, worldX, worldY, color, camera, type = '') { const textElement = document.createElement('div'); textElement.className = `floating-text ${type}`; textElement.textContent = text; textElement.style.color = color; textElement.style.left = `${worldX - camera.x}px`; textElement.style.top = `${worldY - camera.y}px`; $('#floating-text-container').appendChild(textElement); setTimeout(() => textElement.remove(), 1500); }
    updateCharacterSheet(player) { player.recalculateStats(); $('#character-content').innerHTML = `<div class="stat-line"><span>Health</span><span>${player.stats.maxHealth}</span></div><div class="stat-line"><span>Mana</span><span>${player.stats.maxMana}</span></div><hr><div class="stat-line"><span>Strength</span><span>${Math.floor(player.stats.strength)}</span></div><div class="stat-line"><span>Agility</span><span>${Math.floor(player.stats.agility)}</span></div><div class="stat-line"><span>Stamina</span><span>${Math.floor(player.stats.stamina)}</span></div><div class="stat-line"><span>Intellect</span><span>${Math.floor(player.stats.intellect)}</span></div><div class="stat-line"><span>Spirit</span><span>${Math.floor(player.stats.spirit)}</span></div><hr><div class="stat-line"><span>Attack Power</span><span>${player.getAttackDamage().toFixed(1)}</span></div><div class="stat-line"><span>Crit Chance</span><span>${player.stats.critChance.toFixed(2)}%</span></div><div class="stat-line"><span>Dodge Chance</span><span>${player.stats.dodgeChance.toFixed(2)}%</span></div><div class="stat-line"><span>Armor</span><span>${player.stats.armor}</span></div>`;
        // --- NEW: Add professions to character sheet ---
        let professionsHtml = '<hr><h3>Professions</h3>';
        for (const profName in player.professions) {
            const prof = player.professions[profName];
            const profData = GameData.PROFESSIONS[profName];
            professionsHtml += `<div class="stat-line"><span>${profName}</span><span>Lvl ${prof.level} (${prof.xp}/${profData.nextLevelXp})</span></div>`;
        }
        $('#character-content').innerHTML += professionsHtml;
        // --- END NEW ---
    }
    updateInventory(player) {
        const grid = $('#inventory-grid'); grid.innerHTML = '';
        player.inventory.forEach((item, index) => {
            const slot = document.createElement('div'); slot.className = 'inventory-slot'; slot.dataset.index = index; slot.dataset.source = 'inventory';
            if (item) {
                slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`;
                if(item.stackable && item.quantity > 1) slot.innerHTML += `<div class="item-count">${item.quantity}</div>`;
                slot.dataset.itemId = item.id;
                slot.draggable = true;
                // --- NEW: Add click listener for selling from inventory ---
                slot.addEventListener('click', (e) => {
                    const currentVendor = game.entities.find(entity => entity.isTargeted && entity.interactType === 'vendor');
                    if (currentVendor) {
                        this.sellItemFromInventory(player, item, index, currentVendor);
                    }
                });
                // --- END NEW ---
            }
            grid.appendChild(slot);
        });
        $('#currency').innerHTML = UI.formatCurrency(player.gold, true);
    }
    
    static formatCurrency(amount, useIcons = false) {
        const gold = Math.floor(amount / 10000);
        const silver = Math.floor((amount % 10000) / 100);
        const copper = amount % 100;
        if(useIcons) {
            return `<div class="currency-item">${gold} <div class="currency-icon gold"></div></div> <div class="currency-item">${silver} <div class="currency-icon silver"></div></div> <div class="currency-item">${copper} <div class="currency-icon copper"></div></div>`;
        }
        return `${gold}g ${silver}s ${copper}c`;
    }

    setupDragAndDrop(player) {
        document.body.addEventListener('dragstart', (e) => {
            const slot = e.target.closest('[draggable="true"]');
            if (slot) {
                const source = slot.dataset.source;
                const index = slot.dataset.index;
                e.dataTransfer.setData('text/plain', `${source},${index}`);
                e.dataTransfer.effectAllowed = 'copy';
            }
        });
        document.body.addEventListener('dragover', (e) => {
            e.preventDefault();
            const targetSlot = e.target.closest('.action-slot');
            if (targetSlot) { targetSlot.classList.add('drag-over'); }
        });
        document.body.addEventListener('dragleave', (e) => {
            const targetSlot = e.target.closest('.action-slot');
            if (targetSlot) { targetSlot.classList.remove('drag-over'); }
        });
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            const targetSlot = e.target.closest('.action-slot');
            if (targetSlot) {
                targetSlot.classList.remove('drag-over');
                const hotbarIndex = targetSlot.dataset.index;
                const [source, sourceIndex] = e.dataTransfer.getData('text/plain').split(',');
                player.setHotbarSlot(hotbarIndex, source, sourceIndex);
            }
        });
    }
    
    updateQuestLog(player = this.game.player) {
        const content = $('#quest-log-content');
        content.innerHTML = '';
        if (player.quests.length === 0) {
            content.innerHTML = 'You have no active quests.';
        }

        player.quests.forEach(quest => {
            const item = document.createElement('div');
            item.className = 'quest-item';

            const details = document.createElement('div');
            let objectivesHtml = '';
            quest.progress.forEach(obj => {
                // --- NEW: Handle different objective types ---
                if (obj.type === 'kill') {
                    objectivesHtml += `<div class="quest-objective">- ${obj.target} slain: ${obj.current} / ${obj.count}</div>`;
                } else if (obj.type === 'gather') {
                    objectivesHtml += `<div class="quest-objective">- ${obj.target} gathered: ${player.inventory.filter(i => i && i.name.toUpperCase() === obj.target).reduce((sum, i) => sum + i.quantity, 0)} / ${obj.count}</div>`;
                }
                // --- END NEW ---
            });
            details.innerHTML = `<div class="quest-title">${quest.title}</div>${objectivesHtml}`;
            
            const button = document.createElement('button');
            button.className = 'auto-quest-btn';
            
            if (player.isAutoQuesting && player.autoQuest && player.autoQuest.id === quest.id) {
                button.textContent = 'Stop';
                button.classList.add('active');
            } else {
                button.textContent = 'Auto';
            }
            
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                player.toggleAutoQuest(quest);
            });
            
            item.appendChild(details);
            item.appendChild(button);
            content.appendChild(item);
        });

        // --- NEW: Display quest cooldowns ---
        const cooldownsDiv = document.createElement('div');
        cooldownsDiv.style.marginTop = '10px';
        cooldownsDiv.innerHTML = '<h3>Quest Cooldowns</h3>';
        let hasCooldowns = false;
        for (const questId in player.questCooldowns) {
            const remainingTime = player.questCooldowns[questId];
            if (remainingTime > 0) {
                const questData = GameData.QUESTS[questId];
                const minutes = Math.floor(remainingTime / 60000);
                const seconds = Math.floor((remainingTime % 60000) / 1000);
                cooldownsDiv.innerHTML += `<div class="stat-line"><span>${questData.title}</span><span>${minutes}m ${seconds}s</span></div>`;
                hasCooldowns = true;
            }
        }
        if (hasCooldowns) {
            content.appendChild(cooldownsDiv);
        } else if (player.quests.length === 0) {
            content.innerHTML = 'You have no active quests or quests on cooldown.';
        }
        // --- END NEW ---
    }

    setupTooltips() { document.body.addEventListener('mouseover', (e) => { let itemRef; let description = ''; const slot = e.target.closest('.inventory-slot, .action-slot, .spellbook-slot, .buff-icon, .talent, .vendor-item-slot, .crafting-recipe-slot'); if (!slot) return; if(slot.matches('.inventory-slot[data-item-id], .action-slot')) { let hotbarItem; if(slot.dataset.itemId) { const invIndex = slot.dataset.index; itemRef = game.player.inventory[invIndex]; } else if (slot.dataset.index && (hotbarItem = game.player.hotbar[slot.dataset.index])) { if(hotbarItem) itemRef = hotbarItem.ref; } } else if(slot.matches('.spellbook-slot')) { const spellIndex = slot.dataset.index; itemRef = game.player.spellbook[spellIndex]; } else if(slot.matches('.buff-icon')) { const buffId = slot.dataset.buffId; const parentFrame = slot.closest('.unit-frame').id; const unit = parentFrame === 'player-frame' ? game.player : game.player.target; if(unit) itemRef = unit.buffs.find(b => b.id === buffId); } else if(slot.matches('.talent')) { const talentId = slot.dataset.talentId; itemRef = GameData.TALENTS.WARRIOR.find(t=>t.id === talentId); } else if(slot.matches('.vendor-item-slot')) { const itemId = slot.dataset.itemId; itemRef = GameData.ITEMS[itemId]; } else if (slot.matches('.crafting-recipe-slot')) { const recipeId = slot.dataset.recipeId; itemRef = GameData.CRAFTING_RECIPES[recipeId]; } if (!itemRef) return; let statsHtml = ''; if (itemRef.stats) { statsHtml += '<div class="stats">'; for(const stat in itemRef.stats) statsHtml += `<div style="color: lightgreen">+${itemRef.stats[stat]} ${stat.charAt(0).toUpperCase() + stat.slice(1)}</div>`; statsHtml += '</div>'; } if (itemRef.cost) statsHtml += `<div class="stats"><div>Mana Cost: ${itemRef.cost}</div><div>Cooldown: ${itemRef.cooldown/1000}s</div></div>`; if (itemRef.durability !== undefined) statsHtml += `<div class="durability">Durability: ${itemRef.durability} / ${itemRef.maxDurability}</div>`; description = itemRef.slot || (itemRef.range ? `Range: ${itemRef.range}` : itemRef.description || ''); 
            // --- NEW: Add recipe materials to tooltip ---
            if (itemRef.materials) {
                statsHtml += '<div class="stats">Required:<ul>';
                for (const mat of itemRef.materials) {
                    const matData = GameData.ITEMS[mat.itemId];
                    statsHtml += `<li>${mat.quantity}x ${matData.name}</li>`;
                }
                statsHtml += '</ul></div>';
            }
            // --- END NEW ---
            this.tooltip.innerHTML = `<div class="name quality-${itemRef.quality || 'common'}">${itemRef.name}</div><div class="description">${description}</div>${statsHtml}`; this.tooltip.style.display = 'block'; }); document.body.addEventListener('mousemove', (e) => { if (this.tooltip.style.display === 'block') { let x = e.clientX + 15; let y = e.clientY + 15; if (x + this.tooltip.offsetWidth > window.innerWidth) x = e.clientX - this.tooltip.offsetWidth - 15; if (y + this.tooltip.offsetHeight > window.innerHeight) y = e.clientY - this.tooltip.offsetHeight - 15; this.tooltip.style.left = `${x}px`; this.tooltip.style.top = `${y}px`; } }); document.body.addEventListener('mouseout', (e) => { const slot = e.target.closest('.inventory-slot, .action-slot, .spellbook-slot, .buff-icon, .talent, .vendor-item-slot, .crafting-recipe-slot'); if (slot) this.tooltip.style.display = 'none'; }); }
    makeDraggable(element) { let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0; const header = element.querySelector('.window-header'); const dragMouseDown = (e) => { e.preventDefault(); pos3 = e.clientX; pos4 = e.clientY; document.onmouseup = closeDragElement; document.onmousemove = elementDrag; }; const elementDrag = (e) => { e.preventDefault(); pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY; pos3 = e.clientX; pos4 = e.clientY; element.style.top = (element.offsetTop - pos2) + "px"; element.style.left = (element.offsetLeft - pos1) + "px"; }; const closeDragElement = () => { document.onmouseup = null; document.onmousemove = null; }; if (header) header.onmousedown = dragMouseDown; else element.onmousedown = dragMouseDown; }
    showDeathScreen() { $('#death-screen').style.display = 'flex'; }
    hideDeathScreen() { $('#death-screen').style.display = 'none'; }
    updateTalentWindow(player) {
        $('#talent-points-display').textContent = `Talent Points: ${player.talentPoints}`;
        const tree = $('#talent-tree'); tree.innerHTML = '';
        GameData.TALENTS.WARRIOR.forEach(talent => {
            const currentRank = player.talents[talent.id] || 0;
            const div = document.createElement('div');
            div.className = 'talent';
            div.dataset.talentId = talent.id;
            if (currentRank >= talent.maxRank) div.classList.add('maxed');
            if (player.talentPoints === 0 && currentRank < talent.maxRank) div.classList.add('locked'); // Simple lock if no points
            div.innerHTML = `<div class="talent-icon"><i class="fas ${talent.icon}"></i></div><div class="talent-name">${talent.name}</div><div class="talent-rank">${currentRank} / ${talent.maxRank}</div>`;
            if (!div.classList.contains('locked') && !div.classList.contains('maxed')) {
                div.addEventListener('click', () => player.learnTalent(talent.id));
            }
            tree.appendChild(div);
        });
    }
    updateSpellbook(player) {
        const grid = $('#spellbook-grid'); grid.innerHTML = '';
        player.spellbook.forEach((ability, index) => {
            const slot = document.createElement('div');
            slot.className = 'spellbook-slot';
            slot.dataset.index = index;
            slot.dataset.source = 'spellbook';
            slot.draggable = true;
            slot.innerHTML = `<i class="fas ${ability.icon}"></i>`;
            grid.appendChild(slot);
        });
        // --- NEW: Add recipes to spellbook (as a separate section for clarity) ---
        if (player.recipes.length > 0) {
            const recipeSection = document.createElement('div');
            recipeSection.innerHTML = '<hr><h3>Recipes</h3><div id="spellbook-recipes-grid" class="spellbook-grid"></div>';
            grid.appendChild(recipeSection);
            const recipeGrid = $('#spellbook-recipes-grid');
            player.recipes.forEach((recipe, index) => {
                const slot = document.createElement('div');
                slot.className = 'spellbook-slot';
                slot.dataset.index = index; // Use a different index if merging, or keep separate. For now, separate is simpler.
                slot.dataset.source = 'recipe'; // Mark as recipe for drag/drop
                slot.draggable = true;
                slot.innerHTML = `<i class="fas ${recipe.icon}"></i>`;
                recipeGrid.appendChild(slot);
            });
        }
        // --- END NEW ---
    }
    updateReputationWindow(player) {
        const content = $('#reputation-content'); content.innerHTML = '';
        for (const factionId in GameData.FACTIONS) {
            const faction = GameData.FACTIONS[factionId];
            const playerRep = player.reputation[factionId] || faction.base;
            
            let currentTier = faction.tiers[0];
            for (let i = 0; i < faction.tiers.length; i++) {
                if (playerRep >= faction.values[i]) {
                    currentTier = faction.tiers[i];
                } else {
                    break;
                }
            }
            
            let nextTierValue = '';
            const currentTierIndex = faction.tiers.indexOf(currentTier);
            if (currentTierIndex < faction.tiers.length - 1) {
                nextTierValue = ` / ${faction.values[currentTierIndex + 1]}`;
            }

            content.innerHTML += `<div class="reputation-line"><span>${faction.name} (${currentTier})</span><span>${playerRep}${nextTierValue}</span></div>`;
        }
    }
    updateBuffs(character, containerId) {
        const container = $(`#${containerId}`);
        container.innerHTML = '';
        if(!character) return;
        character.buffs.forEach(buff => {
            const div = document.createElement('div');
            div.className = 'buff-icon';
            if (buff.isDebuff) div.classList.add('debuff');
            div.dataset.buffId = buff.id;
            div.innerHTML = `<i class="fas ${buff.icon}"></i><div class="buff-duration">${(buff.duration/1000).toFixed(0)}</div>`;
            container.appendChild(div);
        });
    }

    // --- NEW: Vendor Window Logic ---
    openVendorWindow(player, vendor) {
        $('#vendor-window').style.display = 'flex';
        this.updateVendorWindow(player, vendor);
        // Set vendor as targeted temporarily to ensure window closes if vendor moves away
        player.setTarget(vendor); 
    }

    updateVendorWindow(player, vendor) {
        const playerInventoryGrid = $('#vendor-player-inventory');
        const vendorSellsGrid = $('#vendor-sells-grid');
        $('#vendor-player-gold').innerHTML = UI.formatCurrency(player.gold, true);

        // Populate player's inventory for selling
        playerInventoryGrid.innerHTML = '';
        player.inventory.forEach((item, index) => {
            if (item && vendor.buys.includes(item.slot)) { // Vendor only buys specific item types/slots
                const slot = document.createElement('div');
                slot.className = 'vendor-item-slot inventory-slot'; // Re-use inventory-slot styles
                slot.dataset.index = index;
                slot.dataset.itemId = item.id;
                slot.innerHTML = `<i class="fas ${item.icon} quality-${item.quality}"></i>`;
                if(item.stackable && item.quantity > 1) slot.innerHTML += `<div class="item-count">${item.quantity}</div>`;
                if(item.sellPrice) slot.innerHTML += `<div class="vendor-item-price">${UI.formatCurrency(item.sellPrice, true)}</div>`;
                
                slot.addEventListener('click', () => this.sellItemFromInventory(player, item, index, vendor));
                playerInventoryGrid.appendChild(slot);
            }
        });

        // Populate vendor's items for buying
        vendorSellsGrid.innerHTML = '';
        if (vendor.sells) {
            vendor.sells.forEach((itemDef, index) => {
                const itemData = GameData.ITEMS[itemDef.itemId];
                if (itemData) {
                    const slot = document.createElement('div');
                    slot.className = 'vendor-item-slot';
                    slot.dataset.itemId = itemData.id;
                    slot.innerHTML = `<i class="fas ${itemData.icon} quality-${itemData.quality}"></i>`;
                    if (itemDef.quantity > 1) slot.innerHTML += `<div class="item-count">${itemDef.quantity}</div>`;
                    slot.innerHTML += `<div class="vendor-item-price">${UI.formatCurrency(itemDef.price, true)}</div>`;

                    slot.addEventListener('click', () => this.buyItemFromVendor(player, itemData, itemDef.price, itemDef.quantity));
                    vendorSellsGrid.appendChild(slot);
                }
            });
        }
    }

    sellItemFromInventory(player, item, index, vendor) {
        if (!item || !item.sellPrice || !vendor.buys.includes(item.slot)) {
            game.createFloatingText("Vendor doesn't buy that!", player.x, player.y, 'red');
            return;
        }

        player.gold += item.sellPrice;
        player.removeItem(item.id, 1);
        game.createFloatingText(`+${UI.formatCurrency(item.sellPrice)}`, player.x, player.y, 'gold');
        this.updateVendorWindow(player, vendor);
        this.updateInventory(player); // Also update main inventory
    }

    buyItemFromVendor(player, itemData, price, quantity) {
        if (player.gold < price) {
            game.createFloatingText("Not enough gold!", player.x, player.y, 'red');
            return;
        }
        if (player.inventory.filter(s => s === null).length === 0 && (!itemData.stackable || !player.inventory.some(i => i && i.id === itemData.id))) {
            game.createFloatingText("Inventory full!", player.x, player.y, 'red');
            return;
        }

        player.gold -= price;
        player.addItem(itemData.id, quantity);
        game.createFloatingText(`-${UI.formatCurrency(price)}`, player.x, player.y, 'red');
        game.createFloatingText(`+ ${itemData.name}`, player.x, player.y - 20, 'white');
        this.updateVendorWindow(player, game.entities.find(e => e.isTargeted && e.interactType === 'vendor'));
        this.updateInventory(player); // Update main inventory too
    }
    // --- END NEW ---

    // --- NEW: Crafting Window Logic ---
    openCraftingWindow(player, station) {
        $('#crafting-window').style.display = 'flex';
        this.updateCraftingWindow(player, station);
        // Set station as targeted temporarily
        player.setTarget(station);
        this.activeCraftingStation = station; // Store reference to current station
        this.selectedRecipe = null; // Clear selected recipe on open
        $('#craft-button').removeEventListener('click', this.boundCraftingHandler); // Clear old listener
        this.boundCraftingHandler = () => player.craftItem(this.selectedRecipe.id); // Bind new one
        $('#craft-button').addEventListener('click', this.boundCraftingHandler);
    }

    updateCraftingWindow(player, station) {
        const recipesGrid = $('#crafting-recipes-grid');
        const materialsDisplay = $('#crafting-materials-display');
        const craftButton = $('#craft-button');
        recipesGrid.innerHTML = '';
        materialsDisplay.innerHTML = '';
        craftButton.disabled = true;

        const availableRecipes = player.recipes.filter(r => station.recipes.includes(r.id));
        if (availableRecipes.length === 0) {
            recipesGrid.innerHTML = '<p>No recipes available for this station.</p>';
            return;
        }

        availableRecipes.forEach(recipe => {
            const slot = document.createElement('div');
            slot.className = 'crafting-recipe-slot';
            slot.dataset.recipeId = recipe.id;
            slot.innerHTML = `<i class="fas ${recipe.icon} quality-${recipe.quality || 'common'}"></i>`;
            slot.innerHTML += `<div class="crafting-recipe-cost">${recipe.name}</div>`; // Using this for name initially

            slot.addEventListener('click', () => {
                this.selectedRecipe = recipe;
                this.updateCraftingWindow(player, station); // Re-render to show selection/materials
            });
            recipesGrid.appendChild(slot);
        });

        if (this.selectedRecipe) {
            materialsDisplay.innerHTML = `<h3>${this.selectedRecipe.name} Requirements:</h3><ul>`;
            let canCraft = true;
            for (const mat of this.selectedRecipe.materials) {
                const playerMat = player.inventory.find(item => item && item.id === mat.itemId);
                const hasEnough = playerMat && playerMat.quantity >= mat.quantity;
                const matData = GameData.ITEMS[mat.itemId];
                materialsDisplay.innerHTML += `<li style="color: ${hasEnough ? 'lightgreen' : 'red'};">${mat.quantity}x ${matData.name} (${playerMat ? playerMat.quantity : 0} owned)</li>`;
                if (!hasEnough) canCraft = false;
            }
            materialsDisplay.innerHTML += `<li>Profession Skill: ${this.selectedRecipe.profession} (${player.professions[this.selectedRecipe.profession].level}/${GameData.PROFESSIONS[this.selectedRecipe.profession].maxLevel})</li>`;
            if (player.professions[this.selectedRecipe.profession].level < this.selectedRecipe.skillRequired) canCraft = false;

            materialsDisplay.innerHTML += '</ul>';
            craftButton.disabled = !canCraft;
            craftButton.textContent = `Craft ${this.selectedRecipe.name}`;
        }
    }
    // --- END NEW ---
}

const game = new Game();
window.game = game;

</script>
</body>
</html>
